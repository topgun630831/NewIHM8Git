/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#define EXTERN extern
#include "stm32f4xx_hal.h"
#include "main.h"
#include "GuiData.h"
#include "math.h"
#include "string.h"

static void AcbMccbMeasurementSend(void);
static void DemandMakeString(uint16_t index, int pos, const char* baseUnit );
static void AcbMccbValueDispDemand(void);
static void AcbMccbMeasurementRecv(void);
static void AcbMccbMeasurementMenu(int pos);
static void AcbMccbValueDispVIP(void);
static void AcbMccbMeasurementDispVIP(void);
static void AcbMccbValueDispEnergy(void);
static void AcbMccbMeasurementDispEnergy(void);
static void AcbMccbValueDispPQ(void);
static void AcbMccbMeasurementDispPQ(void);
static void AcbMccbMeasurementDispDemand(void);
static void AcbMccbMeasurementDisp(int pos, int clear);
static void AcbMccbValueDisp(int pos);
static double localFloor(double value);
static void BaseDisp3(double value, char* mks, const char*baseUnit, char unit[UNIT_BUF_SIZE],  char result[DEFAULT_BUF_SIZE]);
static void DispFormat3(double value, const char* baseUnit, char unit[UNIT_BUF_SIZE], char result[DEFAULT_BUF_SIZE]);

static float VI[VI_COL_MAX][VI_ROW_MAX];
static float P[PE_ROW_MAX];
static double Energy[PE_ROW_MAX];
static float PQ1[PQ1_MAX];
static float PQ2[PQ2_COL_MAX][PQ2_ROW_MAX];
static float Angle[ANGLE_COL_MAX][ANGLE_ROW_MAX];
//static int nMenuPos;
static uint16_t nPfDisplay;
static int	gLocalPols;

// PRQA S 1505 1
static void BaseDisp3(double value, char* mks, const char*baseUnit, char unit[UNIT_BUF_SIZE],  char result[DEFAULT_BUF_SIZE])
{
	(void)sprintf(unit, "%s%s", mks, baseUnit);
	(void)sprintf(result, "%6.3f", value);
}

static double localFloor(double value)
{
	value = floor(value * (double)THOUSAND);
	value = value / (double)THOUSAND;
	return value;
}

static void DispFormat3(double value, const char* baseUnit, char unit[UNIT_BUF_SIZE], char result[DEFAULT_BUF_SIZE])
{
	double v = fabs(value);

	v =localFloor(v);
	if(v < THOUSAND)
	{
		BaseDisp3(v, "", baseUnit, unit, result);
		return;
	}
	v = (v / THOUSAND);
	v =localFloor(v);
	if(v < THOUSAND)
	{
		BaseDisp3(v, "k", baseUnit, unit, result);
		return;
	}
	v = (v / THOUSAND);
	v =localFloor(v);
	BaseDisp3(v, "M", baseUnit, unit, result);
}

static void AcbMccbMeasurementSend(void)
{
	(void)printf("AcbMccbMeasurementSend nSendStep = %d, gStatusSendEnd=%d \n", nSendStep, gStatusSendEnd);
	if(StatusSend() == STATUS_SEND_ING)
	{
		return;
	}
	if(nMenuPos == INDEX_3)		// Max Demand
	{
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, ACB_MAXDEMAND_READ_ADDR, ACB_MAXDEMAND_READ_LEN);		// 1812까지
		}
		else
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, MCCB_MAXDEMAND_READ_ADDR, MCCB_MAXDEMAND_READ_LEN);		// 1254까지
		}
		return;
	}
	if(nSendStep == INDEX_0)
	{
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, HOLDING_REGISTER, ACB_VIP_READ_ADDR, ACB_VIP_READ_LEN);		// PF Display
		}
		else
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, HOLDING_REGISTER, MCCB_VIP_READ_ADDR, MCCB_VIP_READ_LEN);		// PF Display
		}
	}
	else
	if(nSendStep == INDEX_1)
	{
		ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, ACBMCCB_ENERGY_READ_ADDR, ACBMCCB_ENERGY_READ_LEN);		// 284까지
	}
	else
	if(nSendStep == INDEX_2)
	{
		ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, ACBMCCB_PQ_READ_ADDR, ACBMCCB_PQ_READ_LEN);		// 366까지
	}
	else {}
}

static void DemandMakeString(uint16_t index, int pos, const char* baseUnit )
{
	char value[DATE_BUF_SIZE];
	char unit[UNIT_BUF_SIZE];
	DispFormat(ModbusGetFloat(index), baseUnit, unit, value);
	index += INDEX_2;
	uint8_t year = ModbusGetUint8_L(index);
	index++;
	uint8_t mon = ModbusGetUint8_U(index);
	uint8_t day = ModbusGetUint8_L(index);
	index++;
	uint8_t hour = ModbusGetUint8_U(index);
	uint8_t min = ModbusGetUint8_L(index);

	GUI_RECT rect;
	GUI_RECT rectUnit;
	GUI_RECT rectDateLocal;
	rect.x0 = ACBMCCB_MEASUR_DEMAND_VALUE_x0;
	rect.y0 = ACBMCCB_RELAYSET_GRID_Y0 + (HEIGHT_VALUE * pos) + 1;
	rect.x1 = ACBMCCB_MEASUR_DEMAND_VALUE_x1;
	rect.y1 = (ACBMCCB_RELAYSET_GRID_Y0 + (HEIGHT_VALUE * (pos+1))) - INDEX_2;

	rectUnit.x0 = ACBMCCB_MEASUR_DEMAND_VALUE_U_x0;
	rectUnit.y0 = rect.y0;
	rectUnit.x1 = ACBMCCB_MEASUR_DEMAND_VALUE_U_x1;
	rectUnit.y1 = rect.y1;

	rectDateLocal.x0 = ACBMCCB_MEASUR_DEMAND_DATE_x0;
	rectDateLocal.y0 = rect.y0;
	rectDateLocal.x1 = ACBMCCB_MEASUR_DEMAND_DATE_x1;
	rectDateLocal.y1 = rect.y1;

	GUI_ClearRect(rect.x0, rect.y0, rect.x1, rect.y1);
	GUI_DispStringInRect(value, &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);

	GUI_ClearRect(rectUnit.x0, rectUnit.y0, rectUnit.x1, rectUnit.y1);
	GUI_DispStringInRect(unit, &rectUnit, GUI_TA_LEFT | GUI_TA_VCENTER);

	(void)sprintf(value, "%02d-%02d-%02d %02d:%02d", year, mon, day, hour, min);

	GUI_ClearRect(rectDateLocal.x0, rectDateLocal.y0, rectDateLocal.x1, rectDateLocal.y1);
	GUI_DispStringInRect(value, &rectDateLocal, GUI_TA_LEFT | GUI_TA_VCENTER);
}

static void AcbMccbValueDispDemand(void)
{
	int cnt = INDEX_6;
	uint16_t index = I_REGISTER_1213;

	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
	{
		index = I_REGISTER_1771;
	}

	GUI_SetColor(COLOR_VALUE);
	(void)GUI_SetFont(&GUI_Font20B_ASCII);
	GUI_SetBkColor(COLOR_MAIN_BG);

	if(gDeviceTypeAll[gDeviceIndex] == FALSE)
	{
		cnt = INDEX_3;
	}

	for(int i = 0; i < cnt; i++)
	{
		DemandMakeString(index, i, _acmeasurementDemand_unit[i]);
		index += INDEX_7;
	}
}

static void AcbMccbMeasurementRecv(void)
{
	uint16_t index;

	(void)printf("\n\n\n AcbMccbMeasurementRecv(%d)\n", nSendStep);
	if(nMenuPos == INDEX_3)
	{
		AcbMccbValueDispDemand();
		nSendStep = 0;
		gStatusSendEnd = STATUS_SEND_ING;
		return;
	}

	if(nSendStep == INDEX_0)
	{
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
		{
			index = H_REGISTER_54;
		}
		else
		{
			index = H_REGISTER_30;
		}
		nPfDisplay = ModbusGetUint16(index);
		(void)printf("\n\n\n\nPfDisplay = %d\n\n\n\n\n", nPfDisplay);
		nSendStep = 1;
	}
	else
	if(nSendStep == INDEX_1)
	{
		if(gPols[gDeviceIndex] == P3)
		{
			index = I_REGISTER_237;
		}
		else
		{
			index = I_REGISTER_231;
		}
		for(int i = 0 ; i < INDEX_3; i++)		// V 전압
		{
			VI[0][i] = ModbusGetFloat(index);
			index += INDEX_2;
		}
		index = I_REGISTER_215;
		for(int i = 0 ; i < INDEX_4; i++)	//  I 전류
		{
			VI[INDEX_1][i] = ModbusGetFloat(index);

			index += INDEX_2;
		}
		index = I_REGISTER_251;
		for(int i = 0 ; i < INDEX_3; i++)		//  P&E PQS
		{
			P[i] = ModbusGetFloat(index);
			index += INDEX_2;
		}
(void)printf("[va] = %f\n", ModbusGetFloat(I_REGISTER_269));
		Energy[INDEX_0] = ModbusGetFloat(I_REGISTER_265) + ((double)(ModbusGetUint32(I_REGISTER_267) * (double)MAX_EP_EQ));	//EP
		Energy[INDEX_1] = ModbusGetFloat(I_REGISTER_269) + ((double)(ModbusGetUint32(I_REGISTER_271) * (double)MAX_EP_EQ));	//EQ
		Energy[INDEX_2] = ModbusGetFloat(I_REGISTER_273) + ((double)(ModbusGetUint32(I_REGISTER_275) * (double)MAX_EP_EQ));	//rEP
		Energy[INDEX_3] = ModbusGetFloat(I_REGISTER_277) + ((double)(ModbusGetUint32(I_REGISTER_279) * (double)MAX_EP_EQ));	//rEQ
		Energy[INDEX_4] = ModbusGetFloat(I_REGISTER_281) + ((double)(ModbusGetUint32(I_REGISTER_283) * (double)MAX_EP_EQ));	//ES

		PQ1[INDEX_0] = ModbusGetFloat(I_REGISTER_257);	//Freq
		PQ1[INDEX_1] = ModbusGetFloat(I_REGISTER_249);	//pF
		nSendStep = INDEX_2;
	}
	else
	if(nSendStep == INDEX_2)
	{
		index = I_REGISTER_321;
		if(gPols[gDeviceIndex] == P3)
		{
			index = I_REGISTER_327;
		}
		else
		{
			index = I_REGISTER_321;
		}
		for(int i = 0; i < INDEX_3; i++)
		{
		  PQ2[INDEX_0][i] = ModbusGetFloat(index);	// THD 전압
		  index += INDEX_2;
		}
		index = I_REGISTER_333;
		for(int i = 0; i < INDEX_3; i++)
		{
		  PQ2[INDEX_1][i] = ModbusGetFloat(index);	// THD 전류
		  index += INDEX_2;
		}
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
		{
			index = I_REGISTER_339;
		}
		else
		{
			index = I_REGISTER_361;
		}
		for(int i = 0; i < INDEX_3; i++)
		{
		  PQ2[INDEX_2][i] = ModbusGetFloat(index);	// TDD 전류
		  index += INDEX_2;
		}

		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
		{
		  if(gPols[gDeviceIndex] == P3)			// 전압 위상
		  {
			  index = I_REGISTER_351;
		  }
		  else
		  {
			  index = I_REGISTER_345;
		  }
		}
		else
		{
		  if(gPols[gDeviceIndex] == P3)			// 전압 위상
		  {
			  index = I_REGISTER_345;
		  }
		  else
		  {
			  index = I_REGISTER_339;
		  }
		}
		for(int i = 0; i < INDEX_3; i++)
		{
			Angle[INDEX_0][i] = ModbusGetFloat(index);
			index += INDEX_2;
		}
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
		{
			index = I_REGISTER_357;
		}
		else
		{
			index = I_REGISTER_351;
		}
		for(int i = 0; i < INDEX_4; i++)					// 전류 위상
		{
			Angle[INDEX_1][i] = ModbusGetFloat(index);
			index += INDEX_2;
		}
// 2012/2/14 LS연구소 테스트시 위상은 그래로 표시하면 된다함
//		float AngleBase = Angle[1][0];
//		for(int i = 0; i < INDEX_2; i++)
//		{
//			for(int j = 0; j < INDEX_4; j++)
//			{
//				Angle[i][j] = Angle[i][j] - AngleBase;
//			}
//		}
//		for(int i = 0; i < INDEX_2; i++)
//		{
//			for(int j = 0; j < INDEX_4; j++)
//			{
//				if(Angle[i][j] < 0)
//				{
//					Angle[i][j] =  Angle[i][j] + MAX_ANGLE;
//				}
//				else
//				if(Angle[i][j] >= MAX_ANGLE)
//				{
//					Angle[i][j] =  Angle[i][j] - MAX_ANGLE;
//				}
//				else {}
//			}
//		}
		nSendStep = 0;
	}
	else {}
}

static void AcbMccbMeasurementMenu(int pos)
{
	GUI_RECT rect;
	rect.x0 = ACBMCCB_MEASUR_TEXT_x0;
	rect.x1 = ACBMCCB_MEASUR_TEXT_x1;
	rect.y0 = STARTY_CONTENTS;
	rect.y1 = (STARTY_CONTENTS + ACBMCCB_MEASUR_MENU_HEIGHT) - 1;

	int y0 = STARTY_CONTENTS;
	for(int i = 0; i < ACBMCCB_MEASUR_MENU_COUNT; i++)
	{
		if(i == pos)
		{
			GUI_SetColor(COLOR_MENU_SELECTED);
		}
		else
		{
			GUI_SetColor(COLOR_MENU_NORMAL);
		}
		GUI_FillRect(STARTX_CONTENTS, y0, (STARTX_CONTENTS + ACBMCCB_MEASUR_MENU_WIDTH) - 1, (y0 + ACBMCCB_MEASUR_MENU_HEIGHT) - 1);

		if(i == pos)
		{
			GUI_SetColor(COLOR_VALUE);
			GUI_SetBkColor(COLOR_MENU_SELECTED);
		//	(void)GUI_SetFont(&GUI_Font20B_ASCII);
			LanguageSelect(FONT20B);
		}
		else
		{
			GUI_SetColor(COLOR_LABEL);
			GUI_SetBkColor(COLOR_MENU_NORMAL);
		//	(void)GUI_SetFont(&GUI_Font20_ASCII);
			LanguageSelect(FONT20);
		}

		GUI_DispStringInRect(_acmeasurement_menu_text[SettingValue[SETUP_LANGUAGE]][i], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);
		rect.y0 += ACBMCCB_MEASUR_MENU_HEIGHT + 1;
		rect.y1 += ACBMCCB_MEASUR_MENU_HEIGHT + 1;
		y0 += ACBMCCB_MEASUR_MENU_HEIGHT + 1;;
	}
}

static void AcbMccbValueDispVIP(void)
{
	(void)printf("gPols[gDeviceIndex] = %d\n", gPols[gDeviceIndex]);
	if(gCommStatus[gDeviceIndex] == COMM_ERROR)
	{
		return;
	}
	if(gLocalPols != gPols[gDeviceIndex])
	{
		GUI_SetBkColor(COLOR_MAIN_BG);
		GUI_ClearRect(ACBMCCB_MEASURE_GRID_X0, ACBMCCB_RELAYSET_GRID_Y0, ACBMCCB_MEASURE_GRID_X1, Y1_MAIN);
		AcbMccbMeasurementDispVIP();
	}
	char buf[DEFAULT_BUF_SIZE];
	GUI_SetColor(COLOR_VALUE);
	(void)GUI_SetFont(&GUI_Font20B_ASCII);
	GUI_SetBkColor(COLOR_MAIN_BG);

	GUI_RECT rect;
	GUI_RECT rectUnit;
	GUI_RECT rectAngle;
	rect.x0 = ACBMCCB_MEASUR_VIP_V_x0;
	rect.y0 = ACBMCCB_RELAYSET_GRID_Y0+1;
	rect.x1 = ACBMCCB_MEASUR_VIP_V_x1;
	rect.y1 = (ACBMCCB_RELAYSET_GRID_Y0 + HEIGHT_VALUE) - INDEX_2;

	rectUnit.x0 = ACBMCCB_MEASUR_VIP_VU_x0;
	rectUnit.y0 = ACBMCCB_RELAYSET_GRID_Y0+1;
	rectUnit.x1 = ACBMCCB_MEASUR_VIP_VU_x1;
	rectUnit.y1 = (ACBMCCB_RELAYSET_GRID_Y0 + HEIGHT_VALUE) - INDEX_2;

	rectAngle.x0 = ACBMCCB_MEASUR_VIP_VA_x0 + INDEX_3;
	rectAngle.y0 = ACBMCCB_RELAYSET_GRID_Y0+1;
	rectAngle.x1 = ACBMCCB_MEASUR_VIP_VA_x1 + INDEX_3;
	rectAngle.y1 = (ACBMCCB_RELAYSET_GRID_Y0 + HEIGHT_VALUE) - INDEX_2;

	int x = ACBMCCB_MEASUR_VIP_VS_x0;
	int y = ACBMCCB_RELAYSET_GRID_Y0;

	if(gDeviceTypeAll[gDeviceIndex] == TRUE)
	{
	  for(int i = 0 ; i < (LINECOUNT_CONTENTS-INDEX_3); i++)
	  {
		char value[DEFAULT_BUF_SIZE];
		char unit[UNIT_BUF_SIZE];
		DispFormat(VI[0][i], "V", unit, value);

		GUI_ClearRect(rect.x0, rect.y0, rect.x1, rect.y1);
		GUI_DispStringInRect(value, &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
		GUI_ClearRect(rectUnit.x0, rectUnit.y0, rectUnit.x1, rectUnit.y1);
		GUI_DispStringInRect(unit, &rectUnit, GUI_TA_LEFT | GUI_TA_VCENTER);

		(void)sprintf(buf, "%3.0f",  Angle[0][i]);
		GUI_ClearRect(rectAngle.x0, rectAngle.y0, rectAngle.x1, rectAngle.y1);
		GUI_DispStringInRect(buf, &rectAngle, GUI_TA_LEFT | GUI_TA_VCENTER);

		GUI_SetColor(GUI_WHITE);
		GUI_DrawPolyLine(cPtAngle, POINT_ANGLE_COUNT, x, y);

		rect.y0 += HEIGHT_VALUE;
		rect.y1 += HEIGHT_VALUE;
		rectUnit.y0 += HEIGHT_VALUE;
		rectUnit.y1 += HEIGHT_VALUE;
		rectAngle.y0 += HEIGHT_VALUE;
		rectAngle.y1 += HEIGHT_VALUE;
		y += HEIGHT_LABEL;

	  }
	}
	  rect.x0 = ACBMCCB_MEASUR_VIP_PQS_x0;
	rect.y0 = ACBMCCB_RELAYSET_GRID_Y0+1 + (HEIGHT_VALUE * (LINECOUNT_CONTENTS-INDEX_3));
	rect.x1 = ACBMCCB_MEASUR_VIP_PQS_x1;
	rect.y1 = ACBMCCB_RELAYSET_GRID_Y0 + (HEIGHT_VALUE - INDEX_2) + (HEIGHT_VALUE * (LINECOUNT_CONTENTS-INDEX_3));

	rectUnit.x0 = ACBMCCB_MEASUR_VIP_PQS_U_x0;
	rectUnit.y0 = ACBMCCB_RELAYSET_GRID_Y0+1 + (HEIGHT_VALUE * (LINECOUNT_CONTENTS-INDEX_3));
	rectUnit.x1 = ACBMCCB_MEASUR_VIP_PQS_U_x1;
	rectUnit.y1 = (rectUnit.y0 + HEIGHT_VALUE) - INDEX_2;

	if(gDeviceTypeAll[gDeviceIndex] == TRUE)
	{
	  for(int i = 0 ; i < INDEX_3; i++)
	  {
		char value[DEFAULT_BUF_SIZE];
		char unit[UNIT_BUF_SIZE];

		DispFormat(P[i], _acPQS_unit[i], unit, value);

		GUI_ClearRect(rect.x0, rect.y0, rect.x1, rect.y1);
		GUI_DispStringInRect(value, &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
		GUI_ClearRect(rectUnit.x0, rectUnit.y0, rectUnit.x1, rectUnit.y1);
		GUI_DispStringInRect(unit, &rectUnit, GUI_TA_LEFT | GUI_TA_VCENTER);

		rect.y0 += HEIGHT_VALUE;
		rect.y1 += HEIGHT_VALUE;
		rectUnit.y0 += HEIGHT_VALUE;
		rectUnit.y1 += HEIGHT_VALUE;
		y += HEIGHT_LABEL;
	  }
	}
	rect.x0 = ACBMCCB_MEASUR_VIP_I_x0;
	rect.y0 = ACBMCCB_RELAYSET_GRID_Y0+1;
	rect.x1 = ACBMCCB_MEASUR_VIP_I_x1;
	rect.y1 = (ACBMCCB_RELAYSET_GRID_Y0 + HEIGHT_VALUE) - INDEX_2;

	rectUnit.x0 = ACBMCCB_MEASUR_VIP_IU_x0;
	rectUnit.y0 = ACBMCCB_RELAYSET_GRID_Y0+1;
	rectUnit.x1 = ACBMCCB_MEASUR_VIP_IU_x1;
	rectUnit.y1 = (ACBMCCB_RELAYSET_GRID_Y0 + HEIGHT_VALUE) - INDEX_2;

	rectAngle.x0 = ACBMCCB_MEASUR_VIP_IA_x0 + INDEX_4;
	rectAngle.y0 = ACBMCCB_RELAYSET_GRID_Y0+1;
	rectAngle.x1 = ACBMCCB_MEASUR_VIP_IA_x1 + INDEX_4;
	rectAngle.y1 = (ACBMCCB_RELAYSET_GRID_Y0 + HEIGHT_VALUE) - INDEX_2;

	x = ACBMCCB_MEASUR_VIP_IS_x0;
	y = ACBMCCB_RELAYSET_GRID_Y0;

	for(int i = 0 ; i < gPols[gDeviceIndex]; i++)
	{
		char value[DEFAULT_BUF_SIZE];
		char unit[UNIT_BUF_SIZE];
		DispFormat(VI[1][i], "A", unit, value);
		GUI_ClearRect(rect.x0, rect.y0, rect.x1, rect.y1);
		GUI_DispStringInRect(value, &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
		GUI_ClearRect(rectUnit.x0, rectUnit.y0, rectUnit.x1, rectUnit.y1);
		GUI_DispStringInRect(unit, &rectUnit, GUI_TA_LEFT | GUI_TA_VCENTER);

		(void)sprintf(buf, "%3.0f",  Angle[1][i]);
		GUI_ClearRect(rectAngle.x0, rectAngle.y0, rectAngle.x1, rectAngle.y1);
		GUI_DispStringInRect(buf, &rectAngle, GUI_TA_LEFT | GUI_TA_VCENTER);

		GUI_DrawPolyLine(cPtAngle, POINT_ANGLE_COUNT, x, y);

		rect.y0 += HEIGHT_VALUE;
		rect.y1 += HEIGHT_VALUE;
		rectUnit.y0 += HEIGHT_VALUE;
		rectUnit.y1 += HEIGHT_VALUE;
		rectAngle.y0 += HEIGHT_VALUE;
		rectAngle.y1 += HEIGHT_VALUE;
		y += HEIGHT_LABEL;
	}
}

static void AcbMccbMeasurementDispVIP(void)
{
	GUI_SetBkColor(COLOR_MAIN_BG);
	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_LINE);
	GUI_DrawRect(ACBMCCB_MEASURE_GRID_X0, ACBMCCB_RELAYSET_GRID_Y0, ACBMCCB_MEASURE_GRID_X1, ACBMCCB_RELAYSET_GRID_Y0 + (INDEX_6 * HEIGHT_VALUE));

	gLocalPols = gPols[gDeviceIndex];

	for(int i = 0; i < (LINECOUNT_CONTENTS-1); i++)
	{
		int y0 = ACBMCCB_RELAYSET_GRID_Y0 + ((i + 1) * HEIGHT_VALUE);
		GUI_DrawHLine(y0, ACBMCCB_MEASURE_GRID_X0, ACBMCCB_MEASURE_GRID_X1);
	}
	GUI_DrawVLine(ACBMCCB_MEASURE_GRID_X, ACBMCCB_RELAYSET_GRID_Y0, ACBMCCB_RELAYSET_GRID_Y0 + (INDEX_6* HEIGHT_VALUE));

	(void)GUI_SetFont(&GUI_Font20_ASCII);

	GUI_RECT rect;
	rect.x0 = ACBMCCB_MEASUR_LABEL_X0;
	rect.x1 = (ACBMCCB_MEASUR_LABEL_X0 +  ACBMCCB_MEASUR_LABEL_WIDTH) - 1;
	rect.y0 = ACBMCCB_RELAYSET_GRID_Y0;
	rect.y1 = (ACBMCCB_RELAYSET_GRID_Y0 +  HEIGHT_LABEL) - 1;

	if(gDeviceTypeAll[gDeviceIndex] == TRUE)
	{
		GUI_SetColor(COLOR_LABEL);
	}
	else
	{
		GUI_SetColor(COLOR_DISABLE);
	}
	for(int j= 0 ; j < LINECOUNT_CONTENTS; j++)
	{
		if(gPols[gDeviceIndex] == P3)
		{
			GUI_DispStringInRect(_acmeasurementVI_LNLL_label_text[1][j], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);
		}
		else
		{
			GUI_DispStringInRect(_acmeasurementVI_LNLL_label_text[0][j], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);
		}
		rect.y0 += HEIGHT_LABEL;
		rect.y1 += HEIGHT_LABEL;
	}
	rect.x0 = ACBMCCB_MEASUR_LABEL2_X0;
	rect.x1 = (ACBMCCB_MEASUR_LABEL2_X0 +  ACBMCCB_MEASUR_LABEL_WIDTH) - 1;
	rect.y0 = ACBMCCB_RELAYSET_GRID_Y0;
	rect.y1 = (ACBMCCB_RELAYSET_GRID_Y0 +  HEIGHT_LABEL) - 1;
	GUI_SetColor(COLOR_LABEL);
	for(int j= 0 ; j < gPols[gDeviceIndex]; j++)
	{
		GUI_DispStringInRect(_acmeasurementVI_A_label_text[j], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);
		rect.y0 += HEIGHT_LABEL;
		rect.y1 += HEIGHT_LABEL;
	}
}

static void AcbMccbValueDispEnergy(void)
{
	if(gCommStatus[gDeviceIndex] == COMM_ERROR)
	{
		return;
	}
	if(gDeviceTypeAll[gDeviceIndex] == FALSE)
	{
		return;
	}
	GUI_SetColor(COLOR_VALUE);
	(void)GUI_SetFont(&GUI_Font20B_ASCII);
	GUI_SetBkColor(COLOR_MAIN_BG);

	GUI_RECT rect;
	GUI_RECT rectUnit;
	rect.x0 = ACBMCCB_MEASUR_VALUE_x0;
	rect.x1 = ACBMCCB_MEASUR_VALUE_x1;
	rect.y0 = ACBMCCB_RELAYSET_GRID_Y0 + 1;
	rect.y1 = (ACBMCCB_RELAYSET_GRID_Y0 + HEIGHT_VALUE) - INDEX_2;
	rectUnit.x0 = ACBMCCB_MEASUR_VALUE_U_x0;
	rectUnit.x1 = ACBMCCB_MEASUR_VALUE_U_x1;
	rectUnit.y0 = ACBMCCB_RELAYSET_GRID_Y0 + 1;
	rectUnit.y1 = (ACBMCCB_RELAYSET_GRID_Y0 + HEIGHT_VALUE) - INDEX_2;
	for(int i = 0 ; i < (LINECOUNT_CONTENTS-1); i++)
	{
		char buf[DEFAULT_BUF_SIZE];
		char unit[UNIT_BUF_SIZE];

		DispFormat3(Energy[i], _acmeasurementEnergy_unit[i], unit, buf);
		GUI_ClearRect(rect.x0, rect.y0, rect.x1, rect.y1);
		GUI_DispStringInRect(buf, &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
		GUI_ClearRect(rectUnit.x0, rectUnit.y0, rectUnit.x1, rectUnit.y1);
		GUI_DispStringInRect(unit, &rectUnit, GUI_TA_LEFT | GUI_TA_VCENTER);
		rect.y0 += HEIGHT_VALUE;
		rect.y1 += HEIGHT_VALUE;
		rectUnit.y0 += HEIGHT_VALUE;
		rectUnit.y1 += HEIGHT_VALUE;
	}
}

static void AcbMccbMeasurementDispEnergy(void)
{
	GUI_SetBkColor(COLOR_MAIN_BG);
	GUI_SetColor(COLOR_LINE);
	GUI_DrawRect(ACBMCCB_MEASURE_GRID_X0, ACBMCCB_RELAYSET_GRID_Y0, ACBMCCB_MEASURE_GRID_X1, ACBMCCB_RELAYSET_GRID_Y0 + (INDEX_5 * HEIGHT_VALUE));

	for(int i = 0; i < (LINECOUNT_CONTENTS-INDEX_2); i++)
	{
		int y0 = ACBMCCB_RELAYSET_GRID_Y0 + ((i + 1) * HEIGHT_VALUE);
		GUI_DrawHLine(y0, ACBMCCB_MEASURE_GRID_X0, ACBMCCB_MEASURE_GRID_X1);
	}

	(void)GUI_SetFont(&GUI_Font20_ASCII);

	GUI_RECT rect;
	rect.x0 = ACBMCCB_MEASUR_LABEL3_X0;
	rect.x1 = ACBMCCB_MEASUR_LABEL3_X1;
	rect.y0 = ACBMCCB_RELAYSET_GRID_Y0;
	rect.y1 = (ACBMCCB_RELAYSET_GRID_Y0 +  HEIGHT_LABEL) - 1;

	if(gDeviceTypeAll[gDeviceIndex] == TRUE)
	{
		GUI_SetColor(COLOR_LABEL);
	}
	else
	{
		GUI_SetColor(COLOR_DISABLE);
	}

	for(int j= 0 ; j < (LINECOUNT_CONTENTS-1); j++)
	{
		GUI_DispStringInRect(_acmeasurementEnergy_label_text[j], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);
		rect.y0 += HEIGHT_LABEL;
		rect.y1 += HEIGHT_LABEL;
	}
}

static void AcbMccbValueDispPQ(void)
{
	static int displayFlag[INDEX_2][INDEX_3][INDEX_3] = {
		{	{FALSE, FALSE, FALSE },
			{TRUE, TRUE, TRUE },
			{TRUE, TRUE, TRUE }
		},
		{	{TRUE, TRUE, TRUE },
			{TRUE, TRUE, TRUE},
			{TRUE, TRUE, TRUE}
		}
	};


	if(gCommStatus[gDeviceIndex] == COMM_ERROR)
	{
		return;
	}

	if(gLocalPols != gPols[gDeviceIndex])
	{
		GUI_SetBkColor(COLOR_MAIN_BG);
		GUI_ClearRect(ACBMCCB_MEASURE_GRID_X0, ACBMCCB_RELAYSET_GRID_Y0, ACBMCCB_MEASURE_GRID_X1, Y1_MAIN);
		AcbMccbMeasurementDispPQ();
	}

	char buf[DEFAULT_BUF_SIZE];

	GUI_SetColor(COLOR_VALUE);
	(void)GUI_SetFont(&GUI_Font20B_ASCII);
	GUI_SetBkColor(COLOR_MAIN_BG);

	GUI_RECT rect;
	GUI_RECT rectUnit;
	rect.x0 = ACBMCCB_MEASUR_VALUE_x0;
	rect.x1 = ACBMCCB_MEASUR_VALUE_x1;
	rect.y0 = ACBMCCB_RELAYSET_GRID_Y0 + 1;
	rect.y1 = (ACBMCCB_RELAYSET_GRID_Y0 + HEIGHT_VALUE) - INDEX_2;
	rectUnit.x0 = ACBMCCB_MEASUR_VALUE_U_x0;
	rectUnit.x1 = ACBMCCB_MEASUR_VALUE_U_x1;
	rectUnit.y0 = ACBMCCB_RELAYSET_GRID_Y0 + 1;
	rectUnit.y1 = (ACBMCCB_RELAYSET_GRID_Y0 + HEIGHT_VALUE) - INDEX_2;
	for(int i = 0 ; i < INDEX_2; i++)
	{
		if(i == 0)
		{
			(void)sprintf(buf, "%4.1f", PQ1[i]);
		}
		else
		{
			if(gDeviceTypeAll[gDeviceIndex] == TRUE)
			{
				float val = fabs(PQ1[i]);
//				printf("value1 = %f\n", val);
//				val = val * TEN;
//				printf("value2 = %f\n", val);
////				val = (float)((int)val);
//				val = ceil(val);
//				printf("value3 = %f\n", val);
//				val = val / TEN;
//				printf("value4 = %f\n", val);

				if(nPfDisplay == PF_DISPLAY_LS)
				{
					if(PQ1[i] >= 0)
					{
						(void)sprintf(buf, "Lag %4.1f", val);
					}
					else
					{
						(void)sprintf(buf, "Lead %4.1f", val);
					}
				}
				else
				if(nPfDisplay == PF_DISPLAY_IEC)
				{
					if(PQ1[i] >= 0)
					{
						(void)sprintf(buf, "Forward %4.1f", val);
					}
					else
					{
						(void)sprintf(buf, "Reverse %4.1f", val);
					}
				}
				else
				if(nPfDisplay == PF_DISPLAY_IEEE)
				{
					if(PQ1[i] >= 0)
					{
						(void)sprintf(buf, "Lead %4.1f", val);
					}
					else
					{
						(void)sprintf(buf, "Lag %4.1f", val);
					}
				}
				else
				{
					(void)sprintf(buf, "%4.1f", PQ1[i]);
				}
			}
		}
		if((i == 0) || (gDeviceTypeAll[gDeviceIndex] == TRUE))
		{
			GUI_ClearRect(rect.x0, rect.y0, rect.x1, rect.y1);
			GUI_DispStringInRect(buf, &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
			GUI_ClearRect(rectUnit.x0, rectUnit.y0, rectUnit.x1, rectUnit.y1);
			GUI_DispStringInRect(_acmeasurementPQ_unit_text[i], &rectUnit, GUI_TA_LEFT | GUI_TA_VCENTER);
		}
		rect.y0 += HEIGHT_VALUE;
		rect.y1 += HEIGHT_VALUE;
		rectUnit.y0 += HEIGHT_VALUE;
		rectUnit.y1 += HEIGHT_VALUE;
	}
	for(int i = 0; i < INDEX_3; i++)
	{
		for(int j = 0; j < INDEX_3; j++)
		{
//			printf("\n\nenable = %d, i = %d, j = %d, flag = %d\n",gDeviceTypeAll[gDeviceIndex], i, j, displayFlag[gDeviceTypeAll[gDeviceIndex]][i][j]);
			if(displayFlag[gDeviceTypeAll[gDeviceIndex]][i][j] == TRUE)
			{
				rect.x0 = PQ_VALUE_X[j][0];
				rect.x1 = PQ_VALUE_X[j][1];
				rectUnit.x0 = PQ_UNIT_X[j][0];
				rectUnit.x1 = PQ_UNIT_X[j][1];
				GUI_ClearRect(rect.x0, rect.y0, rect.x1, rect.y1);
				(void)sprintf(buf, "%3.0f", PQ2[i][j]);
				GUI_DispStringInRect(buf, &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
				GUI_ClearRect(rectUnit.x0, rectUnit.y0, rectUnit.x1, rectUnit.y1);
				GUI_DispStringInRect(_acmeasurementPQ_unit_text[INDEX_2], &rectUnit, GUI_TA_LEFT | GUI_TA_VCENTER);
			}
		}
		rect.y0 += HEIGHT_VALUE;
		rect.y1 += HEIGHT_VALUE;
		rectUnit.y0 += HEIGHT_VALUE;
		rectUnit.y1 += HEIGHT_VALUE;
	}
}

static void AcbMccbMeasurementDispPQ(void)
{
	GUI_SetColor(COLOR_LINE);
	GUI_SetBkColor(COLOR_MAIN_BG);
	GUI_DrawRect(ACBMCCB_MEASURE_GRID_X0, ACBMCCB_RELAYSET_GRID_Y0, ACBMCCB_MEASURE_GRID_X1, ACBMCCB_RELAYSET_GRID_Y0 + (INDEX_5 * HEIGHT_VALUE));

	gLocalPols = gPols[gDeviceIndex];

	for(int i = 0; i < (LINECOUNT_CONTENTS-1); i++)
	{
		if(i == INDEX_2)
		{
			continue;
		}
		int y0 = ACBMCCB_RELAYSET_GRID_Y0 + ((i + 1) * HEIGHT_VALUE);
		GUI_DrawHLine(y0, ACBMCCB_MEASURE_GRID_X0, ACBMCCB_MEASURE_GRID_X1);
	}

	GUI_SetColor(COLOR_LABEL);
	(void)GUI_SetFont(&GUI_Font20_ASCII);

	GUI_RECT rect;
	rect.x0 = ACBMCCB_MEASUR_LABEL3_X0;
	rect.x1 = ACBMCCB_MEASUR_LABEL3_X1;
	rect.y0 = ACBMCCB_RELAYSET_GRID_Y0;
	rect.y1 = (ACBMCCB_RELAYSET_GRID_Y0 +  HEIGHT_LABEL) - 1;

	for(int j = 0 ; j < (LINECOUNT_CONTENTS-1); j++)
	{
		if((j == INDEX_1) && (gDeviceTypeAll[gDeviceIndex] == FALSE))
		{
			GUI_SetColor(COLOR_DISABLE);
		}
	 	else
		{
			GUI_SetColor(COLOR_LABEL);
		}
		GUI_DispStringInRect(_acmeasurementPQ_label_text[j], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);
		rect.y0 += HEIGHT_LABEL;
		rect.y1 += HEIGHT_LABEL;
	}
	rect.y0 = ACBMCCB_RELAYSET_GRID_Y0 + (HEIGHT_LABEL * INDEX_2) ;
	rect.y1 = (ACBMCCB_RELAYSET_GRID_Y0 +  (HEIGHT_LABEL * INDEX_3)) - 1;
	if(gDeviceTypeAll[gDeviceIndex] == TRUE)
	{
		GUI_SetColor(COLOR_LABEL);
	}
	else
	{
		GUI_SetColor(COLOR_DISABLE);
	}
	for(int i = 0; i < INDEX_3; i++)
	{
		rect.x0 = PQ_LABEL_X[i][0];
		rect.x1 = PQ_LABEL_X[i][1];
		int pos = 0;
		if(gPols[gDeviceIndex] == P3)
		{
			pos = 1;
		}
		GUI_DispStringInRect(_acmeasurementVI_LNLL_label_text[pos][i], &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
	}
	rect.y0 += HEIGHT_LABEL;
	rect.y1 += HEIGHT_LABEL;
	for(int i = 0; i < INDEX_3; i++)
	{
//		if((i >= INDEX_1) && (gDeviceTypeAll[gDeviceIndex] == FALSE))
//			GUI_SetColor(COLOR_DISABLE);
//	 	else
		GUI_SetColor(COLOR_LABEL);
		rect.x0 = PQ_LABEL_X[i][0];
		rect.x1 = PQ_LABEL_X[i][1];
		GUI_DispStringInRect(_acmeasurementPQ_I_text[i], &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
	}
	rect.y0 += HEIGHT_LABEL;
	rect.y1 += HEIGHT_LABEL;
	for(int i = 0; i < INDEX_3; i++)
	{
//		if((i >= INDEX_1) && (gDeviceTypeAll[gDeviceIndex] == FALSE))
//			GUI_SetColor(COLOR_DISABLE);
//	 	else
		GUI_SetColor(COLOR_LABEL);
		rect.x0 = PQ_LABEL_X[i][0];
		rect.x1 = PQ_LABEL_X[i][1];
		GUI_DispStringInRect(_acmeasurementPQ_I_text[i], &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
	}
}

static void AcbMccbMeasurementDispDemand(void)
{
	GUI_SetColor(COLOR_LINE);
	GUI_SetBkColor(COLOR_MAIN_BG);
	GUI_DrawRect(ACBMCCB_MEASURE_GRID_X0, ACBMCCB_RELAYSET_GRID_Y0, ACBMCCB_MEASURE_GRID_X1, ACBMCCB_RELAYSET_GRID_Y0 + (LINECOUNT_CONTENTS * HEIGHT_VALUE));

	for(int i = 0; i < (LINECOUNT_CONTENTS - 1); i++)
	{
		int y0 = ACBMCCB_RELAYSET_GRID_Y0 + ((i + 1) * HEIGHT_VALUE);
		GUI_DrawHLine(y0, ACBMCCB_MEASURE_GRID_X0, ACBMCCB_MEASURE_GRID_X1);
	}

	GUI_SetColor(COLOR_LABEL);
	(void)GUI_SetFont(&GUI_Font20_ASCII);

	GUI_RECT rect;
	rect.x0 = ACBMCCB_MEASUR_LABEL3_X0;
	rect.x1 = ACBMCCB_MEASUR_LABEL3_X1;
	rect.y0 = ACBMCCB_RELAYSET_GRID_Y0;
	rect.y1 = (ACBMCCB_RELAYSET_GRID_Y0 +  HEIGHT_LABEL) - 1;

	for(int j = 0 ; j < LINECOUNT_CONTENTS; j++)
	{
		if((j > INDEX_2) && (gDeviceTypeAll[gDeviceIndex] == FALSE))
		{
			GUI_SetColor(COLOR_DISABLE);
		}
		GUI_DispStringInRect(_acmeasurementDemand_label_text[j], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);
		rect.y0 += HEIGHT_LABEL;
		rect.y1 += HEIGHT_LABEL;
	}

}

static void AcbMccbMeasurementDisp(int pos, int clear)
{
	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetBkColor(COLOR_MAIN_BG);
	GUI_SetColor(COLOR_LINE);

	if(clear)
	{
		GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	}

	AcbMccbMeasurementMenu(pos);

	GUI_SetBkColor(COLOR_MAIN_BG);
	GUI_ClearRect(ACBMCCB_MEASURE_GRID_X0, ACBMCCB_RELAYSET_GRID_Y0, ACBMCCB_MEASURE_GRID_X1, Y1_MAIN);
	if(pos == INDEX_0)
	{
		AcbMccbMeasurementDispVIP();
	}
	else
	if(pos == INDEX_1)
	{
		AcbMccbMeasurementDispEnergy();
	}
	else
	if(pos == INDEX_2)
	{
		AcbMccbMeasurementDispPQ();
	}
	else
	if(pos == INDEX_3)
	{
		AcbMccbMeasurementDispDemand();
	}
	else {}
}

static void AcbMccbValueDisp(int pos)
{
	if(pos == INDEX_0)
	{
		AcbMccbValueDispVIP();
	}
	else
	if(pos == INDEX_1)
	{
		AcbMccbValueDispEnergy();
	}
	else
	if(pos == INDEX_2)
	{
		AcbMccbValueDispPQ();
	}
	else {}
}
/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       AcbMccbMeasurement
*/

// PRQA S 1503 1
void AcbMccbMeasurement(void)
{
	int flagBreak = FALSE;
	nSendStep = 0;
	nMenuPos = 0;

	GUI_SetBkColor(COLOR_MAIN_BG);
	(void)GUI_SetFont(&GUI_Font20_ASCII);

	if(gCommStatus[gDeviceIndex] == COMM_ERROR)
	{
		gPols[gDeviceIndex] = INDEX_3;
		gDeviceTypeAll[gDeviceIndex] = TRUE;
	}
	AcbMccbMeasurementDisp(nMenuPos, 1);

	ReadyToSend();
	AcbMccbMeasurementSend();

	while (1)
    {
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			statusSendStep = 0;
			nSendStep = 0;
			AcbMccbMeasurementSend();
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
			AcbMccbMeasurementDisp(nMenuPos, 1);
			gCommOldStatus[gDeviceIndex] = -1;
		}
		else
		if(key == KEY_UP)
		{
			if(nMenuPos > 0)
			{
				nMenuPos--;
			}
			else
			{
				nMenuPos = ACBMCCB_MEASUR_MENU_COUNT - 1;
			}
			AcbMccbMeasurementDisp(nMenuPos, 0);
			AcbMccbValueDisp(nMenuPos);
			if(nMenuPos == INDEX_3)
			{
				ReadyToSend();
				AcbMccbMeasurementSend();
				nSendStep = 0;
			}
		}
		else
		if(key == KEY_DOWN)
		{
			if(nMenuPos < (ACBMCCB_MEASUR_MENU_COUNT-1))
			{
				nMenuPos++;
			}
			else
			{
				nMenuPos = 0;
			}
			AcbMccbMeasurementDisp(nMenuPos, 0);
			AcbMccbValueDisp(nMenuPos);
			if(nMenuPos == INDEX_3)
			{
				ReadyToSend();
				AcbMccbMeasurementSend();
				nSendStep = 0;
			}
		}
		else
		if(key == DATA_RECV)
		{
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				StatusRecv();
				AcbMccbMeasurementSend();
			}
			else
			{
			  (void)printf("nMenuPos=%d, nSendStep=%d\n", nMenuPos, nSendStep);
			  AcbMccbMeasurementRecv();
			  AcbMccbValueDisp(nMenuPos);
			  if(nSendStep != 0)
			  {
			  	  AcbMccbMeasurementSend();
			  }
			  else
			  {
				  g_bRecvAllDone = TRUE;
				  nSendStep = 0;
				  statusSendStep = 0;
				  gStatusSendEnd = STATUS_SEND_ING;
			  }
			}
		}
		else
		if(key == KEY_COMM_ERROR)
		{
			if(gStatusSendEnd == STATUS_SEND_END)
			{
				nSendStep++;
			}
			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				if(nSendStep < INDEX_3)
				{
					AcbMccbMeasurementSend();
				}
				else
				{
					g_bRecvAllDone = TRUE;
					(void)printf("All done!!!\n");
					gStatusSendEnd = STATUS_SEND_ING;
					statusSendStep = 0;
					nSendStep = 0;
				}
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			gPols[gDeviceIndex] = INDEX_3;
			gDeviceTypeAll[gDeviceIndex] = TRUE;
			AcbMccbMeasurementDisp(nMenuPos, 1);
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
	}
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
