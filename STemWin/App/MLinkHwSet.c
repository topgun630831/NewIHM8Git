/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#define EXTERN extern
#include "stm32f4xx_hal.h"
#include "main.h"
#include "GuiData.h"

static void MlinkHwSetSend(void);
static void MlinkHwSetDisp(void);
static void MLinkSetInitDisp(void);

static void MlinkHwSetSend(void)
{
	if(StatusSend() == STATUS_SEND_ING)
	{
		return;
	}
	if(nSendStep == INDEX_0)
	{
		ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, HOLDING_REGISTER, MLINK_HWSET_STEP0_READ_ADDR, MLINK_HWSET_STEP0_READ_LEN);		// 통신속도
	}
	else
	if(nSendStep == INDEX_1)
	{
		ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, I_REGISTER_1003, INDEX_1);			// 1003까지
	}
//	else
//	if(nSendStep == INDEX_2)
//	{
//		ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, MLINK_HWSET_STEP2_READ_ADDR, MLINK_HWSET_STEP2_READ_LEN);			// 1003까지
//	}
	else {}
}

static void MlinkHwSetDisp(void)
{
	static uint16_t nBaudrate;
	static uint16_t nAddress;

	(void)printf("MlinkHwSetDisp=%d\n", nSendStep);
	if(nSendStep == INDEX_0)
	{
		nBaudrate = ModbusGetUint16(H_REGISTER_2002)-1;
		(void)printf("nBaudrate=%d\n", nBaudrate);
		nSendStep = INDEX_1;
		return;
	}
	else {}

	char buf[INDEX_3][DEFAULT_BUF_SIZE];

	nAddress = ModbusGetUint16(I_REGISTER_1003);
	(void)printf("nAddress=%d\n", nAddress);
	(void)sprintf(buf[INDEX_0], "%3d", nAddress);
	if(nBaudrate < SETUP_SPEED_MAX)
	{
		(void)sprintf(buf[INDEX_1], "%s", _acsetup_speed[nBaudrate]);
	}
	if((mLinkMode[gDeviceIndex] >= 1) && (mLinkMode[gDeviceIndex] <= INDEX_3))
	{
		(void)sprintf(buf[INDEX_2], _aclocal_remote[SettingValue[SETUP_LANGUAGE]][INDEX_1]); //"Remote"
	}
	else
	{
		(void)sprintf(buf[INDEX_2], _aclocal_remote[SettingValue[SETUP_LANGUAGE]][INDEX_0]); //"Local"
	}

	GUI_SetColor(COLOR_VALUE);
	GUI_RECT rect;
	rect.x0 = STARTX_VALUE;
	rect.y0 = STARTY_VALUE + INDEX_2;
	rect.x1 = (STARTX_VALUE + WIDTH_VALUE) - 1;
	rect.y1 = (STARTY_VALUE + HEIGHT_VALUE) - INDEX_4;

	(void)GUI_SetFont(&GUI_Font20B_ASCII);
	GUI_SetBkColor(COLOR_MAIN_BG);
	for(int i = 0 ; i < (LINECOUNT_CONTENTS-INDEX_3); i++)
	{
		GUI_ClearRect(rect.x0, rect.y0+1, rect.x1, rect.y1-INDEX_2);
		if(i == INDEX_2)
		{
			LanguageSelect(FONT20B);
		}
		GUI_DispStringInRect(buf[i], &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
		rect.y0 += HEIGHT_VALUE;
		rect.y1 += HEIGHT_VALUE;
	}
	gStatusSendEnd = STATUS_SEND_ING;
	statusSendStep = -1;
	nSendStep = 0;
}

static void MLinkSetInitDisp(void)
{
	GUI_SetBkColor(COLOR_MAIN_BG);
//	(void)GUI_SetFont(&GUI_Font20_ASCII);
	LanguageSelect(FONT20);

	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_LINE);

	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	GUI_DrawRect(STARTX_CONTENTS, STARTY_CONTENTS, (STARTX_CONTENTS + WIDTH_CONTENTS) - 1, (STARTY_CONTENTS + (HEIGHT_LABEL * INDEX_3 )) - 1);

	for(int i = 0; i < (LINECOUNT_CONTENTS-INDEX_4); i++)
	{
		int y0 = STARTY_CONTENTS + ((i + 1) * HEIGHT_LABEL);
		GUI_DrawHLine(y0, STARTX_CONTENTS+INDEX_2, (STARTX_CONTENTS + WIDTH_CONTENTS) - 1);
	}

	GUI_SetColor(COLOR_LABEL);
	GUI_RECT rect;
	rect.x0 = STARTX_LABEL;
	rect.y0 = STARTY_LABEL;
	rect.x1 = (STARTX_LABEL +  WIDTH_LABEL) - 1;
	rect.y1 = (STARTY_LABEL +  HEIGHT_LABEL) - 1;

	for(int i = 0 ; i < (LINECOUNT_CONTENTS-INDEX_3); i++)
	{
		GUI_DispStringInRect(_acmlink_hwset_label_text[SettingValue[SETUP_LANGUAGE]][i], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);
		rect.y0 += HEIGHT_LABEL;
		rect.y1 += HEIGHT_LABEL;
	}
}

// PRQA S 1503 1
void MLinkHwSet(void)
{
	int flagBreak = FALSE;
	MLinkSetInitDisp();
	MlinkHwSetSend();

	while (1)
	{
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			nSendStep = 0;
			statusSendStep = 0;
			MlinkHwSetSend();
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			else {}
			MLinkSetInitDisp();
			gCommOldStatus[gDeviceIndex] = -1;
		}
		else
		if(key == DATA_RECV)
		{
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				StatusRecv();
				MlinkHwSetSend();
			}
			else
			{
				MlinkHwSetDisp();
			  if(nSendStep != 0)
			  {
			  	  MlinkHwSetSend();
			  }
			  else
			  {
					g_bRecvAllDone = TRUE;
					(void)printf("g_bRecvAllDone=0\n");
			  }
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{
			(void)printf("COMM Error!! gStatusSendEnd=%d, statusSendStep=%d\n",gStatusSendEnd,statusSendStep); 
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				if(nSendStep < INDEX_1)
				{
					MlinkHwSetSend();
				}
				else
				{
					g_bRecvAllDone = TRUE;
			
					(void)printf("All done!!!\n");
					gStatusSendEnd = STATUS_SEND_ING;
					statusSendStep = 0;
					nSendStep = 0;
				}

//				MlinkHwSetSend();
//				gStatusSendEnd = STATUS_SEND_ING;
//				statusSendStep = -1;
//				nSendStep = 0;
			}
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			MLinkSetInitDisp();
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
	}
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
