/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#define EXTERN extern
#include "stm32f4xx_hal.h"
#include "main.h"
#include "GuiData.h"

static void BaseDispU32(uint32_t value, char* mks, const char* baseUnit, char result[DEFAULT_BUF_SIZE]);
static void DispFormatU32(uint32_t value, const char* baseUnit, char result[DEFAULT_BUF_SIZE]);
static void DeviceInfoSend(void);
static void OperationInfoSend(void);
static void DeviceInfoValueDisp(void);
static void DeviceInitDisp(void);
static void OperationInfoValueDisp(void);
static void OperationDisp(void);
static void OperationInitDisp(void);
static void MlinkDeviceDisp(void);

//extern char gProductName[DEVICE_MAX][50];

static void BaseDispU32(uint32_t value, char* mks, const char* baseUnit, char result[DEFAULT_BUF_SIZE])
{
	(void)sprintf(result, "(%d%s%s)", value, mks, baseUnit);
}

static void DispFormatU32(uint32_t value, const char* baseUnit, char result[DEFAULT_BUF_SIZE])
{
	uint32_t v = abs(value);
	if(v < THOUSAND)
	{
		BaseDispU32(value, "", baseUnit, result);
		return;
	}
	value = value / THOUSAND;
	v = (v / THOUSAND);
	if(v < TENTHOUSAND)
	{
		BaseDispU32(value, "k", baseUnit, result);
		return;
	}
	value = value / THOUSAND;
	v = (v / THOUSAND);
	if(v < TENTHOUSAND)
	{
		BaseDispU32(value, "M", baseUnit, result);
		return;
	}
	value = value / THOUSAND;
	v = (v / THOUSAND);
	if(v < TENTHOUSAND)
	{
		BaseDispU32(value, "G", baseUnit, result);
		return;
	}
	value = value / THOUSAND;
	v = (v / THOUSAND);
	if(v < TENTHOUSAND)
	{
		BaseDispU32(value, "T", baseUnit, result);
		return;
	}
	value = value / THOUSAND;
	v = (v / THOUSAND);
	BaseDispU32(value, "P", baseUnit, result);
}

static void DeviceInfoSend(void)
{
	if(StatusSend() == STATUS_SEND_ING)
	{
		return;
	}
	if(nSendStep == 0)
	{
		ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, MLINK_DEVICE_INFO_READ_ADDR, MLINK_DEVICE_INFO_READ_LEN);
	}
}

static void OperationInfoSend(void)
{
	if(StatusSend() == STATUS_SEND_ING)
	{
		return;
	}
	if(nSendStep == INDEX_0)
	{
		ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, HOLDING_REGISTER, MLINK_INFO_STEP0_READ_ADDR, MLINK_INFO_STEP0_READ_LEN);
	}
	else
	if(nSendStep == INDEX_1)
	{
		ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, MLINK_INFO_STEP1_READ_ADDR, MLINK_INFO_STEP1_READ_LEN);
	}
	else
	if(nSendStep == INDEX_2)
	{
		ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, MLINK_INFO_STEP2_READ_ADDR, MLINK_INFO_STEP2_READ_LEN);
	}
	else {}
}

static void DeviceInfoValueDisp(void)
{
	char buf[LINECOUNT_CONTENTS][MESSAGE_BUF_SIZE];
	char productName[MESSAGE_BUF_SIZE];
//	char productCode[DEFAULT_BUF_SIZE];

	ModbusGetString(I_REGISTER_1335, INDEX_32, productName);		// Product Name
	ModbusGetString(I_REGISTER_1394, INDEX_12, productCode);		// Product Code


	ModbusGetString(I_REGISTER_1301, INDEX_4, buf[INDEX_0]);		// manufacture
//	ModbusGetString(1335, 32, buf[1]);		// Product Name
	(void)sprintf(buf[1], "%s(%s)", productName, productCode);
	ModbusGetString(I_REGISTER_1400, INDEX_10, buf[INDEX_2]);		// H/W Verison
	ModbusGetString(I_REGISTER_1405, INDEX_10, buf[INDEX_3]);		// S/W Version
	ModbusGetString(I_REGISTER_1320, INDEX_10, buf[INDEX_4]);		// Comm. Version
	ModbusGetString(I_REGISTER_1383, INDEX_22, buf[INDEX_5]);	// Serial Version

	GUI_SetColor(COLOR_VALUE);
	GUI_SetBkColor(COLOR_MAIN_BG);
//	GUI_RECT rect;
//	GUI_RECT rect;
//	rect.x0 = STARTX_CONTENTS + WIDTH_LABEL;
//	rect.y0 = STARTY_VALUE;
//	rect.x1 = (STARTX_VALUE + WIDTH_VALUE) - 1;
//	rect.y1 = (STARTY_VALUE + HEIGHT_VALUE) - 1;

	GUI_RECT rect;
	GUI_RECT rect2;
	rect.x0 = INFO_VALUE_X0;
	rect.y0 = STARTY_VALUE + INDEX_2;
	rect.x1 = INFO_VALUE_X1;
	rect.y1 = (STARTY_VALUE + HEIGHT_VALUE) - INDEX_4;

	rect2.x0 = INFO_VALUE_X0 - INDEX_80;
	rect2.y0 = STARTY_VALUE + INDEX_2;
	rect2.x1 = INFO_VALUE_X1;
	rect2.y1 = (STARTY_VALUE + HEIGHT_VALUE) - INDEX_4;

	(void)GUI_SetFont(&GUI_Font20B_ASCII);
	for(int i = 0 ; i < LINECOUNT_CONTENTS; i++)
	{
//		GUI_ClearRectEx(&rect);
//		GUI_DispStringInRect(buf[i], &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
		if(i == 1)
		{
			GUI_ClearRectEx(&rect2);
			GUI_DispStringInRect(buf[i], &rect2, GUI_TA_RIGHT | GUI_TA_VCENTER);
		}
		else
		{
			GUI_ClearRectEx(&rect);
			GUI_DispStringInRect(buf[i], &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
		}
		rect.y0 += HEIGHT_VALUE;
		rect.y1 += HEIGHT_VALUE;
		rect2.y0 += HEIGHT_VALUE;
		rect2.y1 += HEIGHT_VALUE;
	}
}

static void DeviceInitDisp(void)
{
	int count = LINECOUNT_CONTENTS;

	GUI_SetBkColor(COLOR_MAIN_BG);
	(void)GUI_SetFont(&GUI_Font20_ASCII);

	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_LINE);

	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	GUI_DrawRect(STARTX_CONTENTS, STARTY_CONTENTS, (STARTX_CONTENTS + WIDTH_CONTENTS) - 1, (STARTY_CONTENTS + (HEIGHT_LABEL * count )) - 1);

	for(int i = 0; i < (count-1); i++)
	{
		int y0 = STARTY_CONTENTS + ((i + 1) * HEIGHT_LABEL);
		GUI_DrawHLine(y0, STARTX_CONTENTS+INDEX_2, (STARTX_CONTENTS + WIDTH_CONTENTS)-1);
	}

	GUI_SetColor(COLOR_LABEL);
	GUI_RECT rect;
	rect.x0 = STARTX_LABEL;
	rect.y0 = STARTY_LABEL;
	rect.x1 = STARTX_LABEL +  WIDTH_LABEL + INDEX_10;
	rect.y1 = (STARTY_LABEL +  HEIGHT_LABEL) - 1;

//	(void)GUI_SetFont(&GUI_Font20_ASCII);
	LanguageSelect(FONT20);
	for(int i = 0 ; i < count; i++)
	{
		GUI_DispStringInRect(_acinfo_label_text[SettingValue[SETUP_LANGUAGE]][0][i], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);
		rect.y0 += HEIGHT_LABEL;
		rect.y1 += HEIGHT_LABEL;
	}
}

static void MlinkDeviceDisp(void)
{
	int flagBreak = FALSE;
	nSendStep = 0;
	DeviceInitDisp();
	DeviceInfoSend();

	while (1)
	{
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			statusSendStep = 0;
			DeviceInfoSend();
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			DeviceInitDisp();
		}
		else
		if(key == DATA_RECV)
		{
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				StatusRecv();
				DeviceInfoSend();
			}
			else
			{
				DeviceInfoValueDisp();
				g_bRecvAllDone = TRUE;
				nSendStep = 0;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
			}
		}
//		if(key == DATA_RECV)
//			DeviceInfoValueDisp();
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{
			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
//				DeviceInfoSend();
				g_bRecvAllDone = TRUE;
				nSendStep = 0;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
			}
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			DeviceInitDisp();
		}
		else {}

		if(flagBreak == TRUE)
		{
			break;
		}
	}
}

static void OperationInfoValueDisp(void)
{
	static uint16_t DiType[MLINK_DI_MAX];
	static float DiConstant[MLINK_DI_MAX];
	static char const* _acPulse_unit[PULSE_UNIT_COUNT] = {
		"",
		"Wh",
		"Varh",
		"VAh",
		""
	};

	if(nSendStep == INDEX_0)
	{
		int index = H_REGISTER_2031;
		int constantIndex = H_REGISTER_2037;
		for(int i = 0; i < MLINK_DI_MAX; i++)
		{
			uint16_t value = ModbusGetUint16(index++);
			DiType[i] = 0;
			if(value == PulseWh)		// Wh
			{
				DiType[i] = INDEX_1;
			}
			else
			if(value == PulseVarh)		// Varh
			{
				DiType[i] = INDEX_2;
			}
			else
			if(value == PulseVAh)		// VAh
			{
				DiType[i] = INDEX_3;
			}
			else
			if(value == Pulse)		// ±âÅ¸
			{
				DiType[i] = INDEX_4;
			}
			else {}
			DiConstant[i] = ModbusGetFloat(constantIndex);
//			printf("DI %d => Type = %04X, Constant = %f\n", i+1, value, DiConstant[i]);
			constantIndex += INDEX_2;
		}
		nSendStep = 1;
		OperationInfoSend();
		return;
	}

	GUI_SetColor(COLOR_VALUE);
	(void)GUI_SetFont(&GUI_Font20B_ASCII);
	GUI_SetBkColor(COLOR_MAIN_BG);

	GUI_RECT rect;
	GUI_RECT rect2;
	GUI_RECT rect3;
//	rect.x0 = MLINK_INFO_VALUE3_X0;
//	rect.x1 = rect.x0 + MLINK_INFO_VALUE_WIDTH - 1;
////	rect.y0 = STARTY_VALUE;
////	rect.y1 = rect.y0 + HEIGHT_VALUE - 1;
//	rect.y0 = MLINK_INFO_LABEL_Y0-1;
//	rect.y1 = rect.y0 + MLINK_INFO_TITLE_HEIGHT-2;
//
////	GUI_DispStringInRect(_acmlink_info_title_value_text, &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);

//	rect.y0 = STARTY_VALUE + (HEIGHT_VALUE * 2);
//	rect.y1 = rect.y0 + HEIGHT_VALUE - 1;
	rect.y0 = MLINK_INFO_LABEL_Y0-1;
	rect.y1 = (rect.y0 + MLINK_INFO_TITLE_HEIGHT) - INDEX_2;


	rect3.y0 = rect.y0;
	rect3.y1 = rect.y1;
	rect2.y0 = rect.y0 + MARGIN_24;
	rect2.y1 = rect2.y0 + MARGIN_20;

	rect.x0 = MLINK_INFO_VALUE1_X0;
	rect.x1 = (rect.x0 + MLINK_INFO_VALUE_WIDTH) - 1;
	rect2.x0 = MLINK_INFO_VALUE1_X0;
	rect2.x1 = (rect2.x0 + MLINK_INFO_VALUE_WIDTH) - 1;
	rect3.x0 = MLINK_INFO_VALUE3_X0;
	rect3.x1 = (rect3.x0 + MLINK_INFO_VALUE_WIDTH) - 1;

	if(nSendStep == INDEX_1)
	{
		uint16_t addr = I_REGISTER_1101;	//DO
		for(int i = 0 ; i < MLINK_DO_MAX; i++)
		{
			char buf[DEFAULT_BUF_SIZE];
			(void)sprintf(buf, "%d", ModbusGetUint32(addr));
			GUI_ClearRectEx(&rect3);
			GUI_DispStringInRect(buf, &rect3, GUI_TA_RIGHT | GUI_TA_VCENTER);
			rect3.y0 += MLINK_INFO_LABEL_Y_DISTANCE;
			rect3.y1 += MLINK_INFO_LABEL_Y_DISTANCE;

			addr += INDEX_2;
		}
		nSendStep = INDEX_2;
		OperationInfoSend();
		return;
	}
	else
	if(nSendStep == INDEX_2)
	{
		uint16_t addr;
		addr = I_REGISTER_1121;		// DI1
		for(int i = 0 ; i < MLINK_DI_MAX; i++)
		{
			char buf[DEFAULT_BUF_SIZE];
			uint32_t value = ModbusGetUint32(addr);
			(void)sprintf(buf, "%d", value);
			(void)GUI_SetFont(&GUI_Font20B_ASCII);
			GUI_ClearRectEx(&rect);
			GUI_DispStringInRect(buf, &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
			if(DiType[i] != 0)
			{
				uint32_t energy = (uint32_t)((float)value * DiConstant[i]);
				DispFormatU32(energy, _acPulse_unit[DiType[i]], buf);
				(void)GUI_SetFont(&GUI_Font16_ASCII);
				GUI_ClearRectEx(&rect2);
				GUI_DispStringInRect(buf, &rect2, GUI_TA_RIGHT | GUI_TA_TOP);
			}
			addr += INDEX_2;
			if( i == INDEX_2)
			{
				rect.x0 = MLINK_INFO_VALUE2_X0;
				rect.x1 = (rect.x0 + MLINK_INFO_VALUE_WIDTH) - 1;
				rect.y0 = MLINK_INFO_LABEL_Y0-1;
				rect.y1 = (rect.y0 + MLINK_INFO_TITLE_HEIGHT) - INDEX_2;

				rect2.x0 = MLINK_INFO_VALUE2_X0;
				rect2.x1 = (rect2.x0 + MLINK_INFO_VALUE_WIDTH) - 1;
				rect2.y0 = rect.y0 + MARGIN_24;
				rect2.y1 = rect2.y0 + MARGIN_20;
			}
			else
			{
				rect.y0 += MLINK_INFO_LABEL_Y_DISTANCE;
				rect.y1 += MLINK_INFO_LABEL_Y_DISTANCE;
				rect2.y0 += MLINK_INFO_LABEL_Y_DISTANCE;
				rect2.y1 += MLINK_INFO_LABEL_Y_DISTANCE;
			}
		}
	}
	else {}
	nSendStep = 0;
}

static void OperationInitDisp(void)
{
	int count = LINECOUNT_CONTENTS;

	GUI_SetBkColor(COLOR_MAIN_BG);
//	(void)GUI_SetFont(&GUI_Font20_ASCII);
	LanguageSelect(FONT20);

	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_LINE);

	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	GUI_DrawRect(STARTX_CONTENTS, STARTY_CONTENTS, (STARTX_CONTENTS + WIDTH_CONTENTS) - 1, (STARTY_CONTENTS + (HEIGHT_LABEL * count )) - 1);

	GUI_RECT rect;
	rect.x0 = MLINK_INFO_LABEL1_X0;
	rect.y0 = MLINK_INFO_TITLE_Y0;
	rect.x1 = (MLINK_INFO_LABEL1_X0 +  MLINK_INFO_TITLE_WIDTH) - 1;
	rect.y1 = (MLINK_INFO_TITLE_Y0 +  MLINK_INFO_TITLE_HEIGHT) - 1;

	GUI_SetColor(COLOR_LABEL);
	GUI_DispStringInRect(_acmlink_info_title_text[SettingValue[SETUP_LANGUAGE]], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);

	(void)GUI_SetFont(&GUI_Font20_ASCII);
	rect.y0 = MLINK_INFO_LABEL_Y0;
	rect.y1 = rect.y0 + MLINK_INFO_TITLE_HEIGHT;

	GUI_RECT rect2;
	GUI_RECT rect3;

	rect.x0 = MLINK_INFO_LABEL1_X0;
	rect.x1 = (rect.x0 + MLINK_INFO_LABEL_WIDTH) - 1;
	rect2.x0 = MLINK_INFO_LABEL2_X0;
	rect2.x1 = (rect2.x0 + MLINK_INFO_LABEL_WIDTH) - 1;
	rect3.x0 = MLINK_INFO_LABEL3_X0;
	rect3.x1 = (rect3.x0 + MLINK_INFO_LABEL_WIDTH) - 1;

	rect2.y0 = rect3.y0 = rect.y0;
	rect2.y1 = rect3.y1 = rect.y1;
	for(int i = 0; i < INDEX_4; i++)
	{
		GUI_DispStringInRect(_acmlink_info_label_text[INDEX_0][i], &rect, GUI_TA_LEFT | GUI_TA_TOP);
		GUI_DispStringInRect(_acmlink_info_label_text[INDEX_1][i], &rect2, GUI_TA_LEFT | GUI_TA_TOP);
		GUI_DispStringInRect(_acmlink_info_label_text[INDEX_2][i], &rect3, GUI_TA_LEFT | GUI_TA_TOP);

		rect.y0 += MLINK_INFO_LABEL_Y_DISTANCE;
		rect.y1 += MLINK_INFO_LABEL_Y_DISTANCE;
		rect2.y0 += MLINK_INFO_LABEL_Y_DISTANCE;
		rect2.y1 += MLINK_INFO_LABEL_Y_DISTANCE;
		rect3.y0 += MLINK_INFO_LABEL_Y_DISTANCE;
		rect3.y1 += MLINK_INFO_LABEL_Y_DISTANCE;
	}
}

static void OperationDisp(void)
{
	int flagBreak = FALSE;
	nSendStep = 0;

	OperationInitDisp();
	OperationInfoSend();

	while (1)
	{
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			statusSendStep = 0;
			OperationInfoSend();
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			OperationInitDisp();
		}
		else
		if(key == DATA_RECV)
		{
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				StatusRecv();
				OperationInfoSend();
			}
			else
			{
				OperationInfoValueDisp();
				if(nSendStep != 0)
				{
					OperationInfoSend();
				}
				else
				{
					g_bRecvAllDone = TRUE;
					nSendStep = 0;
					statusSendStep = 0;
					gStatusSendEnd = STATUS_SEND_ING;
				}
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{
			if(gStatusSendEnd == STATUS_SEND_END)
			{
				nSendStep++;
			}
			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				if(nSendStep < INDEX_3)
				{
					OperationInfoSend();
				}
				else
				{
					g_bRecvAllDone = TRUE;
					(void)printf("All done!!!\n");
					nSendStep = 0;
					statusSendStep = 0;
					gStatusSendEnd = STATUS_SEND_ING;
				}
			}
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			OperationInitDisp();
		}
		else {}

		if(flagBreak == TRUE)
		{
			break;
		}
	}
}


/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       Createstatus_window
*/

// PRQA S 1503 1
void MLinkInfomation(void)
{
	int flagBreak = FALSE;
	nMenuPos = 0;

	InfoMenu(INFO_MENU, nMenuPos, INFO_MENU_COUNT);

	GUI_SetBkColor(COLOR_MAIN_BG);
	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_LINE);
	gStatusSendEnd = STATUS_SEND_ING;
	ReadyToSend();
	(void)StatusSend();

	while (1)
    {
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			statusSendStep = 0;
			(void)StatusSend();
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			InfoMenu(INFO_MENU, nMenuPos, INFO_MENU_COUNT);
			gCommOldStatus[gDeviceIndex] = -1;
		}
		else
		if(key == KEY_UP)
		{
			if(nMenuPos > 0)
			{
				nMenuPos--;
				InfoMenu(INFO_MENU, nMenuPos, INFO_MENU_COUNT);
			}
		}
		else
		if(key == KEY_DOWN)
		{
			if(nMenuPos < (INFO_MENU_COUNT-1))
			{
				nMenuPos++;
				InfoMenu(INFO_MENU, nMenuPos, INFO_MENU_COUNT);
			}
		}
		else
		if(key == KEY_ENTER)
		{
			if(nMenuPos == 0)
			{
				MlinkDeviceDisp();
			}
			else
			if(nMenuPos == 1)
			{
				OperationDisp();
			}
			else {}
			InfoMenu(INFO_MENU, nMenuPos, INFO_MENU_COUNT);
		}
		else
		if(key == DATA_RECV)
		{
			StatusRecv();
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				(void)StatusSend();
			}
			else
			{
				g_bRecvAllDone = TRUE;
				nSendStep = 0;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{
			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				g_bRecvAllDone = TRUE;
				(void)printf("All done!!!\n");
				gStatusSendEnd = STATUS_SEND_ING;
				statusSendStep = 0;
				nSendStep = 0;
			}
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			// flagBreak = TRUE;
		}
		else {}

		if(flagBreak == TRUE)
		{
			break;
		}
	}
}
// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
