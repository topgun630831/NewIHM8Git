/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#define EXTERN extern
#include "stm32f4xx_hal.h"
#include "main.h"
#include "GuiData.h"
#include "string.h"
#include "math.h"

//static uint16_t nEventCount;
//static uint16_t nFaultCount;

static void BaseDisp2(float value, char* mks, const char*baseUnit, char result[RESULT_BUF_SIZE]);
static void DispFormat2(float value, const char* baseUnit, char result[RESULT_BUF_SIZE]);
static void EventMenuDisp(int pos);
static void EventMenu(int pos);

static void BaseDisp2(float value, char* mks, const char*baseUnit, char result[RESULT_BUF_SIZE])
{
	int point;
	char format[FORMAT_BUF_SIZE];
	float v = fabs(value);

	if(v < TEN)
	{
		point = INDEX_3;
	}
	else
	if(v < HUNDRED)
	{
		point = INDEX_2;
	}
	else
	if(v < THOUSAND)
	{
		point = INDEX_1;
	}
	else
	{
		point = INDEX_0;
	}
	(void)sprintf(format, "%%5.%df %s%s", point, mks, baseUnit);
	(void)sprintf(result, format, value);
}

static void DispFormat2(float value, const char* baseUnit, char result[RESULT_BUF_SIZE])
{
	float v = fabs(value);
	if(v < THOUSAND)
	{
		BaseDisp2(value, "", baseUnit, result);
		return;
	}
	value = value / THOUSAND;
	v = v / THOUSAND;
	if(v < THOUSAND)
	{
		BaseDisp2(value, "k", baseUnit, result);
		return;
	}
	value = value / THOUSAND;
	v = v / THOUSAND;
	if(v < THOUSAND)
	{
		BaseDisp2(value, "M", baseUnit, result);
		return;
	}
	value = value / THOUSAND;
	v = v / THOUSAND;
	if(v < THOUSAND)
	{
		BaseDisp2(value, "G", baseUnit, result);
		return;
	}
}

// PRQA S 1505 1
void EventSend(int bEvent)
{
	uint16_t SendIndex;
	
	if(bEvent == TRUE)
	{
		(void)printf("Event Send.....\n");
		uint8_t fileNo = MODBUS_FILE_NO_SYSTEM;
		if(nMenuPos)
		{
		fileNo = MODBUS_FILE_NO_FAULT;
		}
		if(nCurrIndex <=  nEventIndex)
		{
			SendIndex = (nEventIndex - nCurrIndex) + 1;
		}
		else
		{
			SendIndex = nEventTotal - (nCurrIndex - nEventIndex - 1);
		}
		CommTimerClear();
		(void)printf("\n\n\n\n\n\nIndex=%d=> Send=%d\n\n\n\n\n\n\n\n", nCurrIndex, SendIndex);
		ModbusSendFrameEvent(ConnectSetting[gDeviceIndex].Address, fileNo, SendIndex);
		gStatusSendEnd = STATUS_SEND_END;
	}
	else
	if(StatusSend() == STATUS_SEND_ING)
	{
		return;
	}
	else
	{
	}
}

// PRQA S 1505 1
void EventDataRecv(void)
{
	(void)printf("EventDataRecv\n");
	gStatusSendEnd = STATUS_SEND_ING;
	char buf[EVENT_LINE_MAX][RESULT_BUF_SIZE];

	uint16_t mainCategory;
	uint16_t middleCategory;
	uint16_t smallCategory;
	S_DATE_TIME dateTime;
	uint16_t Status;
	float 	Value;

	GUI_SetBkColor(COLOR_MAIN_BG);
	GUI_ClearRect(STARTX_CONTENTS+1, EVENT_CONTENTS_Y0+1, (STARTX_CONTENTS + WIDTH_CONTENTS)-INDEX_2, EVENT_CONTENTS_Y1-1);

	ModbusAcbSystemEventGet(&dateTime, &mainCategory, &middleCategory, &smallCategory, &Status, &Value);
	(void)printf("\n\n\n Event(%d, %d, %d,  =>%d\n\n\n", mainCategory, middleCategory, smallCategory, Status);
	(void)sprintf(buf[0], "%04d-%02d-%02d %02d:%02d:%02d.%03d", dateTime.Year, dateTime.Month, dateTime.Day, dateTime.Hour, dateTime.Min, dateTime.Sec, dateTime.mSec);
	if(nMenuPos == 0)
	{
		(void)strcpy(buf[1], acSystemEventMainMsg[SettingValue[SETUP_LANGUAGE]][mainCategory]);
		if(mainCategory == SYSTEM_EVENT_STATUS_CHANGE)
		{
			if((middleCategory >= SYSTEM_EVENT_STATUS_CHANGE_COUNT) || (smallCategory >= SYSTEM_EVENT_STATUS_CHANGE_SMALL_COUNT))
			{
				return;
			}
			(void)strcpy(buf[INDEX_2], acSystemEventStatusChange[SettingValue[SETUP_LANGUAGE]][middleCategory]);
			(void)strcpy(buf[INDEX_3], acSystemEventStatusChangeSmall[SettingValue[SETUP_LANGUAGE]][middleCategory][smallCategory]);
		}
		else
		if(mainCategory == SYSTEM_EVENT_SETTING_CHANGE)
		{
			if((middleCategory >= SYSTEM_EVENT_SETTING_CHANGE_COUNT) || (smallCategory >= SYSTEM_EVENT_SETTING_CHANGE_SMALL_COUNT))
			{
				return;
			}
			(void)strcpy(buf[INDEX_2], acSystemEventSettingChange[SettingValue[SETUP_LANGUAGE]][middleCategory]);
			(void)strcpy(buf[INDEX_3], acSystemEventSettingChangeSmall[SettingValue[SETUP_LANGUAGE]][middleCategory][smallCategory]);
		}
		else
		if(mainCategory == SYSTEM_EVENT_SYSTEM_CHANGE)
		{
			if(smallCategory >= SYSTEM_EVENT_SYSTEM_CHANGE_SMALL_COUNT)
			{
				return;
			}
			(void)strcpy(buf[INDEX_2], acSystemEventSystemChange[SettingValue[SETUP_LANGUAGE]][middleCategory]);
			(void)strcpy(buf[INDEX_3], acSystemEventSystemChangeSmall[SettingValue[SETUP_LANGUAGE]][middleCategory][smallCategory]);
		}
		else
		{
			return;
		}
	}
	else
	if(nMenuPos == 1)
	{
		(void)printf("%d, %d, %s, %x, %f\n", middleCategory, FAULT_MIDDLE_COUNT, acFaultMiddleMsg[SettingValue[SETUP_LANGUAGE]][middleCategory], Status, Value);
		if(middleCategory < FAULT_MIDDLE_COUNT)
		{
			(void)strcpy(buf[1], acFaultMiddleMsg[SettingValue[SETUP_LANGUAGE]][middleCategory]);
		}
		else
		{
			return;
		}

		int source=0;
		int phase=0;

		source = (Status & SOURCE_MASK);
//		if(Status & 0x0001)
//			source = 0;
//		else
//		if(Status & 0x0002)
//			source = 1;
//		else
//		if(Status & 0x0004)
//			source = 2;
//		else
//		if(Status & 0x0008)
//			source = 3;


//		if(Status & 0x0100)
//			phase = 0;
//		else
//		if(Status & 0x0200)
//			phase = 1;
//		else
//		if(Status & 0x0400)
//			phase = 2;
//		else
//		if(Status & 0x0800)
//			phase = 3;
		phase = (Status & PHASE_MASK) >> INDEX_8;
		if(phase > INDEX_8)
		{
			phase = 0;
		}
		if((phase ==0) || (phase == INDEX_7))
		{
			(void)sprintf(buf[INDEX_2], "%s", acFaultSource[source]);
		}
		else
		{
			(void)sprintf(buf[INDEX_2], "%s - %s", acFaultPhase[SettingValue[SETUP_LANGUAGE]][phase], acFaultSource[source]);
		}
		DispFormat2(Value, acFaultUnit[source], buf[INDEX_3]);
	}
	else {}
	//(void)GUI_SetFont(&GUI_Font24B_ASCII);
	LanguageSelect(FONT24B);
	GUI_SetColor(COLOR_VALUE);
	GUI_RECT rect;
	rect.x0 = EVENT_X0;
	rect.y0 = EVENT_DATE_Y0;
	rect.x1 = (STARTX_CONTENTS + WIDTH_CONTENTS) - 1;
	rect.y1 = (EVENT_DATE_Y0 + HEIGHT_LABEL) - 1;
	for(int i = 0 ; i < EVENT_LINE_MAX; i++)
	{
		GUI_DispStringInRect(buf[i], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);
		rect.y0 += HEIGHT_LABEL;
		rect.y1 += HEIGHT_LABEL;
	}
	if(gReadIndex <=  nEventIndex)
	{
		nCurrIndex = (nEventIndex - gReadIndex) + 1;
	}
	else
	{
		nCurrIndex = nEventTotal - (gReadIndex - nEventIndex - 1);
	}
	CountDisp(nEventTotal, nCurrIndex);
		/*
		if(eventRolloverCount == 0)
			nEventCount = eventCnt;
		else
			nEventCount = 255;

		if(faultRolloverCount == 0)
			nFaultCount = faultCnt;
		else
			nFaultCount = 127;
*/

}

static void EventMenuDisp(int pos)
{
	GUI_SetBkColor(COLOR_MAIN_BG);

	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_LINE);

	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	GUI_DrawRect(STARTX_CONTENTS, EVENT_CONTENTS_Y0, (STARTX_CONTENTS + WIDTH_CONTENTS)-1, EVENT_CONTENTS_Y1);

	if(pos == 0)
	{
		nEventIndex = gSystemEventIndex[gDeviceIndex];
		nEventTotal = gSystemEventTotalCount[gDeviceIndex];
	}
	else
	if(pos == 1)
	{
		nEventIndex = gFaultEventIndex[gDeviceIndex];
		nEventTotal = gFaultEventTotalCount[gDeviceIndex];
	}
	else {}

//	bEventSend = TRUE;
//	(void)EventSend();

//	if((gCommStatus[gDeviceIndex] == COMM_OK) && (nEventTotal != 0))
	if(gCommStatus[gDeviceIndex])
	{
		if(nEventTotal == 0)
		{
			nCurrIndex = 0;
		}
		CountDisp(nEventTotal, nCurrIndex);
	}

	GUI_SetColor(COLOR_LABEL);
	GUI_RECT rect;
	rect.x0 = EVENT_X0;
	rect.y0 = EVENT_TITLE_Y0;
	rect.x1 = EVENT_TITLE_X1;
	rect.y1 = EVENT_TITLE_Y1;
	LanguageSelect(FONT24);
	GUI_DispStringInRect(_acinfo_menu_text[SettingValue[SETUP_LANGUAGE]][EVENT_MENU][pos], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);

//	if((gCommStatus[gDeviceIndex] == COMM_OK) && (nEventTotal == 0))
//	{
//		LanguageSelect(FONT24B);
//		GUI_SetColor(COLOR_VALUE);
//		rect.x0 = EVENT_X0;
//		rect.y0 = EVENT_DATE_Y0;
//		rect.x1 = (STARTX_CONTENTS + WIDTH_CONTENTS) - 1;
//		rect.y1 = (EVENT_DATE_Y0 + HEIGHT_LABEL) - 1;
//		GUI_DispStringInRect(acevent_noevent_text[SettingValue[SETUP_LANGUAGE]], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);
//	}
}

static void EventMenu(int pos)
{
	int bCommError = gCommStatus[gDeviceIndex];
	int flagBreak = FALSE;
	nCurrIndex = 1;
	EventMenuDisp(pos);

	(void)printf("\n\n\n EventMenu\n\n\n\n");
	if(nEventTotal != 0)
	{
//		bEventSend = TRUE;
		(void)EventSend(TRUE);
	}

	while (1)
	{
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			if(gOldFaultEventIndex[gDeviceIndex] != gFaultEventIndex[gDeviceIndex])
			{
				if(pos == 1)
				{
					nEventIndex = gFaultEventIndex[gDeviceIndex];
					nEventTotal = gFaultEventTotalCount[gDeviceIndex];
					EventMenuDisp(pos);
					gOldFaultEventIndex[gDeviceIndex] = gFaultEventIndex[gDeviceIndex];
					nCurrIndex = 1;
					bEventSend = TRUE;
					FaultCountWrite();
				}
			}
			(void)printf("TIME_OUT......\n");
			nSendStep = 0;
			statusSendStep = 0;
			gStatusSendEnd = STATUS_SEND_ING;
			(void)EventSend(FALSE);
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			EventMenuDisp(pos);
			(void)EventSend(TRUE);
		}
		else
		if(key == KEY_UP)
		{
			if(nEventTotal == 0)
			{
				continue;
			}
			if(nCurrIndex < nEventTotal)
			{
				nCurrIndex++;
			}
			else
			{
				nCurrIndex = 1;
			}
			(void)EventSend(TRUE);
			CountDisp(nEventTotal, nCurrIndex);
		}
		else
		if(key == KEY_DOWN)
		{
			if(nEventTotal == 0)
			{
				continue;
			}
			if(nCurrIndex > 1)
			{
				nCurrIndex--;
			}
			else
			{
				nCurrIndex = nEventTotal;
			}
			(void)EventSend(TRUE);
			CountDisp(nEventTotal, nCurrIndex);
		}
		else
		if(key == DATA_RECV)
		{
			if(bCommError == COMM_ERROR)
			{
				if(pos == 0)
				{
					nEventTotal = gSystemEventTotalCount[gDeviceIndex];
				}
				else
				{
					nEventTotal = gFaultEventTotalCount[gDeviceIndex];
				}
				nCurrIndex = 1;
				bCommError = COMM_OK;
				if(nEventTotal != 0)
				{
					gStatusSendEnd = STATUS_SEND_END;
					(void)EventSend(TRUE);
					continue;
				}
				else
				{
					EventMenuDisp(pos);
				}
			}
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				StatusRecv();
				if(gStatusSendEnd == STATUS_SEND_ING)
				{
					(void)EventSend(FALSE);
				}
				else
				{
					(void)printf("All done!!!\n");
					g_bRecvAllDone = TRUE;
					nSendStep = 0;
					statusSendStep = 0;
					gStatusSendEnd = STATUS_SEND_ING;
				}
			}
			else
			{
				(void)printf("All done!!!\n");
				EventDataRecv();
				g_bRecvAllDone = TRUE;
				nSendStep = 0;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{
			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep); 
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				g_bRecvAllDone = TRUE;
				(void)printf("All done!!!\n");
				gStatusSendEnd = STATUS_SEND_ING;
				statusSendStep = 0;
				nSendStep = 0;
			}
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			bCommError = COMM_ERROR;
			nEventTotal = 0;
			EventMenuDisp(pos);
			gStatusSendEnd = STATUS_SEND_ING;
			statusSendStep = 0;
			nSendStep = 0;
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
	}
}


/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       Createstatus_window
*/

// PRQA S 1503 2
// PRQA S 1505 1
void AcbMccbEvent(void)
{
	int flagBreak = FALSE;
	nMenuPos = 0;

	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	InfoMenu(EVENT_MENU, nMenuPos, EVENT_MENU_COUNT);

	//(void)StatusSend();

	nSendStep = 0;

	while (1)
    {
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			nSendStep = 0;
			statusSendStep = 0;
			gStatusSendEnd = STATUS_SEND_ING;
			(void)StatusSend();
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
			InfoMenu(EVENT_MENU, nMenuPos, EVENT_MENU_COUNT);
			gCommOldStatus[gDeviceIndex] = -1;
		}
		else
		if(key == KEY_UP)
		{
			if(nMenuPos > 0)
			{
				nMenuPos--;
			}
			else
			{
				nMenuPos = EVENT_MENU_COUNT - 1;
			}
			InfoMenu(EVENT_MENU, nMenuPos, EVENT_MENU_COUNT);
		}
		else
		if(key == KEY_DOWN)
		{
			if(nMenuPos < (EVENT_MENU_COUNT-1))
			{
				nMenuPos++;
			}
			else
			{
				nMenuPos = 0;
			}
			InfoMenu(EVENT_MENU, nMenuPos, EVENT_MENU_COUNT);
		}
		else
		if(key == KEY_ENTER)
		{
			if((nMenuPos == 1) && (gOldFaultEventIndex[gDeviceIndex] != gFaultEventIndex[gDeviceIndex]))
			{
				gOldFaultEventIndex[gDeviceIndex] = gFaultEventIndex[gDeviceIndex];
				FaultCountWrite();
			}
			EventMenu(nMenuPos);
			InfoMenu(EVENT_MENU, nMenuPos, EVENT_MENU_COUNT);
		}
		else
		if(key == DATA_RECV)
		{
			(void)printf("DATA_RECV\n");
			StatusRecv();
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				(void)EventSend(FALSE);
			}
			else
			{
				g_bRecvAllDone = TRUE;
				(void)printf("All done!!!\n");
				nSendStep = 0;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{
			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep); 
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				g_bRecvAllDone = TRUE;
				(void)printf("All done!!!\n");
				gStatusSendEnd = STATUS_SEND_ING;
				statusSendStep = 0;
				nSendStep = 0;
			}
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
	}
}
// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
