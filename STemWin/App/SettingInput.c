/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#define EXTERN extern
#include "stm32f4xx_hal.h"
#include "main.h"
#include "GuiData.h"

static void InputDisp(int value, int pos, int not_used);
static void InputDispString(const int value, const int pos, const char * const text[], int muti_lan);

static void InputDisp(int value, int pos, int not_used)
{

	GUI_RECT rect;
	GUI_SetBkColor(COLOR_MENU_NORMAL);
	GUI_ClearRect(SETUP_INPUT_X0, (SETUP_INPUT_Y0 - INDEX_17), SETUP_INPUT_X1, SETUP_INPUT_Y1 + INDEX_17);

	LanguageSelect(FONT24B);

	rect.x0 = SETUP_INPUT_X0;
	rect.y0 = SETUP_INPUT_Y0;
	rect.x1 = SETUP_INPUT_X1;
	rect.y1 = SETUP_INPUT_Y1;

	char buf[MESSAGE_BUF_SIZE];

	if(pos >= SETUP_INPUT_COUNT)
	{
		if((not_used == 1) && (value == 0))
		{
			(void)sprintf(buf, "%s", _acNotUsed[SettingValue[SETUP_LANGUAGE]]);
		}
		else
		{
			(void)sprintf(buf, "%d", value);
		}
		GUI_DispStringInRect(buf, &rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
		return;
	}

	GUI_SetColor(SELECTED_TEXT_COLOR);
	GUI_SetBkColor(GUI_BLACK);
	GUI_ClearRect(rect.x0, rect.y0, rect.x1, rect.y1);

	if((not_used == 1) && (value == 0))
	{
		(void)sprintf(buf, "%s", _acNotUsed[SettingValue[SETUP_LANGUAGE]]);
	}
	else
	{
		(void)sprintf(buf, "%d", value);
	}

	GUI_DispStringInRect(buf, &rect, GUI_TA_HCENTER | GUI_TA_VCENTER);

	(void)GUI_BMP_Draw(_acUp, SETUP_INPUT_UPDOWN_X0, SETUP_INPUT_Y0 - INDEX_17);
	(void)GUI_BMP_Draw(_acDown, SETUP_INPUT_UPDOWN_X0, SETUP_INPUT_Y1 + 1);
}

// PRQA S 1503 1
int SettingInput(uint16_t *orgValue, int const min, int const max, int const not_used)
{
	int flagBreak = FALSE;
	int nPos = 0;
	int	ret = FALSE;
	uint16_t value = *orgValue;

	GUI_SetBkColor(COLOR_MENU_NORMAL);

	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_MENU_SELECTED);

	GUI_ClearRect(POPUP_WINDOW_X0, POPUP_WINDOW_Y0, POPUP_WINDOW_X1, POPUP_WINDOW_Y1);
	GUI_DrawRect(POPUP_WINDOW_X0, POPUP_WINDOW_Y0, POPUP_WINDOW_X1, POPUP_WINDOW_Y1);

	InputDisp(value, nPos, not_used);
	ButtonDisp(CONTROL_BUTTON_NOSELECT);

	while (1)
	{
		E_KEY key = GetKey();

		if(key == KEY_UP)
		{
			if(nPos < SETUP_INPUT_COUNT)
			{
				if(value < max)
				{
					if(not_used == 1)
					{
						if(value == 0)
						{
							value = min;
						}
						else
						{
							value++;
						}
					}
					else
					{
						value++;
					}
					InputDisp(value, nPos, not_used);
				}
				else
				{
					if(not_used == 1)
					{
						value = 0;
					}
					else
					{
						value = min;
					}
					InputDisp(value, nPos, not_used);
				}
			}
			else
			if(nPos == (SETUP_INPUT_COUNT + 1))
			{
				ButtonDisp(CONTROL_BUTTON_OK);
				nPos = SETUP_INPUT_COUNT;
			}
			else {}
		}
		else
		if(key == KEY_DOWN)
		{
			if(nPos < SETUP_INPUT_COUNT)
			{
				if(value > min)
				{
					value--;
					InputDisp(value, nPos, not_used);
				}
				else
				{
					if(not_used == 1)
					{
						if(value == 0)
						{
							value = max;
						}
						else
						{
							value = 0;
						}
					}
					else
					{
						value = max;
					}
					InputDisp(value, nPos, not_used);
				}
			}
			else
			if(nPos == SETUP_INPUT_COUNT)
			{
				ButtonDisp(CONTROL_BUTTON_CANCEL);
				nPos = SETUP_INPUT_COUNT + 1;
			}
			else {}
		}
		else
		if(key == KEY_ENTER)
		{
			if(nPos < SETUP_INPUT_COUNT)
			{
				nPos++;
				InputDisp(value, nPos, not_used);
				ButtonDisp(CONTROL_BUTTON_OK);
			}
			else
			if(nPos == SETUP_INPUT_COUNT)	// OK 이면
			{
				*orgValue = value;
				ret = TRUE;
				flagBreak = TRUE;
			}
			else
			if(nPos == (SETUP_INPUT_COUNT + 1))	// Cancel 이면
			{
				flagBreak = TRUE;
			}
			else {}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
	}
	return ret;
}

static void InputDispString(const int value, const int pos, const char * const text[], int muti_lan)
{

	GUI_RECT rect;
	GUI_SetBkColor(COLOR_MENU_NORMAL);
	GUI_ClearRect(SETUP_INPUT_STRING_X0, SETUP_INPUT_Y0 - INDEX_17, SETUP_INPUT_STRING_X1, SETUP_INPUT_Y1 + INDEX_17);

//	(void)GUI_SetFont(&GUI_Font24B_ASCII);
	LanguageSelect(FONT24B);
	rect.x0 = SETUP_INPUT_STRING_X0;
	rect.y0 = SETUP_INPUT_Y0;
	rect.x1 = SETUP_INPUT_STRING_X1;
	rect.y1 = SETUP_INPUT_Y1;

	if(pos >= SETUP_INPUT_COUNT)
	{
		if(muti_lan == TRUE)
		{
			if(value == CHINESE)
			{
				(void)GUI_SetFont(&GUI_FontLSfont_24x24);
			}
			else
			if(value == RUSSIAN)
			{
				(void)GUI_SetFont(&GUI_Fontcyrillic_24x24);
			}
			else
			{
				(void)GUI_SetFont(&GUI_Font32B_ASCII);
			}
		}
		GUI_DispStringInRect(text[value], &rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
		return;
	}
	GUI_SetColor(SELECTED_TEXT_COLOR);
	GUI_SetBkColor(GUI_BLACK);
	GUI_ClearRect(rect.x0, rect.y0, rect.x1, rect.y1);

	if(muti_lan == TRUE)
	{
		if(value == CHINESE)
		{
			(void)GUI_SetFont(&GUI_FontLSfont_24x24);
		}
		else
		if(value == RUSSIAN)
		{
			(void)GUI_SetFont(&GUI_Fontcyrillic_24x24);
		}
		else
		{
			(void)GUI_SetFont(&GUI_Font32B_ASCII);
		}
	}
	GUI_DispStringInRect(text[value], &rect, GUI_TA_HCENTER | GUI_TA_VCENTER);

	(void)GUI_BMP_Draw(_acUp, SETUP_INPUT_UPDOWN_X0, SETUP_INPUT_Y0 - INDEX_17);
	(void)GUI_BMP_Draw(_acDown, SETUP_INPUT_UPDOWN_X0, SETUP_INPUT_Y1 + 1);
}

// PRQA S 1503 1
int SettingInputString(uint16_t* orgValue, int const max, const char* const text[], int multi_lan)
{
	int flagBreak = FALSE;
	int nPos = 0;
	int ret = FALSE;
	uint16_t value = *orgValue;

	if(value >= max)
	{
		value = 0;
	}
	GUI_SetBkColor(COLOR_MENU_NORMAL);

	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_MENU_SELECTED);

	GUI_ClearRect(POPUP_WINDOW_X0, POPUP_WINDOW_Y0, POPUP_WINDOW_X1, POPUP_WINDOW_Y1);
	GUI_DrawRect(POPUP_WINDOW_X0, POPUP_WINDOW_Y0, POPUP_WINDOW_X1, POPUP_WINDOW_Y1);

	InputDispString(value, nPos, text, multi_lan);
	ButtonDisp(CONTROL_BUTTON_NOSELECT);
	while (1)
	{
		E_KEY key = GetKey();

		if(key == KEY_UP)
		{
			if(nPos < SETUP_INPUT_COUNT)
			{
				if(value < (max - 1))
				{
					value++;
				}
				else
				{
					value = 0;
				}
				InputDispString(value, nPos, text, multi_lan);
			}
			else
			if(nPos == (SETUP_INPUT_COUNT + 1))
			{
				ButtonDisp(CONTROL_BUTTON_OK);
				nPos = SETUP_INPUT_COUNT;
			}
			else {}
		}
		else
		if(key == KEY_DOWN)
		{
			if(nPos < SETUP_INPUT_COUNT)
			{
				if(value > 0)
				{
					value--;
				}
				else
				{
					value = max - 1;
				}
				InputDispString(value, nPos, text, multi_lan);
			}
			else
			if(nPos == SETUP_INPUT_COUNT)
			{
				ButtonDisp(CONTROL_BUTTON_CANCEL);
				nPos = SETUP_INPUT_COUNT + 1;
			}
			else {}
		}
		else
		if(key == KEY_ENTER)
		{
			if(nPos < SETUP_INPUT_COUNT)
			{
				nPos++;
				InputDispString(value, nPos, text, multi_lan);
				ButtonDisp(CONTROL_BUTTON_OK);
			}
			else
			if(nPos == SETUP_INPUT_COUNT)	// OK 이면
			{
				*orgValue = value;
				ret = TRUE;
				flagBreak = TRUE;
			}
			else
			if(nPos == (SETUP_INPUT_COUNT + 1))	// Cancel 이면
			{
				flagBreak = TRUE;
			}
			else {}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
	}
	return ret;
}

/*************************** End of file ****************************/
