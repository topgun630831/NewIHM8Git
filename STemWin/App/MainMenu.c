/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#define EXTERN extern
#include "stm32f4xx_hal.h"
#include "main.h"
#include "GUI.h"
#include "DIALOG.h"
#include "GuiData.h"
#include <math.h>
#include "string.h"
#include "RTOS.h"
#include "string.h"
#include "modbus.h"

#define __SAVING_MODE__					1			// 0=disable, 1=enable

static void AcbMccbOverView(void);
static void AcbMccbOverViewValue(int flag);
static void PageDisp(int page);
static void CommStatusDisp(void);
static void Overview(bool newDisp);
static void ScreenTimerInit(void);
static uint32_t GetTimerDiff(void);

// PRQA S 1514 2
static uint8_t gTimeSyncDay;

uint8_t KeyChanged[KEY_MAX];

extern UART_HandleTypeDef huart6;

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

static float gLrValue[DEVICE_MAX];
static float gLnrValue[DEVICE_MAX];
static float gLnValue[DEVICE_MAX];
static float gNPHASE_PROTECTION_Value[DEVICE_MAX];
// PRQA S 1514 ++
int gAmpareFrame[DEVICE_MAX];
static uint32_t commTimer;
static uint32_t readTimeTimer;
// PRQA S 1514 --


//static uint16_t gDioStatus[DEVICE_MAX][DIO_STATUS_MAX];
//static uint8_t gRemote[DEVICE_MAX];
//static uint8_t gDoSetting[DEVICE_MAX][DOSETTING_MAX];

void // PRQA S 1505 1
LanguageSelect(E_FONT_SIZE size)
{
	if(SettingValue[SETUP_LANGUAGE] == CHINESE)
	{
//		(void)GUI_SetFont(&GUI_FontLSfont_24x24);
		if((size == FONT16) || (size == FONT16B))
		{
			(void)GUI_SetFont(&GUI_FontLSfont16_);
		}
		else
		if(size == FONT20)
		{
			(void)GUI_SetFont(&GUI_FontLSFont20n_);
		}
		else
		if(size == FONT20B)
		{
			(void)GUI_SetFont(&GUI_FontLSFont20b_);
		}
		else
		if((size == FONT24) || (size == FONT24B))
		{
			(void)GUI_SetFont(&GUI_FontLSfont24_);
		}
		else
		if((size == FONT32) || (size == FONT32B))
		{
			(void)GUI_SetFont(&GUI_FontLSfont24_);
		}
		else {}
	}
	else
	if(SettingValue[SETUP_LANGUAGE] == RUSSIAN)
	{
		if((size == FONT16) || (size == FONT16B))
		{
			(void)GUI_SetFont(&GUI_Fontcyrillic16_16x16);
		}
		else
		if((size == FONT20) || (size == FONT20B))
		{
			(void)GUI_SetFont(&GUI_Fontcyrillic20_20x20);
		}
		else
		if((size == FONT24) || (size == FONT24B))
		{
			(void)GUI_SetFont(&GUI_Fontcyrillic_24x24);
		}
		else
		if((size == FONT32) || (size == FONT32B))
		{
			(void)GUI_SetFont(&GUI_Fontcyrillic_24x24);
		}
		else {}
	}
	else
	{
		if(size == FONT16)
		{
			(void)GUI_SetFont(&GUI_Font16_ASCII);
		}
		else
		if(size == FONT16B)
		{
			(void)GUI_SetFont(&GUI_Font16B_ASCII);
		}
		else
		if(size == FONT20)
		{
			(void)GUI_SetFont(&GUI_Font20_ASCII);
		}
		else
		if(size == FONT20B)
		{
			(void)GUI_SetFont(&GUI_Font20B_ASCII);
		}
		else
		if(size == FONT24)
		{
			(void)GUI_SetFont(&GUI_Font24_ASCII);
		}
		else
		if(size == FONT24B)
		{
			(void)GUI_SetFont(&GUI_Font24B_ASCII);
		}
		else
		if(size == FONT32)
		{
			(void)GUI_SetFont(&GUI_Font32_ASCII);
		}
		else
		if(size == FONT32B)
		{
			(void)GUI_SetFont(&GUI_Font32B_ASCII);
		}
		else {}
	}
}

// PRQA S 1505 1
void BaseDisp(float value, char* mks, const char*baseUnit, char unit[UNIT_BUF_SIZE],  char result[DEFAULT_BUF_SIZE])
{
	(void)sprintf(unit, "%s%s", mks, baseUnit);
	(void)sprintf(result, "%5.1f", value);
}

// PRQA S 1505 1
void DispFormat(float value, const char* baseUnit, char unit[UNIT_BUF_SIZE], char result[DEFAULT_BUF_SIZE])
{
	float v = fabs(value);
	if(v < TENTHOUSAND)
	{
		BaseDisp(value, "", baseUnit, unit, result);
		return;
	}
	value = value / THOUSAND;
	v = (v / THOUSAND);
// PRQA S 3335 ++
// PRQA S 4604 ++
	if(round(v) < TENTHOUSAND)
// PRQA S 3335 --
// PRQA S 4604 --
	{
		BaseDisp(value, "k", baseUnit, unit, result);
		return;
	}
	value = value / THOUSAND;
	v = (v / THOUSAND);
	if(round(v) < TENTHOUSAND)
	{
		BaseDisp(value, "M", baseUnit, unit, result);
		return;
	}
	value = value / THOUSAND;
	v = (v / THOUSAND);
	if(round(v) < TENTHOUSAND)
	{
		BaseDisp(value, "G", baseUnit, unit, result);
		return;
	}
	value = value / THOUSAND;
	v = (v / THOUSAND);
	if(round(v) < TENTHOUSAND)
	{
		BaseDisp(value, "T", baseUnit, unit, result);
		return;
	}
	value = value / THOUSAND;
	v = (v / THOUSAND);
	if(round(v) < TENTHOUSAND)
	{
		BaseDisp(value, "P", baseUnit, unit, result);
		return;
	}
	(void)sprintf(unit,"");
	(void)sprintf(result,"ERROR");
}

// PRQA S 1505 1
void DispStatus(void)
{

	(void)GUI_SetPenSize(STATUS_PENSIZE_LINE);
	GUI_SetColor(COLOR_MENU_NORMAL);
	GUI_SetBkColor(COLOR_MENU_NORMAL);
	GUI_ClearRect(0, 0, X1_MAIN, Y0_MAIN);
	GUI_SetColor(STATUS_LINE_COLOR);
	for(int i = 0; i < INDEX_3; i++)
	{
		GUI_DrawVLine(_ichstatus_line_x[i], 0, Y0_MAIN);
	}
}

static void AcbMccbOverView(void)
{
	GUI_SetBkColor(COLOR_MAIN_BG);
	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	(void)GUI_SetFont(&GUI_Font16_ASCII);
	if(gCommStatus[gDeviceIndex] == COMM_OK)
	{
		GUI_SetColor(GUI_WHITE);
	}
	else
	{
		GUI_SetColor(COLOR_LINE);
	}

	GUI_RECT rect;
	rect.x0 = ACBMCCB_50PER_X0;
	rect.x1 = ACBMCCB_50PER_X1;
	rect.y0 = ACBMCCB_PER_Y0;
	rect.y1 = ACBMCCB_PER_Y1;
	GUI_DispStringInRect("50", &rect, (GUI_TA_HCENTER | GUI_TA_VCENTER));
	rect.x0 = ACBMCCB_100PER_X0;
	rect.x1 = ACBMCCB_100PER_X1;
	GUI_DispStringInRect("100", &rect, (GUI_TA_HCENTER | GUI_TA_VCENTER));
	rect.x0 = ACBMCCB_120PER_X0;
	rect.x1 = ACBMCCB_120PER_X1;
	GUI_DispStringInRect("120%", &rect, (GUI_TA_HCENTER | GUI_TA_VCENTER));

	GUI_SetColor(COLOR_LINE);
	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_DrawVLine(STATUS_X1, STATUS_Y0, STATUS_Y1);
	GUI_DrawVLine(ACBMCCB_BAR_X50, STATUS_Y0, STATUS_Y1);
	GUI_DrawVLine(ACBMCCB_BAR_X100, STATUS_Y0, STATUS_Y1);
	GUI_DrawVLine(ACBMCCB_BAR_X120, STATUS_Y0, STATUS_Y1);

	(void)GUI_SetFont(&GUI_Font32B_ASCII);
	GUI_SetColor(COLOR_LABEL);
	GUI_SetColor(COLOR_LABEL);
	rect.x0 = ACBMCCB_LABEL_X0;
	rect.y0 = ACBMCCB_LABEL_Y0;
	rect.x1 = ACBMCCB_LABEL_X1;
	rect.y1 = ACBMCCB_LABEL_Y1;

	for(int i = 0; i < PHASE_MAX; i++)
	{
		if(i == INDEX_3)
		{
			GUI_SetColor(COLOR_DISABLE);
		}
		GUI_DispStringInRect(_acPhase_Label[i],  &rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
		rect.y0 += ACBMCCB_LABEL_DISTANCE;
		rect.y1 += ACBMCCB_LABEL_DISTANCE;
	}

	(void)GUI_SetFont(&GUI_Font16B_1);
	int y0 = ACBMCCB_BAR_Y0;
	int y1 = ACBMCCB_BAR_Y1;
	for(int i = 0; i < PHASE_MAX; i++)
	{
		int x0 = ACBMCCB_BAR_X0;
		int x1 = ACBMCCB_BAR_X1;
		for(int j = 0; j < INDEX_12; j++)
		{
			GUI_FillRect(x0, y0, x1, y1);
			x0 += ACBMCCB_BAR_X_DISTANCE;
			x1 += ACBMCCB_BAR_X_DISTANCE;
			if((j == INDEX_4) || (j ==INDEX_9))
			{
				x0 += INDEX_3;
				x1 += INDEX_3;
			}
		}
		y0 += ACBMCCB_BAR_Y_DISTANCE;
		y1 += ACBMCCB_BAR_Y_DISTANCE;
	}
}

static void AcbMccbOverViewValue(int flag)
{
	static const GUI_COLOR _BarColor[PHASE_MAX+1] = {
		0x0000ff, 0x00deff, 0x2dbe31, 0x2dbe31, 0x3a3939
	};
	static float Ampare[DEVICE_MAX][PHASE_MAX];


	//(void)printf("AcbMccbOverViewValue(%d) gDeviceIndex=%d, gPols[gDeviceIndex]=%d, gLrValue[gDeviceIndex]=%f \n", flag, gDeviceIndex, gPols[gDeviceIndex], gLrValue[gDeviceIndex]);
	if((int)gLrValue[gDeviceIndex] == 0)
	{
		return;
	}
	char 				buf[PHASE_MAX][DEFAULT_BUF_SIZE];
	char 				unit[PHASE_MAX][UNIT_BUF_SIZE];
	uint16_t			barGraph[PHASE_MAX];
	uint16_t			barGraphPer[PHASE_MAX];

	if(flag)
	{
	  Ampare[gDeviceIndex][INDEX_0] =  ModbusGetFloat(I_REGISTER_215);
	  Ampare[gDeviceIndex][INDEX_1] =  ModbusGetFloat(I_REGISTER_217);
	  Ampare[gDeviceIndex][INDEX_2] =  ModbusGetFloat(I_REGISTER_219);
	  Ampare[gDeviceIndex][INDEX_3] =  ModbusGetFloat(I_REGISTER_221);
	  for(int i = 0; i < INDEX_4; i++)
	  {
	  	//(void)printf("Value %d => %f\n", i, Ampare[gDeviceIndex][i]);
	  }
	}

	for(int i = 0; i < gPols[gDeviceIndex]; i++)
	{
		double v;
		{
// PRQA S 3335 ++
// PRQA S 4604 ++
			v = round((double)Ampare[gDeviceIndex][i]*FLOAT_TEN);
// PRQA S 3335 --
// PRQA S 4604 --
			Ampare[gDeviceIndex][i] = (float)(v / FLOAT_TEN);
		}
		DispFormat(Ampare[gDeviceIndex][i], "A",unit[i],  buf[i]);

		float value = (Ampare[gDeviceIndex][i] * TEN);// / gLrValue[gDeviceIndex]);

		if(value < 0)
		{
			value = 0;
		}

		float compare = gLrValue[gDeviceIndex];
		if(i == INDEX_3)	// N상
		{
			if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
			{
				compare = gLrValue[gDeviceIndex] * (gLnrValue[gDeviceIndex] / HUNDRED);
			}
			else		// MCCB
			{
				if((uint16_t)gNPHASE_PROTECTION_Value[gDeviceIndex] == INDEX_3)
				{
					compare = gLrValue[gDeviceIndex] * MCCB_RATIO_0_5;
				}
				else
				if((uint16_t)gNPHASE_PROTECTION_Value[gDeviceIndex] == INDEX_4)
				{
					//(void)printf("OSN  lr=%f, ln=%f\n", gLrValue[gDeviceIndex], gLnValue[gDeviceIndex]);
					if(gLrValue[gDeviceIndex] < (MCCB_COMPARE_0_63 * gLnValue[gDeviceIndex]))
					{
						//(void)printf("Ir < 0.63In\n");
						compare = gLrValue[gDeviceIndex] * MCCB_RATIO_1_6;
					}
					else
					{
						compare = gLnValue[gDeviceIndex];
					}
				}
				else
				{
				}
			}
		}
		if((int)Ampare[gDeviceIndex][i] == 0)
		{
			barGraph[i] = 0;
		}
		else
//		if(value < gLrValue[gDeviceIndex])
		if(value < compare)
		{
			barGraph[i] = 1;
		}
		else
		{
//			barGraph[i] = (int)(value / gLrValue[gDeviceIndex]) + 1;
			barGraph[i] = (int)(value / compare) + 1;
		}
//		barGraphPer[i] = (uint16_t)((Ampare[gDeviceIndex][i] * HUNDRED) / gLrValue[gDeviceIndex]);
		if((i == INDEX_3) && ((uint16_t)gNPHASE_PROTECTION_Value[gDeviceIndex] == 1))		// MCCB 전부녹색
		{
			barGraphPer[i] = 0;
		}
// 2019/2/21 선박용은 통신되는 모델이 없음
//		else
//		if(gAcbType[gDeviceIndex] == MARINE)	// ACB 선박용
//		{
//			printf("MARINE: value=%f, PTA=%f\n", Ampare[gDeviceIndex][i], gPTAValue[gDeviceIndex]);
//			if(Ampare[gDeviceIndex][i] < gPTAValue[gDeviceIndex])
//			{
//				barGraphPer[i] = 0;		// 녹색
//			}
//			else
//			if(Ampare[gDeviceIndex][i] < compare)
//			{
//				barGraphPer[i] = PER90;		// 노랑색
//			}
//			else
//			{
//				barGraphPer[i] = PER105;		// 적색
//			}
//		}
		else
		{
			barGraphPer[i] = (uint16_t)((Ampare[gDeviceIndex][i] * HUNDRED) / compare);
		}
	}

	GUI_SetBkColor(COLOR_MAIN_BG);

	GUI_RECT rect;
	GUI_RECT rect2;
	GUI_SetColor(COLOR_LABEL);
	(void)GUI_SetFont(&GUI_Font32B_ASCII);
	rect.x0 = ACBMCCB_LABEL_X0;
	rect.y0 = ACBMCCB_LABEL_Y0;
	rect.x1 = ACBMCCB_LABEL_X1;
	rect.y1 = ACBMCCB_LABEL_Y1;

	for(int i = 0; i < PHASE_MAX; i++)
	{
		int pol = gPols[gDeviceIndex];
		if(pol < INDEX_3)
		{
			pol = INDEX_3;
		}
		if(i >= pol)
		{
			GUI_SetColor(COLOR_DISABLE);
		}
		GUI_DispStringInRect(_acPhase_Label[i],  &rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
		rect.y0 += ACBMCCB_LABEL_DISTANCE;
		rect.y1 += ACBMCCB_LABEL_DISTANCE;
	}

	GUI_SetColor(COLOR_VALUE);
	rect.x0 = ACBMCCB_VALUE_X0;
	rect.y0 = ACBMCCB_LABEL_Y0;
	rect.x1 = ACBMCCB_VALUE_X1;
	rect.y1 = ACBMCCB_LABEL_Y1;

	rect2.x0 = ACBMCCB_UNIT_X0;
	rect2.y0 = ACBMCCB_LABEL_Y0;
	rect2.x1 = ACBMCCB_UNIT_X1;
	rect2.y1 = ACBMCCB_LABEL_Y1;
	for(int i = 0; i < gPols[gDeviceIndex]; i++)
	{
		GUI_ClearRect(rect.x0, rect.y0, rect.x1, rect.y1);
		(void)GUI_SetFont(&GUI_Font32B_ASCII);
		GUI_DispStringInRect(buf[i], &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
		GUI_ClearRect(rect2.x0, rect2.y0, rect2.x1, rect2.y1);
		(void)GUI_SetFont(&GUI_Font20_ASCII);
		GUI_DispStringInRect(unit[i], &rect2, GUI_TA_LEFT | GUI_TA_BASELINE);
		rect.y0 += ACBMCCB_LABEL_DISTANCE;
		rect.y1 += ACBMCCB_LABEL_DISTANCE;
		rect2.y0 += ACBMCCB_LABEL_DISTANCE;
		rect2.y1 += ACBMCCB_LABEL_DISTANCE;
	}

	int y0 = ACBMCCB_BAR_Y0;
	int y1 = ACBMCCB_BAR_Y1;
	for(int i = 0; i < gPols[gDeviceIndex]; i++)
	{
		if(barGraphPer[i] >= PER105)
		{
			GUI_SetColor(_BarColor[INDEX_0]);
		}
		else
		if(barGraphPer[i] >= PER90)
		{
			GUI_SetColor(_BarColor[INDEX_1]);
		}
		else
		{
			GUI_SetColor(_BarColor[INDEX_2]);
		}
		int x0 = ACBMCCB_BAR_X0;
		int x1 = ACBMCCB_BAR_X1;
		for(int j = 0; j < INDEX_12; j++)
		{
			if(barGraph[i] <= j)
			{
				GUI_SetColor(_BarColor[PHASE_MAX]);
			}
			GUI_FillRect(x0, y0, x1, y1);
			x0 += ACBMCCB_BAR_X_DISTANCE;
			x1 += ACBMCCB_BAR_X_DISTANCE;
			if((j == INDEX_4) || (j == INDEX_9))
			{
				x0 += INDEX_3;
				x1 += INDEX_3;
			}
		}
		y0 += ACBMCCB_BAR_Y_DISTANCE;
		y1 += ACBMCCB_BAR_Y_DISTANCE;
	}
}

// PRQA S 1505 1
void OverViewValue(int flag)
{
	if((ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB) || (ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB))
	{
		AcbMccbOverViewValue(flag);
	}
	else
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MLINK)
	{
		MLinkOverviewValue(flag);
	}
	else {}
}

static void PageDisp(int page)
{
	int x = PAGE_X;
	int y = PAGE_Y;

	for(int i = 0; i < gDeviceCount; i++)
	{
		if( i == page)
		{
			GUI_SetColor(COLOR_VALUE);
		}
		else
		{
			GUI_SetColor(COLOR_LINE);
		}
		GUI_FillCircle(x, y, PAGE_RADIUS);
		y += PAGE_HEIGHT;
	}
}

static void CommStatusDisp(void)
{
	if(g_nStatusNoUpdate == 0)
	{
		if(gCommStatus[gDeviceIndex] != gCommOldStatus[gDeviceIndex])
		{
			if(gCommStatus[gDeviceIndex] == COMM_ERROR)
			{
				DispStatus();
			}
			(void)GUI_BMP_Draw(_acImage[gCommStatus[gDeviceIndex]], _acXyPos[0], _acXyPos[1]);
			gCommOldStatus[gDeviceIndex] = gCommStatus[gDeviceIndex];
		}
	}
}

// PRQA S 1505 1
void CommTimerClear(void)
{
	//(void)printf("CommTimerClear\n");
	g_bRecvAllDone = FALSE;
	commTimer = HAL_GetTick();
}

// PRQA S 1505 1
void CommTimerInit(void)
{
	//(void)printf("CommTimerInit\n");
	commTimer = 0;
}

static void Overview(bool newDisp)
{
	if(newDisp)
	{
		DispStatus();
	}
	if((ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB) || (ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB))
	{
		AcbMccbOverView();
	}
	else
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MLINK)
	{
		MLinkOverview();
	}
	else
	{
		GUI_SetBkColor(COLOR_MAIN_BG);
		GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	}
	PageDisp(gDeviceIndex);
	gCommOldStatus[gDeviceIndex] = -1;
}

// PRQA S 1505 1
uint16_t StatusSend(void)
{
	if(gStatusSendEnd == STATUS_SEND_ING)
	{
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MLINK)
		{
			if(statusSendStep == INDEX_0)
			{
				CommTimerClear();
				ModbusSendFrameReadTime(ConnectSetting[gDeviceIndex].Address);	// ReadTime
			}
			else
			if(statusSendStep == INDEX_1)
			{
				ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, I_REGISTER_1335, INDEX_16);		// Product Name
			}
			else
			if(statusSendStep == INDEX_2)
			{
				ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, HOLDING_REGISTER, H_REGISTER_2501, INDEX_16);	// Device Description
			}
			else
			if(statusSendStep == INDEX_3)
			{
				ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, I_REGISTER_1004, INDEX_1);		// Event Max
			}
			else
			if(statusSendStep == INDEX_4)
			{
				ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, I_REGISTER_201, INDEX_17);		// Event Count, 시간동기+Local/Remote, DiDo Status, SBO
			}
			else {}
		}
		else
		if((ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB) || (ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB))
		{
			if(statusSendStep == INDEX_0)
			{
				CommTimerClear();
				ModbusSendFrameReadTime(ConnectSetting[gDeviceIndex].Address);	// ReadTime
			}
			else
			if(statusSendStep == INDEX_1)
			{
				ModbusSendFrameDeviceIdentofocation3(ConnectSetting[gDeviceIndex].Address, INDEX_2, INDEX_3);
			}
			else
			if(statusSendStep == INDEX_2)
			{
				uint16_t len = MCCB_STATUS_STEP2_LEN;
				if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
				{
					len = ACB_STATUS_STEP2_LEN;
				}
				ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, HOLDING_REGISTER, INDEX_1, len);	// Device Description,poles,group control
			}
			else
			if(statusSendStep == INDEX_3)
			{
				ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, HOLDING_REGISTER, H_REGISTER_467, INDEX_2);		// Event Max
			}
			else
			if(statusSendStep == INDEX_4)
			{
				ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, I_REGISTER_194, INDEX_15);		// Event Count, 시간동기
			}
			else
			{
				statusSendStep = 0;
			}
		}
		else {}
	}
	return gStatusSendEnd;
}

// PRQA S 1505 1
uint16_t StatusRecvErrorProcess(void)
{
	if(gStatusSendEnd == STATUS_SEND_ING)
	{
		if(gDebug == true)
			(void)printf("StatusRecvErrorProcess()  statusSendStep = %d\n", statusSendStep);
		int nMaxStep;
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MLINK)
		{
			nMaxStep = INDEX_4;
		}
		else
		{
			nMaxStep = INDEX_4;
		}
		if(statusSendStep < nMaxStep)
		{
			statusSendStep++;
			(void)StatusSend();
		}
		else
		{
			statusSendStep = 0;
			gStatusSendEnd = STATUS_SEND_END;
		}
	}
	return gStatusSendEnd;
}

// PRQA S 1505 1
void StatusRecv(void)
{
	static uint16_t gEventMax[DEVICE_MAX];
	static uint16_t gFaultMax[DEVICE_MAX];

	char buf[MESSAGE_BUF_SIZE];
	GUI_SetBkColor(COLOR_MENU_NORMAL);
	(void)GUI_SetFont(&GUI_Font16B_ASCII);
	if(gDebug == true)
		(void)printf("StatusRecv(statusSendStep=%d)\n", statusSendStep);

	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MLINK)
	{
		if(statusSendStep > INDEX_4)
		{
			statusSendStep = 0;
			return;
		}
		if(statusSendStep == INDEX_0)
		{
			GUI_SetColor(STATUS_LINE_COLOR);
			GUI_SetColor(GUI_WHITE);

			S_DATE_TIME dateTime;
			ModbusGetDateTime(&dateTime);
			(void)sprintf(buf, "'%02d-%02d-%02d %02d:%02d:%02d", dateTime.Year-YEAR_BASE,
			dateTime.Month,
			dateTime.Day,
			dateTime.Hour,
			dateTime.Min,
			dateTime.Sec);
			GUI_ClearRectEx(&rectDate);
			GUI_DispStringInRect(buf, &rectDate, GUI_TA_HCENTER | GUI_TA_VCENTER);
			statusSendStep = 1;
		}
		else
		if(statusSendStep == INDEX_1)
		{
			ModbusGetString(I_REGISTER_1335, INDEX_32, gProductName[gDeviceIndex]);
			//(void)printf("gProductName = %s\n", gProductName[gDeviceIndex]);
			statusSendStep = INDEX_2;
		}
		else
		if(statusSendStep == INDEX_2)
		{
			GUI_SetColor(GUI_WHITE);
			ModbusGetString(H_REGISTER_2501, INDEX_32, buf);

			//(void)printf("device description = %s\n", buf);
			if(strlen(buf) > INDEX_20)
			{
			   buf[INDEX_20] = '.';
			   buf[INDEX_21] = '.';
			   buf[INDEX_22] = '.';
			   buf[INDEX_23] = 0;
			}
			if(buf[0] != 0)
			{
				(void)strcpy(gDescription[gDeviceIndex], buf);
			}
			else
			{
				(void)sprintf(buf, "%s #%d", gProductName[gDeviceIndex], ConnectSetting[gDeviceIndex].Address);
			}
			GUI_ClearRectEx(&rectDesc);
			GUI_DispStringInRect(buf, &rectDesc, GUI_TA_HCENTER | GUI_TA_VCENTER);
			statusSendStep = INDEX_3;
		}
		else
		if(statusSendStep == INDEX_3)
		{
			gEventMax[gDeviceIndex] = ModbusGetUint16(I_REGISTER_1004);
			statusSendStep = INDEX_4;
		}
		else
		if(statusSendStep == INDEX_4)
		{
			GUI_SetColor(GUI_WHITE);
			mLinkMode[gDeviceIndex] = ModbusGetUint16(I_REGISTER_216) & MLINK_MODE_MASK;
			mLinkSBO[gDeviceIndex] = ModbusGetUint16(I_REGISTER_217);
			int pos = 0;
			if((mLinkMode[gDeviceIndex] >= INDEX_1) && (mLinkMode[gDeviceIndex] <= INDEX_3))
			{
				pos = INDEX_1;
			}
			GUI_ClearRectEx(&rectLocal);
			LanguageSelect(FONT16B);
			GUI_DispStringInRect(_aclocal_remote[SettingValue[SETUP_LANGUAGE]][pos], &rectLocal, GUI_TA_HCENTER | GUI_TA_VCENTER);
			(void)sprintf(buf, "M%d", mLinkMode[gDeviceIndex]);
			GUI_ClearRectEx(&rectMode);
			(void)GUI_SetFont(&GUI_Font16B_ASCII);
			GUI_DispStringInRect(buf, &rectMode, GUI_TA_HCENTER | GUI_TA_VCENTER);

			GUI_SetColor(GUI_WHITE);
			uint16_t rolloverCount = ModbusGetUint16(I_REGISTER_201);
			uint16_t SystemEventRolloverCount = (rolloverCount >> INDEX_8) & ROLLOVER_COUNT_MASK;
			gSystemEventIndex[gDeviceIndex] = ModbusGetUint16(I_REGISTER_202);
			//(void)printf("\n\n\nEvent\n (%d,%d)\n\n\n", SystemEventRolloverCount, gSystemEventIndex[gDeviceIndex]);
			if(SystemEventRolloverCount)
			{
				gSystemEventTotalCount[gDeviceIndex] = gEventMax[gDeviceIndex];
			}
			else
			{
				gSystemEventTotalCount[gDeviceIndex] = gSystemEventIndex[gDeviceIndex];
			}

			for(uint16_t i = 0; i < MLINK_DO_MAX; i++)
			{
				doStatus[gDeviceIndex][i] = ModbusGetBit(I_REGISTER_210, i);
			}
			for(uint16_t i = 0; i < MLINK_DI_MAX; i++)
			{
				diStatus[gDeviceIndex][i] = ModbusGetBit(I_REGISTER_209, i);
			}

			if(ModbusGetUint16(I_REGISTER_208) & TIME_SYNC_MASK)
			{
				(void)printf("M-LINK Time Invalid................\n\n\n\n");
				PCF2127_readTime(1);
				ModbusSetTimeAndWait(ConnectSetting[gDeviceIndex].Address, &gDateTime);
			}

			statusSendStep = 0;
			gStatusSendEnd = STATUS_SEND_END;
		}
		else {}
	}
	else
	{
		if(statusSendStep > INDEX_4)
		{
			statusSendStep = 0;
			return;
		}
		GUI_SetColor(GUI_WHITE);
		if(statusSendStep == 0)
		{
			GUI_SetColor(STATUS_LINE_COLOR);
			GUI_SetColor(GUI_WHITE);

			S_DATE_TIME dateTime;
			ModbusGetDateTime(&dateTime);
			(void)sprintf(buf, "'%02d-%02d-%02d %02d:%02d:%02d", dateTime.Year-YEAR_BASE,
			dateTime.Month,
			dateTime.Day,
			dateTime.Hour,
			dateTime.Min,
			dateTime.Sec);

			GUI_ClearRectEx(&rectDate);
			GUI_DispStringInRect(buf, &rectDate, GUI_TA_HCENTER | GUI_TA_VCENTER);
			statusSendStep = 1;
		}
		else
		if(statusSendStep == INDEX_1)
		{
			ModbusGetId2(gProductName[gDeviceIndex]);

			//(void)printf("gProductName = %s\n", gProductName[gDeviceIndex]);
			statusSendStep = INDEX_2;
		}
		else
		if(statusSendStep == INDEX_2)
		{
			GUI_SetColor(GUI_WHITE);
			ModbusGetString(H_REGISTER_1, INDEX_32, buf);

			if(strlen(buf) > INDEX_20)
			{
			   buf[INDEX_20] = '.';
			   buf[INDEX_21] = '.';
			   buf[INDEX_22] = '.';
			   buf[INDEX_23] = 0;
			}

			if(buf[0] != 0)
			{
				(void)strcpy(gDescription[gDeviceIndex], buf);
			}
			else
			{
				(void)sprintf(buf, "%s #%d", gProductName[gDeviceIndex], ConnectSetting[gDeviceIndex].Address);
			}

			GUI_ClearRectEx(&rectDesc);
			GUI_DispStringInRect(buf, &rectDesc, GUI_TA_HCENTER | GUI_TA_VCENTER);
			uint16_t pols;
			if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
			{
				uint8_t acbDeviceType = ModbusGetUint8_U(H_REGISTER_18);
				if((acbDeviceType == INDEX_0) || (acbDeviceType == INDEX_1))    // 0: S Type, 1: P Type, 2: A Type, 3: N Type
				{
					gDeviceTypeAll[gDeviceIndex] = TRUE;
				}
				else
				{
					gDeviceTypeAll[gDeviceIndex] = FALSE;
				}
				//(void)printf("acb device type = %d, gDeviceTypeAll = %d\n", acbDeviceType, gDeviceTypeAll[gDeviceIndex]);
						//						gLrValue[gDeviceIndex] = ModbusGetUint16(H_REGISTER_24);
				pols = (ModbusGetUint16(H_REGISTER_19) >> INDEX_8) & POLL_MASK;
				//(void)printf("ACB pols=%d\n", pols);
				if(pols != P4)
				{
					pols = P3;
				}
				if(pols != gPols[gDeviceIndex])
				{
					gPols[gDeviceIndex] = pols;
				}
				uint16_t group = ModbusGetUint16(H_REGISTER_50);
				//(void)printf("ACB group=%d\n", group);
				if(group == 1)		//Group B
				{
					gGroupOffset[gDeviceIndex] = ACB_RELAYSET_GROUPOFFSET;
				}
				else
				{
					gGroupOffset[gDeviceIndex] = 0;
				}
			}
			else
			if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
			{
				uint8_t mccbDeviceType = ModbusGetUint8_U(H_REGISTER_18);
				if((mccbDeviceType == INDEX_2) || (mccbDeviceType == INDEX_3))    // 0: 기본형(S-default), 1: 고급형(M), 2: 최고급형(H), 3: 최고급형+visibility(L)
				{
					gDeviceTypeAll[gDeviceIndex] = TRUE;
				}
				else
				{
					gDeviceTypeAll[gDeviceIndex] = FALSE;
				}
				//(void)printf("mccb device type = %d, gDeviceTypeAll = %d\n", mccbDeviceType, gDeviceTypeAll[gDeviceIndex]);
				gAmpareFrame[gDeviceIndex] = ModbusGetUint16(H_REGISTER_20);
				pols = ModbusGetUint16(H_REGISTER_19) & POLL_MASK;
				//(void)printf("MCCB pols=%d, gPols[gDeviceIndex]=%d\n", pols, gPols[gDeviceIndex]);
				if(pols != P4)
				{
					pols = P3;
				}
				if(pols != gPols[gDeviceIndex])
				{
					gPols[gDeviceIndex] = pols;
				}
				gLnValue[gDeviceIndex] = ModbusGetUint16(H_REGISTER_21);		//Rating Plug
				gGroupOffset[gDeviceIndex] = 0;
			}
			else
			{
			}
			statusSendStep = INDEX_3;
		}
		else
		if(statusSendStep == INDEX_3)
		{
			gEventMax[gDeviceIndex] = ModbusGetUint16(H_REGISTER_467);
			gFaultMax[gDeviceIndex] = ModbusGetUint16(H_REGISTER_468);
			//(void)printf("Event Max: %d, Fault Max:%d\n", gEventMax[gDeviceIndex], gFaultMax[gDeviceIndex]);
			statusSendStep = INDEX_4;
		}
		else
		if(statusSendStep == INDEX_4)
		{
			GUI_SetColor(GUI_WHITE);
			uint16_t rolloverCount = ModbusGetUint16(I_REGISTER_194);
			//(void)printf("rolloverCount = 0x%x\n", rolloverCount);
			uint16_t SystemEventRolloverCount = (rolloverCount >> INDEX_8) & ROLLOVER_COUNT_MASK;
			uint16_t FaultEventRolloverCount = rolloverCount & ROLLOVER_COUNT_MASK;
			gSystemEventIndex[gDeviceIndex] = ModbusGetUint16(I_REGISTER_195);
			uint16_t faultCount = ModbusGetUint16(I_REGISTER_196);

			if((faultCount == 0))
			{
				int flag = FALSE;
				if(gFaultEventIndex[gDeviceIndex] != 0)
				{
					flag = TRUE;
				}
				gOldFaultEventIndex[gDeviceIndex] = 0;
				if(flag == TRUE)
				{
					FaultCountWrite();
				}
			}
			gFaultEventIndex[gDeviceIndex] = faultCount;
			//(void)printf("\n\n\nEvent\n (%d,%d) (%d,%d)\n\n\n", SystemEventRolloverCount, FaultEventRolloverCount, gSystemEventIndex[gDeviceIndex], gFaultEventIndex[gDeviceIndex]);
			if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
			{
				if(SystemEventRolloverCount)
				{
					gSystemEventTotalCount[gDeviceIndex] = gEventMax[gDeviceIndex];
				}
				else
				{
					gSystemEventTotalCount[gDeviceIndex] = gSystemEventIndex[gDeviceIndex];
				}
				if(FaultEventRolloverCount)
				{
					gFaultEventTotalCount[gDeviceIndex] = gFaultMax[gDeviceIndex];
				}
				else
				{
					gFaultEventTotalCount[gDeviceIndex] = gFaultEventIndex[gDeviceIndex];
				}
			}
			else
			if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
			{
				if(SystemEventRolloverCount)
				{
					gSystemEventTotalCount[gDeviceIndex] = gEventMax[gDeviceIndex];
				}
				else
				{
					gSystemEventTotalCount[gDeviceIndex] = gSystemEventIndex[gDeviceIndex];
				}
				if(FaultEventRolloverCount)
				{
					gFaultEventTotalCount[gDeviceIndex] = gFaultMax[gDeviceIndex];
				}
				else
				{
					gFaultEventTotalCount[gDeviceIndex] = gFaultEventIndex[gDeviceIndex];
				}
			}
			else {}
	   		GUI_ClearRectEx(&rectLocal);

			if(gFaultEventIndex[gDeviceIndex] == gOldFaultEventIndex[gDeviceIndex])
			{
				GUI_SetColor(STATUS_LINE_COLOR);
			}
			LanguageSelect(FONT16B);
			GUI_DispStringInRect(_acalarm_text[SettingValue[SETUP_LANGUAGE]], &rectLocal, GUI_TA_HCENTER | GUI_TA_VCENTER);

			uint16_t value;
			if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
			{
				value = ModbusGetUint16(I_REGISTER_205); // 1:선박용, 2:일반용(Default), 3:Hynix용, 4:SK용
				gAcbType[gDeviceIndex] = (E_ACB_TYPE)(value & ACB_TYPE_MASK);
			}

			value = ModbusGetUint16(I_REGISTER_208);
			uint8_t cbStatus;
			if(value & CB_USE_UNUSE_MASK)			// 차단기 모드 사용/사용안함
			{
				cbStatus = (value >> INDEX_8) & CB_STATUS_MASK;
			}
			else
			{
				cbStatus = CB_NOTUSED;
			}

			GUI_COLOR cbStatusColor = GUI_WHITE;
			if(cbStatus == INDEX_2)				// Trip
			{
				cbStatusColor = GUI_RED;
			}

			GUI_SetColor(cbStatusColor);
			GUI_ClearRectEx(&rectMode);		// CB Status
			LanguageSelect(FONT16B);
			GUI_DispStringInRect(_accb_status[SettingValue[SETUP_LANGUAGE]][cbStatus], &rectMode, GUI_TA_HCENTER | GUI_TA_VCENTER);
			statusSendStep = INDEX_2;

			gLrValue[gDeviceIndex] = ModbusGetUint16(I_REGISTER_203);
			//(void)printf("ACB/MCCB lr=%f, groupoffset=%d\n", gLrValue[gDeviceIndex], gGroupOffset[gDeviceIndex]);

			value = ModbusGetUint16(I_REGISTER_206);
			if(value & TIME_SYNC_MASK)
			{
				(void)printf("ACB/MCCB Time Invalid................\n\n\n\n");
				PCF2127_readTime(1);
				ModbusSetTimeAndWait(ConnectSetting[gDeviceIndex].Address, &gDateTime);
			}

			statusSendStep = 0;
			gStatusSendEnd = STATUS_SEND_END;
		}
		else {}
	}
}

// PRQA S 1505 1
void OverviewSend(void)
{
	if(StatusSend() == STATUS_SEND_ING)
	{
		return;
	}
	//(void)printf("\n\n\nOverviewSend() nSendStep=%d\n", nSendStep);
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
	{
		if(nSendStep == 0)
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, HOLDING_REGISTER, H_REGISTER_119+gGroupOffset[gDeviceIndex], INDEX_6);
		}
		else
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, I_REGISTER_215, INDEX_8);
		}
	}
	else
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
	{
		if(nSendStep == 0)
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, HOLDING_REGISTER, H_REGISTER_104, INDEX_1);
		}
		else
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, I_REGISTER_215, INDEX_8);
		}
	}
	else
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MLINK)
	{
		if(nSendStep == 0)
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, I_REGISTER_219, INDEX_2);		// AI
		}
		else
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, HOLDING_REGISTER, H_REGISTER_2031, INDEX_6);		// DI 접점설정 ~2036
		}
	}
	else {}
}
static uint16_t gbSavingMode;

static void ScreenTimerInit(void)
{
	uint32_t timer = HAL_GetTick();
	gSavingModeCounter = timer + (SettingValue[SETUP_SAVING_MODE] * THOUSAND);
	gScreenSwitchingCounter = timer + (SettingValue[SETUP_SCREEN_SWITCHING] * THOUSAND);
	gReturnToScreen = timer + (SettingValue[SETUP_RETURN_TO_SCREEN] * THOUSAND);
}

uint32_t last_recv;

// PRQA S 1503 1
void GuiMain(void)
{
	static float gPTAValue[DEVICE_MAX];

	gbSBO = 0;

	last_recv = HAL_GetTick();
	commTimer = HAL_GetTick();
	readTimeTimer = HAL_GetTick();
	g_bRecvAllDone = FALSE;
	for(int i = 0; i < KEY_MAX; i++)
	{
		KeyStatus[i] = GPIO_PIN_SET;
	}
	for(int d = 0; d < DEVICE_MAX; d++)
	{
		for(uint16_t i = 0; i < MLINK_DO_MAX; i++)
		{
			doStatus[d][i] = 0;
		}
		for(uint16_t i = 0; i < MLINK_DI_MAX; i++)
		{
			diStatus[d][i] = 0;
		}
		gCommOldStatus[d] = -1;
	}

	_acImage[COMM_ERROR] = (const uint8_t *)_acImageStatusDisconnected;
	_acImage[COMM_OK] = (const uint8_t *)_acImageStatusConnected;

	g_nStatusNoUpdate = 0;
	nSendStep = 0;
	Overview(true);
	OverviewSend();

	gbInMainMenu = TRUE;
	gbSavingMode = FALSE;

	PCF2127_readTime(1);
	gTimeSyncDay = gDateTime.Day;
	gbSettingTime = FALSE;

	ScreenTimerInit();

	sendFlag = 0;
	gbSlaveSend = false;

	HAL_UART_Receive_DMA(&huart1, uart1_dma_rx_buff, UART1_DMA_RX_BUFF_SIZE);
	HAL_UART_Receive_DMA(&huart2, uart2_dma_rx_buff, UART2_DMA_RX_BUFF_SIZE);

	uart1LastNDTR = huart1.hdmarx->Instance->NDTR;
	uart2LastNDTR = huart2.hdmarx->Instance->NDTR;

	int curCommStat = gCommStatus[gDeviceIndex];

	while (1)
    {

		E_KEY key = GetKey();

		if(curCommStat != gCommStatus[gDeviceIndex])
		{
			//if(gCommStatus[gDeviceIndex] == COMM_ERROR)
			{
				Overview(false);
			}
			curCommStat = gCommStatus[gDeviceIndex];
		}
		if(key == TIME_OUT)
		{
			statusSendStep = 0;
			gStatusSendEnd = STATUS_SEND_ING;
			OverviewSend();
		}
		else
		if(key == KEY_SETUP)
		{
			gbInMainMenu = FALSE;
			(void)Setup();
			gbInMainMenu = TRUE;
			nSendStep = 0;
			OverviewSend();
			Overview(true);
//			OverViewValue(0);
		}
		else
		if(key == KEY_UP)
		{
			if(gDeviceIndex > 0)
			{
				gDeviceIndex--;
			}
			else
			{
				gDeviceIndex = gDeviceCount - 1;
			}
			gStatusSendEnd = STATUS_SEND_ING;
			statusSendStep = 0;
			nSendStep = 0;
			OverviewSend();
			Overview(true);
			curCommStat = gCommStatus[gDeviceIndex];
//			OverViewValue(0);
		}
		else
		if(key == KEY_DOWN)
		{
			if(gDeviceIndex < (gDeviceCount-1))
			{
				gDeviceIndex++;
			}
			else
			{
				gDeviceIndex = 0;
			}
			gStatusSendEnd = STATUS_SEND_ING;
			statusSendStep = 0;
			nSendStep = 0;
			OverviewSend();
			Overview(true);
			curCommStat = gCommStatus[gDeviceIndex];
//			OverViewValue(0);
		}
		else
		if(key == KEY_ENTER)
		{
			if(ConnectSetting[gDeviceIndex].DeviceType != DEVICE_NO)
			{
				gbInMainMenu = FALSE;
				WM_HWIN hWin = CreateMenu(ConnectSetting[gDeviceIndex].DeviceType);
				WM_ShowWindow(hWin);
				WM_DeleteWindow(hWin);
				gbInMainMenu = TRUE;

				OverviewSend();
				Overview(false);
				CommTimerInit();
//				OverViewValue(0);
			}
		}
		else
		if(key == DATA_RECV)
		{
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				StatusRecv();
				nSendStep = 0;
				OverviewSend();
			}
			else
			{
				if(nSendStep == 0)
				{
					if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MLINK)
					{
						OverViewValue(1);
					}
					else
					{
						if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
						{
							gLnrValue[gDeviceIndex] = ModbusGetUint16(H_REGISTER_119+gGroupOffset[gDeviceIndex]);
							//(void)printf("ACB ln=%f, groupoffset=%d\n", gLnrValue[gDeviceIndex], gGroupOffset[gDeviceIndex]);
							gPTAValue[gDeviceIndex] = ModbusGetUint16(H_REGISTER_124);
							//(void)printf("ACB PTA=%f\n", gPTAValue[gDeviceIndex]);
						}
						else
						{
							gNPHASE_PROTECTION_Value[gDeviceIndex] = ModbusGetUint16(H_REGISTER_104);
							//(void)printf("MCCB gNPHASE_PROTECTION_Value=%f\n", gNPHASE_PROTECTION_Value[gDeviceIndex]);
						}
					}
					nSendStep = 1;
					OverviewSend();
				}
				else
				if(nSendStep == 1)
				{
					OverViewValue(1);
					nSendStep = 0;
					g_bRecvAllDone = TRUE;
					//(void)printf("g_bRecvAllDone=0\n");
				}
				else {}
			}
		}
		else
		if(key == KEY_COMM_ERROR)
		{
			//(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(gStatusSendEnd == STATUS_SEND_END)
			{
				nSendStep++;
			}
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				int nStepMax;
				if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MLINK)
				{
					nStepMax = INDEX_2;
				}
				else
				{
					nStepMax = INDEX_2;
				}

				if(nSendStep < nStepMax)
				{
					OverviewSend();
				}
				else
				{
					g_bRecvAllDone = TRUE;

					//(void)printf("All done!!!\n");
					gStatusSendEnd = STATUS_SEND_ING;
					statusSendStep = 0;
					nSendStep = 0;
//					StatusRecvErrorProcess();
				}
			}
		}
		else {}
		OS_Delay(1);
	}
}

static uint32_t GetTimerDiff(void)
{
	if(SettingValue[SETUP_GATEWAY_USE] == 1)	// Gateway 사용할 경우
	{
		return (TIMER_DIFF_10SEC);		// 10초
	}
	else
	{
		return TIMER_DIFF;				// 1초
	}
}

__STATIC_INLINE void Pol_Delay_us(volatile uint32_t microseconds)
{
	/* Go to number of cycles for system */
	microseconds *= (SystemCoreClock / 1000000);   /* Delay till end */
	while (microseconds--);
}

uint32_t inControlTick = 0;
bool bInControl = false;

static uint8_t MasterModbusCRCCheck(bool bInChecking)
{
	if(g_modbusRxIndex < 5 || g_modbusRxIndex > MODBUS_BUFF_SIZE)
		return MODBUS_CRC_ERROR;
	if(gDebug)
	{
		(void)printf("Master Recv Frame!!!(%d, g_sendOwner = %d)\n", HAL_GetTick(), g_sendOwner);
		for(int i = 0; i < g_modbusRxIndex; i++)
		{
			(void)printf("%02X ", g_modbusRxBuff[i]);
		}
		(void)printf("\n");
	}
	bool exception = false;
	if(g_modbusRxBuff[1] & MASK_80)
	{
		exception = true;
		if(gDebug == true)
			(void)printf("-----------------\nModbus Exception Error[%02x]\n", g_modbusRxBuff[INDEX_2]);
	}

	uint8_t ret = MODBUS_OK;
	uint16_t p, crc;
	if(exception == true)
	{
		p = (uint16_t)(g_modbusRxBuff[INDEX_3] << INDEX_8) | (uint16_t)g_modbusRxBuff[INDEX_4];
		crc = CRC16(g_modbusRxBuff, INDEX_3);
	}
	else
	{
		p = (uint16_t)(g_modbusRxBuff[g_modbusRxIndex-INDEX_2] << INDEX_8) | (uint16_t)g_modbusRxBuff[g_modbusRxIndex-1];
		crc = CRC16(g_modbusRxBuff, g_modbusRxIndex-INDEX_2);
	}
	if(crc == p)
	{
		if(g_sendOwner == OWNER_SLAVE)
		{
			SlaveSendLength = g_modbusRxIndex;
			memcpy(SlaveTxBuffer, g_modbusRxBuff, SlaveSendLength);
		}
		if(g_modbusRxBuff[INDEX_1] == FORCE_SINGLE_COIL)
		{
			if(bInControl == false)
			{
				bInControl = true;
				last_recv = inControlTick = HAL_GetTick();
				if(gDebug)
					printf("In Control Start......\n");
			}
			else
			{
				bInControl = false;
				if(gDebug)
					printf("In Control End......\n");
			}
		}
	}
	else
	{
		if(gDebug == true)
			(void)printf("-----------------\nModbus CRC Error[%04x, %04x]\n", crc, p);
		ret = MODBUS_CRC_ERROR;
		bInControl = false;
	}
	if(bInControl == false)
	{
		if(g_sendOwner == OWNER_SLAVE)
		{
			if(gbSavingMode == FALSE)
				g_sendOwner = OWNER_MASTER;
		}
		else
		if(bInChecking == false && g_sendOwner == OWNER_MASTER)
		{
			if(MasterSendLength[OWNER_SLAVE] != 0)
				g_sendOwner = OWNER_SLAVE;
		}
	}
	g_modbusRxIndex = 0;
	GUI_Delay(10);
	return ret;
}

E_MODBUS_ERROR nMasterStatus;
void MasterModbusProcess(bool bInChecking)
{
	nMasterStatus = MODBUS_NONE;
	if(sendFlag == 1)
	{
		uint32_t uart2NewNDTR = huart2.hdmarx->Instance->NDTR;
		HAL_StatusTypeDef stat;
		int nTimeOut = MODBUS_TIMEOUT;
		bool bRecvOk = false;
		uint32_t count;


		if(uart2LastNDTR != uart2NewNDTR)
		{
			last_recv = HAL_GetTick();
			uint16_t readExceptionLen = NORMAL_EXCEPTION_LEN;
			if(g_functionCode == MODBUS_EXTEND_FUNCTION)
			{
			//					readExceptionLen = EXTEND_EXCEPTION_LEN;
			  readExceptionLen = NORMAL_EXCEPTION_LEN;
			}
			uint32_t pos = UART2_DMA_RX_BUFF_SIZE - uart2LastNDTR;
			if(uart2LastNDTR > uart2NewNDTR)
			{
				count = (uart2LastNDTR - uart2NewNDTR);
				memcpy(&g_modbusRxBuff[g_modbusRxIndex], &uart2_dma_rx_buff[pos], count);
				g_modbusRxIndex += count;
		  	}
			else
			{
				count = (UART2_DMA_RX_BUFF_SIZE - uart2NewNDTR) + uart2LastNDTR;
				memcpy(&g_modbusRxBuff[g_modbusRxIndex], &uart2_dma_rx_buff[pos], uart2LastNDTR);
				g_modbusRxIndex += uart2LastNDTR;
				uint32_t remainder = UART2_DMA_RX_BUFF_SIZE- uart2NewNDTR;
				memcpy(&g_modbusRxBuff[g_modbusRxIndex], &uart2_dma_rx_buff[0], remainder);
				g_modbusRxIndex += remainder;
			}
			if(gDebug == true)
				printf("recv:%u, last=%u, new=%u, cnt=%u\n",  last_recv, uart2LastNDTR, uart2NewNDTR, count);
			uart2LastNDTR = uart2NewNDTR;

			if(gDebug == true)
			{
				(void)printf("Read!!!(%u, %u) g_bRecvVariable:%d, readExceptionLen:%d\n", g_sendOwner, g_modbusRxIndex, g_bRecvVariable, readExceptionLen);
				for(int i = 0; i < g_modbusRxIndex; i++)
				{
					  (void)printf("%02X ", g_modbusRxBuff[i]);
				}
				(void)printf("\n");
			}

			if(g_modbusRxIndex < readExceptionLen)
				return;
			uint8_t modbusAddress;
			uint8_t functionCode;
			uint16_t wModbusWaitLen;
			if(g_sendOwner == OWNER_SLAVE)
			{
				modbusAddress		= g_modbusSlaveAddress;
				functionCode		= g_SlavefunctionCode;
				wModbusWaitLen 		= g_wModbusSlaveWaitLen;
				g_bRecvVariable		= g_bSlaveRecvVariable;
			}
			else
			{
				modbusAddress		= g_modbusAddress;
				functionCode		= g_functionCode;
				wModbusWaitLen 		= g_wModbusWaitLen;
				g_bRecvVariable		= g_bMasterRecvVariable;
			}
			//printf("(%u)cnt=%u[%02X%02X}\n", last_recv, count, modbusAddress, functionCode);
//printf("{%u}", last_recv);

			if((((g_modbusRxBuff[1] & INDEX_0x80) == INDEX_0x80) || (g_modbusRxBuff[0] != modbusAddress)) || (functionCode != g_modbusRxBuff[1]))
			{

				if(gDebug == true)
				{
					(void)printf("Exception Frame Read!!!(%d)\n", g_sendOwner);
					for(int i = 0; i < readExceptionLen; i++)
					{
						  (void)printf("%02X ", g_modbusRxBuff[i]);
					}
					(void)printf("\n");
				}
				if(g_sendOwner == OWNER_MASTER)
				{
					if(++gCommErrorCount[gDeviceIndex] >= COMM_ERROR_COUNT)
					{
					  gCommStatus[gDeviceIndex] = COMM_ERROR;
					  gCommErrorCount[gDeviceIndex] = 0;
					}
					g_modbusRxError = 1;
				}
				else
				{
					SlaveSendLength = g_modbusRxIndex;
					memcpy(SlaveTxBuffer, g_modbusRxBuff, SlaveSendLength);
				}
				if(g_modbusRxBuff[1] & INDEX_0x80)
				{
					if(gDebug == true)
						(void)printf("Header Exception Error!!!!(modbusAddress:%02X,functionCode:%02X\n",modbusAddress, functionCode);
				}
				else
				{
					if(gDebug == true)
					  (void)printf("Header Comm Error!!!!(modbusAddress:%02X,functionCode:%02X\n",modbusAddress, functionCode);
				}
				if(g_sendOwner == OWNER_MASTER)
				{
					g_modbusRxError = 1;
					if(bInChecking == false)
					{
						if(MasterSendLength[OWNER_SLAVE] != 0)
							g_sendOwner = OWNER_SLAVE;
					}
				}
				else
				{
					if(gbSavingMode == FALSE)
						g_sendOwner = OWNER_MASTER;
				}
				bInControl = false;
				sendFlag = 0;
				g_modbusRxIndex = 0;
				return;
			}
//			printf("g_bRecvVariable=%d, g_modbusRxIndex=%d, wModbusWaitLen=%d\n", g_bRecvVariable, g_modbusRxIndex, wModbusWaitLen);
			if(g_modbusRxIndex >= wModbusWaitLen)
			{
				uint16_t pos = 8;
				if(g_bRecvVariable == FALSE)
				{
					if(g_sendOwner == OWNER_MASTER)
					{
						g_modbusRxDone = 1;
						gCommStatus[gDeviceIndex] = COMM_OK;
						gCommErrorCount[gDeviceIndex] = 0;
					}
					if(gDebug)
						(void)printf("Recv Done!!!!(%d)\n",HAL_GetTick());
					sendFlag = 0;
					bRecvOk = true;
					g_modbusRxIndex = wModbusWaitLen;		// Recv frame 뒤에 Garbage 처리
					nMasterStatus = MasterModbusCRCCheck(bInChecking);
//					(void)printf("(((%d)))\n", HAL_GetTick());
					g_modbusRxIndex = 0;
				}
				else
				{
/*					(void)printf("g_bRecvVariable  Read!!!(%u, %d)\n", g_sendOwner, g_modbusRxIndex);
					for(int i = 0; i < g_modbusRxIndex; i++)
					{
						  (void)printf("%02X ", g_modbusRxBuff[i]);
					}
					(void)printf("\n");
*/					uint16_t index = wModbusWaitLen;
					uint8_t cnt = g_modbusRxBuff[INDEX_7];
					bRecvOk = true;
					for(uint8_t i = 0; i < cnt; i++)
					{
						if(g_modbusRxIndex < (pos + 2))		// Object ID + Object Length
						{
							bRecvOk = false;
							break;
						}
						uint8_t len = g_modbusRxBuff[pos+1];
						if(g_modbusRxIndex < (pos + len + 1))
						{
							bRecvOk = false;
							break;
						}
						pos += len + 2;
					}
					if(bRecvOk == true)
					{
						if(g_modbusRxIndex < (pos + 2))		// CRC
						{
							bRecvOk = false;
							return;
						}
						if(g_sendOwner == OWNER_MASTER)
						{
							g_modbusRxDone = 1;
							gCommStatus[gDeviceIndex] = COMM_OK;
							gCommErrorCount[gDeviceIndex] = 0;
						}
//						(void)printf("((((%d))))\n", HAL_GetTick());
						if(gDebug)
							(void)printf("[g_bRecvVariable]Recv Done!!!!(%d)\n", HAL_GetTick());
						g_modbusRxIndex = pos+2;
						nMasterStatus = MasterModbusCRCCheck(bInChecking);
						sendFlag = 0;
					}
				}
			}
		}
		else
		{
			if((HAL_GetTick() - last_recv) > 1000)
			{
				printf("Recv Timeout Reset(%d,last=%d)------------------------\n", HAL_GetTick(), last_recv);
				uint32_t stat = HAL_UART_GetState(&huart2);
				uint32_t error = HAL_UART_GetError(&huart6);
				printf("stat:%x. error=%x\n", stat, error);
//				__HAL_DMA_DISABLE(&huart2);
				HAL_UART_DMAStop(&huart2);
				HAL_UART_MspDeInit(&huart2);
				Pol_Delay_us(15000);
				HAL_UART_MspInit(&huart2);
				MX_USART2_UART_Init();
//				__HAL_DMA_ENABLE(&huart2);
				HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET);
				HAL_UART_Receive_DMA(&huart2, uart2_dma_rx_buff, UART2_DMA_RX_BUFF_SIZE);
				uart2LastNDTR = huart2.hdmarx->Instance->NDTR;
				last_recv = HAL_GetTick();
				sendFlag = 0;
				bInControl = false;
				if(g_sendOwner == OWNER_MASTER)
				{
					g_modbusRxError = 1;
					if(bInChecking == false)
					{
						if(MasterSendLength[OWNER_SLAVE] != 0)
							g_sendOwner = OWNER_SLAVE;
					}
				}
				else
				{
					if(gbSavingMode == FALSE)
						g_sendOwner = OWNER_MASTER;
				}
			}
			uint32_t tick = HAL_GetTick() - masterSendTick;
			if(sendFlag == 1 && bRecvOk == false && tick > 1000)		//Send 후 500ms 이내 응답없으면
			{

				printf("Send And Recv timeout!!!(g_sendOwner:%d)\n",  g_sendOwner);
				if(g_sendOwner == OWNER_MASTER)
				{
					if(++gCommErrorCount[gDeviceIndex] >= COMM_ERROR_COUNT)
					{
						gCommStatus[gDeviceIndex] = COMM_ERROR;
						gCommErrorCount[gDeviceIndex] = 0;
						(void)printf("Comm Error!!!!\n");
					}
					if(bInChecking == false)
					{
						if(MasterSendLength[OWNER_SLAVE] != 0)
							g_sendOwner = OWNER_SLAVE;
					}
					g_modbusRxError = 1;
				}
				else
				{
					if(gbSavingMode == FALSE)
						g_sendOwner = OWNER_MASTER;
				}
				sendFlag = 0;
				bInControl = false;
			}
		}
	}
	if(huart2.gState == HAL_UART_STATE_READY)
	{
	}
	uint32_t stat = HAL_UART_GetState(&huart2);
	uint32_t error = HAL_UART_GetError(&huart6);
	if(error != HAL_UART_ERROR_NONE)
		printf("\n\n\n\n Error!!!(stat:%d, error:%d\n\n\n\n", stat, error);
}

static uint8_t SlaveModbusCRCCheck(void)
{
	if(g_modbusSlaveRxIndex < 5 || g_modbusSlaveRxIndex > MODBUS_SLAVE_BUFF_SIZE)
	{
		g_modbusSlaveRxIndex = 0;
		return MODBUS_CRC_ERROR;
	}
	if(gDebug)
	{
		(void)printf("Slave Recv Frame!!!(%d)\n", HAL_GetTick());
		for(int i = 0; i < g_modbusSlaveRxIndex; i++)
		{
			(void)printf("%02X ", g_modbusSlaveRxBuff[i]);
		}
		(void)printf("\n");
	}
	bool exception = false;
	if(g_modbusSlaveRxBuff[1] & MASK_80)
	{
		exception = true;
		if(gDebug)
			(void)printf("-----------------\nModbus Exception Error[%02x]\n", g_modbusSlaveRxBuff[INDEX_2]);
	}

	uint8_t ret = MODBUS_OK;
	uint16_t p, crc;
	if(exception == true)
	{
		p = (uint16_t)(g_modbusSlaveRxBuff[INDEX_3] << INDEX_8) | (uint16_t)g_modbusSlaveRxBuff[INDEX_4];
		crc = CRC16(g_modbusSlaveRxBuff, INDEX_3);
	}
	else
	{
		p = (uint16_t)(g_modbusSlaveRxBuff[g_modbusSlaveRxIndex-INDEX_2] << INDEX_8) | (uint16_t)g_modbusSlaveRxBuff[g_modbusSlaveRxIndex-1];
		crc = CRC16(g_modbusSlaveRxBuff, g_modbusSlaveRxIndex-INDEX_2);
	}
	if(crc == p)
	{
		if(bInControl == true && g_modbusSlaveRxBuff[1] == FORCE_SINGLE_COIL)
		{
			ControlModbusBufferPut(g_modbusSlaveRxBuff, g_modbusSlaveRxIndex, OWNER_SLAVE);
			g_modbusSlaveRxIndex = 0;
		}
		else
		{
			MasterModbusBufferPut(g_modbusSlaveRxBuff, g_modbusSlaveRxIndex, OWNER_SLAVE);
			g_modbusSlaveRxIndex = 0;
			bInControl = false;
		}
	}
	else
	{
		if(gDebug)
			(void)printf("-----------------\nModbus CRC Error[%04x, %04x]\n", crc, p);
		ret = MODBUS_CRC_ERROR;
	}
	g_modbusSlaveRxIndex = 0;
	return ret;
}


void SlaveModbusProcess(void)
{
	static bool bTurnSlave = false;
	uint32_t uart1NewNDTR = huart1.hdmarx->Instance->NDTR;
	int nTimeOut = MODBUS_TIMEOUT;
	int bRecvOk = FALSE;
	uint32_t count;
	static uint32_t slave_last_recv = 0;


	if(uart1LastNDTR != uart1NewNDTR)
	{
		uint32_t pos = UART1_DMA_RX_BUFF_SIZE - uart1LastNDTR;
		if(uart1LastNDTR > uart1NewNDTR)
		{
		  count = (uart1LastNDTR - uart1NewNDTR);
		  memcpy(&g_modbusSlaveRxBuff[g_modbusSlaveRxIndex], &uart1_dma_rx_buff[pos], count);
		  g_modbusSlaveRxIndex += count;
		}
		else
		{
			count = (UART1_DMA_RX_BUFF_SIZE - uart1NewNDTR) + uart1LastNDTR;
			memcpy(&g_modbusSlaveRxBuff[g_modbusSlaveRxIndex], &uart1_dma_rx_buff[pos], uart1LastNDTR);
			g_modbusSlaveRxIndex += uart1LastNDTR;
			uint32_t remainder = UART1_DMA_RX_BUFF_SIZE- uart1NewNDTR;
			memcpy(&g_modbusSlaveRxBuff[g_modbusSlaveRxIndex], &uart1_dma_rx_buff[0], remainder);
			g_modbusSlaveRxIndex += remainder;
		}
		slave_last_recv = HAL_GetTick();
		if(gDebug)
			printf("(%d)g_modbusSlaveRxIndex : %d\n", slave_last_recv, g_modbusSlaveRxIndex);
		if(g_modbusSlaveRxIndex >= INDEX_8)
		{

			if(SlaveModbusCRCCheck() == MODBUS_OK)
			{
			}
		}
		uart1LastNDTR = uart1NewNDTR;
	}
	else
	{
		if((slave_last_recv != 0) && ((HAL_GetTick() - slave_last_recv) > 2000))
		{
		  printf("Slave Recv Wait Time Out!!!(%d,%d)\n", slave_last_recv, HAL_GetTick());
//		  g_modbusSlaveRxIndex = 0;
		  slave_last_recv = HAL_GetTick();
		}
	}
}

// PRQA S 1503 1
E_KEY GetKey(void)
{
	static  int gCommCheckStatus[DEVICE_MAX];
	uint32_t LedTickCount = HAL_GetTick();

	uint32_t timer;
	while (1)
    {

#if __WATCHDOG__ //[[ by kys.2018.06.17_BEGIN -- watchdog
            __HAL_IWDG_RELOAD_COUNTER(&hiwdg);
#endif //]] by kys.2018.06.17_END -- watchdog

		CommStatusDisp();
		timer = HAL_GetTick();
		uint32_t diff;
		diff = timer-commTimer;

		if((timer - LedTickCount) > 500)
		{
			HAL_GPIO_TogglePin(USER_LED_GPIO_Port, USER_LED_Pin);
			LedTickCount = timer;
		}
		if(diff >= GetTimerDiff())
		{
			if((g_bRecvAllDone == TRUE) || (diff >= TIMER_DIFF_10SEC))          //  모든 데이터 수집 완료하거나 타임아웃이면
			{
				if(gDebug)
					(void)printf("g_bRecvAllDone=%d, commTimer-1=%d, Tick=%d, Diff=%d\n", g_bRecvAllDone, commTimer, timer, diff);
				CommTimerClear();
				return TIME_OUT;
			}
		}
		diff = timer-readTimeTimer;
		if(diff >= TIMER_DIFF)
		{
//			printf("commTimer-2=%d, Tick=%d, Diff=%d\n", commTimer, timer, diff);
//			printf("readTimeTimer=%d, Tick=%d, Diff=%d\n", readTimeTimer, timer, diff);
			if(gbSettingTime == FALSE)
			{
				PCF2127_readTime(1);
//				printf("gDateTime.Day=%d ,gTimeSyncDay=%d, gDateTime.Hour=%d, TIMESYNC_HOUR=%d, gDateTime.Min=%d,TIMESYNC_MIN=%d\n", gDateTime.Day ,gTimeSyncDay, gDateTime.Hour, TIMESYNC_HOUR, gDateTime.Min,TIMESYNC_MIN);
				if((gDateTime.Day != gTimeSyncDay) && (gDateTime.Hour == TIMESYNC_HOUR) && (gDateTime.Min == TIMESYNC_MIN))
				{
					(void)printf("TimeSync.....\n\n\n\n\n\n\n\n\n\n");
					gTimeSyncDay = gDateTime.Day;
					for(int i = 0; i < gDeviceCount; i++)
					{
//							OS_Delay(TIMESYNC_DELAY);
						ModbusSetTimeAndWait(ConnectSetting[i].Address, &gDateTime);    // yskim
					}
				}
			}
			readTimeTimer = timer;
			if(gDebug)
				(void)printf("SECOND_TIMER return(%d)\n", SECOND_TIMER);
			return SECOND_TIMER;
		}
		if(gCommStatus[gDeviceIndex] != gCommCheckStatus[gDeviceIndex])
		{
			if(gCommStatus[gDeviceIndex] == COMM_ERROR)
			{
				gCommCheckStatus[gDeviceIndex] = gCommStatus[gDeviceIndex];
				if(gDebug)
					(void)printf("\n\n\n\n\n gCommStatus[gDeviceIndex] == COMM_ERROR\n\n\n\n\n\n");
				return COMM_STAT_ERROR;
			}
			gCommCheckStatus[gDeviceIndex] = gCommStatus[gDeviceIndex];
		}
		if(gbSavingMode == FALSE)
		{
			if((SettingValue[SETUP_SAVING_MODE] != 0) && (timer >= gSavingModeCounter))
			{
				BacklightBrghtness(SettingValue[SETUP_BRIGHTNESS], TRUE);
				LCD_OnOff(0);
				gbSavingMode = TRUE;
			}
		}
		if(gbInMainMenu == TRUE)
		{
			if((SettingValue[SETUP_DEVICE_COUNT] != 1) && (SettingValue[SETUP_SCREEN_SWITCHING] != 0) && (timer >= gScreenSwitchingCounter))
			{
				gScreenSwitchingCounter = timer + (SettingValue[SETUP_SCREEN_SWITCHING] * THOUSAND);
				if(gbSavingMode == FALSE)
					return KEY_DOWN;
			}
		}
		else
		{
			if((SettingValue[SETUP_RETURN_TO_SCREEN] != 0) && (timer >= gReturnToScreen))
			{
				if(gbSavingMode == FALSE)
					return KEY_CANCEL;
			}
		}
		for(E_KEY i = KEY_SETUP; i < KEY_MAX; i++)
		{
			if(KeyChanged[i] == 1)
			{
				KeyChanged[i] = 0;
				uint8_t bContinue = FALSE;
				if(gbSavingMode == TRUE)
				{
					BacklightBrghtness(SettingValue[SETUP_BRIGHTNESS], 0);
					LCD_OnOff(1);
					bContinue = TRUE;
					gbSavingMode = FALSE;
				}
				ScreenTimerInit();
				if(bContinue == TRUE)
				{
					continue;
				}
				return i;
			}
		}
		if(bInControl == true && (timer - inControlTick) > 5000)
		{
			if(gDebug)
				printf("Control Timeout....\n");
			bInControl = false;
		}
		if(sendFlag == 0)
		{
			uint32_t tm = HAL_GetTick();

			if(bInControl == true)
			{
				if(ControlSendLength != 0)
				{
					if(gDebug)
						printf("ControlModbusSend(%d, %d)\n", HAL_GetTick(), g_sendOwner);
					ControlModbusSend();
				}
			}
			else
			{
				if(MasterSendLength[g_sendOwner] != 0)
				{
					if(gDebug)
						printf("MasterModbusSend(%d, %d)\n", HAL_GetTick(), g_sendOwner);
					MasterModbusSend(g_sendOwner);
				}
				else
				{
					if(bInControl == false)
					{
						if(g_sendOwner == OWNER_MASTER)
						{
							if(MasterSendLength[OWNER_SLAVE] != 0)
								g_sendOwner = OWNER_SLAVE;
						}
						else
						{
							if(gbSavingMode == FALSE)
								g_sendOwner = OWNER_MASTER;
						}
						if(MasterSendLength[g_sendOwner] != 0)
						{
							if(gDebug)
								printf("MasterModbusSend2(%d, %d)\n", HAL_GetTick(), g_sendOwner);
							MasterModbusSend(g_sendOwner);
						}
					}
				}
			}
		}
		else
		{
			if(gDebug)
				printf("{1}");
		}
		MasterModbusProcess(false);
		SlaveModbusProcess();

		if(SlaveSendLength != 0)
		{
			if(gDebug)
				printf("SlaveModbusSend(%d)\n", HAL_GetTick());
			SlaveModbusSend();
		}
		if (g_modbusRxDone)
		{
			if(gDebug)
				printf("g_modbusRxDone!!\n");
			CommStatusDisp();
			if(nMasterStatus == MODBUS_OK)
			{
				if(gDebug)
					(void)printf("[MODBUS_OK]\n");
			  return DATA_RECV;
			}
			else
			if(nMasterStatus == MODBUS_ERROR)
			{
			  (void)printf("[Modbus Error]\n");
			  return KEY_COMM_ERROR;
			}
			else
			if(nMasterStatus == MODBUS_CRC_ERROR)
			{
			  (void)printf("[CRC BAD]\n");
			  return KEY_COMM_ERROR;
			}
			g_modbusRxDone = 0;
		}
		if(g_modbusRxError)
		{
			(void)printf("[g_modbusRxError(%d)]\n", g_sendOwner);
			CommStatusDisp();
			g_modbusRxError = 0;
			return KEY_COMM_ERROR;
		}
		GUI_Delay(30);
	}
}

uint8_t ModbusRecvCheck(void)
{
	uint32_t tick = HAL_GetTick();

	uint32_t timer;

	g_sendOwner = OWNER_MASTER;
	if(gDebug)
		printf("[RecvCheck] MasterModbusSend(%d, %d)\n", HAL_GetTick(), g_sendOwner);
	MasterModbusSend(g_sendOwner);
	last_recv = tick;

	while (1)
    {
		timer = HAL_GetTick();
		MasterModbusProcess(true);

		if(SlaveSendLength != 0)
		{
			if(gDebug)
				printf("SlaveModbusSend(%d)\n", HAL_GetTick());
			SlaveModbusSend();
		}
		if (g_modbusRxDone)
		{
			printf("g_modbusRxDone!!\n");
			CommStatusDisp();
			if(nMasterStatus == MODBUS_OK)
			{
				if(gDebug)
					(void)printf("[MODBUS_OK]\n");
			  return DATA_RECV;
			}
			else
			if(nMasterStatus == MODBUS_ERROR)
			{
			  (void)printf("[Modbus Error]\n");
			  return KEY_COMM_ERROR;
			}
			else
			if(nMasterStatus == MODBUS_CRC_ERROR)
			{
			  (void)printf("[CRC BAD]\n");
			  return KEY_COMM_ERROR;
			}
			g_modbusRxDone = 0;
		}
		if(g_modbusRxError)
		{
			(void)printf("[g_modbusRxError(%d)]\n", g_sendOwner);
			CommStatusDisp();
			g_modbusRxError = 0;
			return KEY_COMM_ERROR;
		}
		GUI_Delay(50);
	}
}

/*************************** End of file ****************************/
