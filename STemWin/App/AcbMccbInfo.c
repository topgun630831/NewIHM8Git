/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#define EXTERN extern
#include "stm32f4xx_hal.h"
#include "main.h"
#include "GuiData.h"


/*********************************************************************
*
*       Defines
*
**********************************************************************
*/

#define RELAY_STATUS_TEXT_X0			36
#define RELAY_STATUS_TEXT_X1			RELAY_STATUS_TEXT_X0 + 134
#define RELAY_STATUS_TEXT_Y0			50
#define RELAY_STATUS_TEXT_Y1			RELAY_STATUS_TEXT_Y0 + 20

#define RELAY_STATUS_PAGE_TEXT_X0		380
#define RELAY_STATUS_PAGE_TEXT_X1		RELAY_STATUS_PAGE_TEXT_X0 + 64

#define RELAY_STATUS_LINE_X				10
#define RELAY_STATUS_LINE_Y				78
#define RELAY_STATUS_LINE_X_INC			230
#define RELAY_STATUS_LINE_Y_INC			58

#define RELAY_STATUS_PAGE_MAX			7
#define RELAY_STATUS_COUNT				8

#define RELAY_STATUS_READ_ADDR			211
#define RELAY_STATUS_READ_LEN			4

#define RELAY_STATUS_LABEL_X0			RELAY_STATUS_LINE_X + 26
#define RELAY_STATUS_LABEL_Y0			RELAY_STATUS_LINE_Y + 14
#define RELAY_STATUS_LABEL_X1			RELAY_STATUS_LABEL_X0 + 158
#define RELAY_STATUS_LABEL_Y1			RELAY_STATUS_LABEL_Y0 + 30

#define RELAY_STATUS_BOX_X0				RELAY_STATUS_LABEL_X1
#define RELAY_STATUS_BOX_Y0				RELAY_STATUS_LINE_Y + 19
#define RELAY_STATUS_BOX_X1				RELAY_STATUS_BOX_X0 + 20
#define RELAY_STATUS_BOX_Y1				RELAY_STATUS_BOX_Y0 + 20

// USER START (Optionally insert additional defines)
static void InfoSend(int menu);
static void InfoValueDisp(int pos, int count);
static void InfoInitDisp(int pos);
static void InfoDisp(int pos);
static void RelayStatusSend(void);
static void RelayStatusDisp(int nPage);
static void RelayStatus(void);
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
char const* _acacbmccb_relay_status_text[RELAY_STATUS_PAGE_MAX][RELAY_STATUS_COUNT] = {
	{
		"Pre Alarm",
		"L A",
		"L B",
		"L C",
		"L N",
		"S1 A",
		"S1 B",
		"S1 C"
	},
	{
		"S2 A",
		"S2 B",
		"S2 C",
		"PTA A",
		"PTA B",
		"PTA C",
		"",
		""
	},
	{
		"I A",
		"I B",
		"I C",
		"G",
		"Gext",
		"D A",
		"D B",
		"D C",
	},
	{
		"S(V)1 A",
		"S(V)1 B",
		"S(V)1 C",
		"S(V)2 A",
		"S(V)2 B",
		"S(V)2 C",
		"OF1",
		"OF2",
	},
	{
		"UF1",
		"UF2",
		"RQ1",
		"RQ2",
		"OQ",
		"UP",
		"ROCF",
		"RV",
	},
	{
		"OV1 A",
		"OV1 B",
		"OV1 C",
		"OV2 A",
		"OV2 B",
		"OV2 C",
		"UV1 A",
		"UV1 B"
	},
	{
		"UV1 C",
		"UV2 A",
		"UV2 B",
		"UV2 C",
		"VU",
		"IU",
		"RP",
		"OP"
	}
};

static int const relay_status_register[RELAY_STATUS_PAGE_MAX][RELAY_STATUS_COUNT] = {
	{					// page 1
		211,
		211,
		211,
		211,
		211,
		211,
		211,
		211
	},
	{					// page 2
		211,
		211,
		211,
		211,
		211,
		211,
		211,
		211
	},
	{					// page 3
		212,
		212,
		212,
		212,
		212,
		212,
		212,
		212
	},
	{					// page 4
		212,
		212,
		212,
		212,
		212,
		212,
		213,
		213
	},
	{					// page 5
		213,
		213,
		213,
		213,
		213,
		213,
		213,
		213
	},
	{					// page 6
		214,
		214,
		214,
		214,
		214,
		214,
		214,
		214
	},
	{					// page 7
		214,
		214,
		214,
		214,
		214,
		214,
		214,
		214
	}
};

static int const relay_status_bit[RELAY_STATUS_PAGE_MAX][RELAY_STATUS_COUNT] = {
	{					// page 1
		0,
		5,
		6,
		7,
		8,
		9,
		10,
		11
	},
	{					// page 2
		12,
		13,
		14,
		2,
		3,
		4,
		0,
		0
	},
	{					// page 3
		0,
		1,
		2,
		3,
		4,
		5,
		6,
		7
	},
	{					// page 4
		8,
		9,
		10,
		11,
		12,
		13,
		0,
		1
	},
	{					// page 5
		2,
		3,
		4,
		5,
		6,
		7,
		8,
		9
	},
	{					// page 6
		0,
		1,
		2,
		3,
		4,
		5,
		6,
		7
	},
	{					// page 7
		8,
		9,
		10,
		11,
		12,
		13,
		14,
		14
	}
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

static void InfoSend(int menu)
{
	if(StatusSend() == STATUS_SEND_ING)
	{
		return;
	}
	(void)printf("InfoSend() nSendStep=%d\n", nSendStep);
	if(menu == 0)
	{
		if(nSendStep == 0)
		{
			ModbusSendFrameDeviceIdentofocation3(ConnectSetting[gDeviceIndex].Address, 1, 0);
		}
		else
		{
			ModbusSendFrameDeviceIdentofocation3(ConnectSetting[gDeviceIndex].Address, INDEX_3, MODBUS_EXTENDED_OBJECT);
		}
	}
	else
	{
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, ACB_INFO_READ_ADDR, ACB_INFO_READ_LEN);
		}
		else
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, MCCB_INFO_READ_ADDR, MCCB_INFO_READ_LEN);
		}
		else {}
	}
}

// PRQA S 1503 2
// PRQA S 1505 1
void InfoMenu(int menu, int pos, int count)
{
	GUI_SetBkColor(COLOR_MAIN_BG);
	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);

	GUI_RECT rect;
	rect.x0 = INFO_MENU_X0;
	rect.x1 = (INFO_MENU_X0 + INFO_MENU_WIDTH) - 1;
	rect.y0 = STARTY_CONTENTS;
	rect.y1 = (STARTY_CONTENTS + INFO_MENU_HEIGHT) - 1;

	int y0 = STARTY_CONTENTS;
	for(int i = 0; i < count; i++)
	{
		if(i == pos)
		{
			GUI_SetColor(COLOR_MENU_SELECTED);
		}
		else
		{
			GUI_SetColor(COLOR_MENU_NORMAL);
		}
		GUI_FillRect(STARTX_CONTENTS, y0, (STARTX_CONTENTS + INFO_MENU_WIDTH) - 1, (y0 + INFO_MENU_HEIGHT) - 1);

		if(i == pos)
		{
			LanguageSelect(FONT24B);
			GUI_SetColor(COLOR_VALUE);
			GUI_SetBkColor(COLOR_MENU_SELECTED);
		}
		else
		{
			LanguageSelect(FONT24);
			GUI_SetColor(COLOR_LABEL);
			GUI_SetBkColor(COLOR_MENU_NORMAL);
		}

		GUI_DispStringInRect(_acinfo_menu_text[SettingValue[SETUP_LANGUAGE]][menu][i], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);
		rect.y0 += INFO_MENU_HEIGHT + 1;
		rect.y1 += INFO_MENU_HEIGHT + 1;
		y0 += INFO_MENU_HEIGHT + 1;;
	}
}
static void InfoValueDisp(int pos, int count)
{
	char buf[INDEX_6][MESSAGE_BUF_SIZE];
	uint16_t wValue;
	uint32_t dValue;

	(void)printf("InfoValueDisp() nSendStep=%d\n", nSendStep);

	GUI_SetBkColor(COLOR_MAIN_BG);

	if(pos == 0)
	{
		if(nSendStep == 0)
		{
			ModbusGetId1();
			nSendStep = 1;
//			InfoSend(pos);
			return;
		}
		else
		{
			(void)sprintf(buf[0], "%s", VendorName);
//			ModbusGetId3(serialNo, productCode, har			char serialNo[DEFAULT_BUF_SIZE];
			ModbusGetId3();
			(void)sprintf(buf[1], "%s(%s)", gProductName[gDeviceIndex], productCode);
			(void)sprintf(buf[INDEX_2], "%s", hardwarVersion);
			(void)sprintf(buf[INDEX_3], "%s", softwareVersion);
			(void)sprintf(buf[INDEX_4], "%s", ModbusVersion);
			(void)sprintf(buf[INDEX_5], "%s", serialNo);
			nSendStep = 0;
		}
	}
	else if(pos == 1)
	{
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
		{
			dValue = (ModbusGetUint32(I_REGISTER_1759));		// Running Time
			(void)sprintf(buf[INDEX_0], "%dh", dValue);
			dValue = (ModbusGetUint32(I_REGISTER_1761));		// Energizing Cycle
			(void)sprintf(buf[INDEX_1], "%dh", dValue);
			dValue = (ModbusGetUint32(I_REGISTER_1765));		// M
			(void)sprintf(buf[INDEX_2], "%d", dValue);
			dValue = (ModbusGetUint32(I_REGISTER_1763));		// E
			(void)sprintf(buf[INDEX_3], "%d", dValue);
			dValue = (ModbusGetUint32(I_REGISTER_1767));		// Number of Trip
			(void)sprintf(buf[INDEX_4], "%d", dValue);
			wValue = (ModbusGetUint16(I_REGISTER_1769));		// Contact Wear
			(void)sprintf(buf[INDEX_5], "%d", wValue);
			int len = strlen(buf[INDEX_5]);
			buf[INDEX_5][len++] = '%';
			buf[INDEX_5][len] = 0;
		}
		else
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			dValue = (ModbusGetUint32(I_REGISTER_1201));
			(void)sprintf(buf[INDEX_0], "%dh", dValue);
			dValue = (ModbusGetUint32(I_REGISTER_1203));
			(void)sprintf(buf[INDEX_1], "%dh", dValue);
			dValue = (ModbusGetUint32(I_REGISTER_1207));
			(void)sprintf(buf[INDEX_2], "%d", dValue);
			dValue = (ModbusGetUint32(I_REGISTER_1205));
			(void)sprintf(buf[INDEX_3], "%d", dValue);
			dValue = (ModbusGetUint32(I_REGISTER_1209));
			(void)sprintf(buf[INDEX_4], "%d", dValue);
			wValue = (ModbusGetUint16(I_REGISTER_1211));
			(void)sprintf(buf[INDEX_5], "%d", wValue);
			int len = strlen(buf[INDEX_5]);
			buf[INDEX_5][len++] = '%';
			buf[INDEX_5][len] = 0;
		}
		else {}
		nSendStep = 0;
	}
	else {}

	GUI_SetColor(COLOR_VALUE);
	GUI_RECT rect;
	GUI_RECT rect2;
	rect.x0 = INFO_VALUE_X0;
	rect.y0 = STARTY_VALUE + INDEX_2;
	rect.x1 = INFO_VALUE_X1;
	rect.y1 = (STARTY_VALUE + HEIGHT_VALUE) - INDEX_4;

	rect2.x0 = INFO_VALUE_X0 - INDEX_80;
	rect2.y0 = STARTY_VALUE + INDEX_2;
	rect2.x1 = INFO_VALUE_X1;
	rect2.y1 = (STARTY_VALUE + HEIGHT_VALUE) - INDEX_4;

	(void)GUI_SetFont(&GUI_Font20B_ASCII);
	for(int i = 0 ; i < count; i++)
	{
		if((pos == 0) && (i == 1))
		{
			GUI_ClearRectEx(&rect2);
			GUI_DispStringInRect(buf[i], &rect2, GUI_TA_RIGHT | GUI_TA_VCENTER);
		}
		else
		{
			GUI_ClearRectEx(&rect);
			GUI_DispStringInRect(buf[i], &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
		}
		rect.y0 += HEIGHT_VALUE;
		rect.y1 += HEIGHT_VALUE;
		rect2.y0 += HEIGHT_VALUE;
		rect2.y1 += HEIGHT_VALUE;
	}
}
static void InfoInitDisp(int pos)
{
	int count = LINECOUNT_CONTENTS;

	GUI_SetBkColor(COLOR_MAIN_BG);
	(void)GUI_SetFont(&GUI_Font20_ASCII);

	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_LINE);

	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	GUI_DrawRect(STARTX_CONTENTS, STARTY_CONTENTS, (STARTX_CONTENTS + WIDTH_CONTENTS)-1, (STARTY_CONTENTS + (HEIGHT_LABEL * count )) - 1);

	for(int i = 0; i < (count-1); i++)
	{
		if((pos == INDEX_1) && (i == INDEX_2))
		{
			continue;
		}
		int y0 = STARTY_CONTENTS + ((i + 1) * HEIGHT_LABEL);
		GUI_DrawHLine(y0, STARTX_CONTENTS+INDEX_2, (STARTX_CONTENTS + WIDTH_CONTENTS)-1);
	}

	GUI_SetColor(COLOR_LABEL);
	GUI_RECT rect;
	GUI_RECT rect2;
	rect.x0 = STARTX_LABEL;
	rect.y0 = STARTY_LABEL;
	rect.x1 = (STARTX_LABEL +  WIDTH_LABEL + INDEX_20) - 1;
	rect.y1 = (STARTY_LABEL +  HEIGHT_LABEL) - 1;

	rect2.x0 = STARTX_LABEL - INDEX_3;
	rect2.y0 = STARTY_LABEL;
	rect2.x1 = (STARTX_LABEL +  WIDTH_LABEL + INDEX_20) - 1;
	rect2.y1 = (STARTY_LABEL +  HEIGHT_LABEL) - 1;

	LanguageSelect(FONT20);
	for(int i = 0 ; i < count; i++)
	{
		if(pos == 1 && i == INDEX_3)
		{
			GUI_DispStringInRect(_acinfo_label_text[SettingValue[SETUP_LANGUAGE]][pos][i], &rect2, GUI_TA_LEFT | GUI_TA_VCENTER);
		}
		else
		{
			GUI_DispStringInRect(_acinfo_label_text[SettingValue[SETUP_LANGUAGE]][pos][i], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);
		}
		rect.y0 += HEIGHT_LABEL;
		rect.y1 += HEIGHT_LABEL;
		rect2.y0 += HEIGHT_LABEL;
		rect2.y1 += HEIGHT_LABEL;
	}
}

static void InfoDisp(int pos)
{
	int flagBreak = FALSE;
	int count = LINECOUNT_CONTENTS;
	InfoInitDisp(pos);

	nSendStep = 0;

	InfoSend(pos);

	while (1)
	{
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			nSendStep = 0;
			InfoSend(pos);
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			InfoInitDisp(pos);
			gCommOldStatus[gDeviceIndex] = -1;
		}
		else
		if(key == DATA_RECV)
		{
			(void)printf("DATA_RECV gStatusSendEnd=%d\n",gStatusSendEnd);
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				StatusRecv();
				InfoSend(pos);
			}
			else
			{
				InfoValueDisp(pos, count);
				if(nSendStep != 0)
				{
					InfoSend(pos);
				}
				else
				{
					g_bRecvAllDone = TRUE;
					nSendStep = 0;
					statusSendStep = 0;
					gStatusSendEnd = STATUS_SEND_ING;
				}
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{
			if(gStatusSendEnd == STATUS_SEND_END)
			{
				nSendStep++;
			}
			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				int stepMax = INDEX_2;
				if(pos == 1)
				{
					stepMax = 1;
				}

				if(nSendStep < stepMax)
				{
					InfoSend(pos);
				}
				else
				{
					g_bRecvAllDone = TRUE;
					(void)printf("All done!!!\n");
					gStatusSendEnd = STATUS_SEND_ING;
					statusSendStep = 0;
					nSendStep = 0;
				}
			}
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			InfoInitDisp(pos);
		}
		else {}

		if(flagBreak == TRUE)
		{
			break;
		}
		GUI_Delay(1);
	}
}

static void RelayStatusValueDisp(int nPage)
{
	GUI_RECT rect;
	uint8_t status[RELAY_STATUS_COUNT];

	int cnt = RELAY_STATUS_COUNT;
	int row_cnt = INDEX_4;
	if(nPage == 1)
	{
		row_cnt = INDEX_3;
		cnt = INDEX_6;
	}

	for(int i = 0; i < cnt; i++)
	{
		status[i] = ModbusGetBit(relay_status_register[nPage][i], relay_status_bit[nPage][i]);
	}
	if(nPage == 0)
	{
		uint8_t status1 = ModbusGetBit(relay_status_register[0][0], 0);
		uint8_t status2 = ModbusGetBit(relay_status_register[0][0], 1);
		if(status1 == 0 && status2 == 0)
			status[0] = 0;
		else
		if(status1 == 1 && status2 == 0)
			status[0] = 1;
		else
			status[0] = 2;
	}

	rect.y0 = RELAY_STATUS_BOX_Y0;
	rect.y1 = RELAY_STATUS_BOX_Y1;
	int pos = 0;
	for(int i = 0; i < row_cnt; i++)
	{
		rect.x0 = RELAY_STATUS_BOX_X0;
		rect.x1 = RELAY_STATUS_BOX_X1;
		for(int j = 0 ; j < INDEX_2; j++)
		{
			if(status[pos] == 0)
			{
				GUI_SetColor(COLOR_NORMAL);
			}
			else
			if(status[pos] == 1)
			{
				GUI_SetColor(COLOR_ALARM);
			}
			else
			{
				GUI_SetColor(COLOR_WARNING);
			}
			GUI_FillRectEx(&rect);
			rect.x0 += RELAY_STATUS_LINE_X_INC;
			rect.x1 += RELAY_STATUS_LINE_X_INC;
			pos++;
		}
		rect.y0 += RELAY_STATUS_LINE_Y_INC;
		rect.y1 += RELAY_STATUS_LINE_Y_INC;
	}
}

static void RelayStatusSend(void)
{
	if(StatusSend() == STATUS_SEND_ING)
	{
		return;
	}
	ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, RELAY_STATUS_READ_ADDR, RELAY_STATUS_READ_LEN);
}


static void RelayStatusDisp(int nPage)
{
	GUI_SetBkColor(COLOR_MAIN_BG);
	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	(void)GUI_SetFont(&GUI_Font20_ASCII);

	GUI_SetColor(COLOR_LABEL);
	GUI_RECT rect;
	rect.x0 = RELAY_STATUS_TEXT_X0;
	rect.x1 = RELAY_STATUS_TEXT_X1;
	rect.y0 = RELAY_STATUS_TEXT_Y0;
	rect.y1 = RELAY_STATUS_TEXT_Y1;
	GUI_DispStringInRect("Relay Status", &rect, (GUI_TA_LEFT | GUI_TA_VCENTER));

	GUI_SetColor(GUI_WHITE);
	rect.x0 = RELAY_STATUS_PAGE_TEXT_X0;
	rect.x1 = RELAY_STATUS_PAGE_TEXT_X1;

	int row_cnt = INDEX_4;
	if(nPage == 1)
		row_cnt = INDEX_3;
	char buf[INDEX_10];
	sprintf(buf, "%d/%d", nPage+1, RELAY_STATUS_PAGE_MAX);
	GUI_DispStringInRect(buf, &rect, (GUI_TA_RIGHT | GUI_TA_VCENTER));

	GUI_SetColor(COLOR_LINE);
	rect.x0 = RELAY_STATUS_LINE_X;
	rect.y0 = RELAY_STATUS_LINE_Y;
	rect.x1 = RELAY_STATUS_LINE_X + (INDEX_2 * RELAY_STATUS_LINE_X_INC);
	(void)GUI_SetPenSize(PENSIZE_LINE);
	for(int i = 0; i < row_cnt+1; i++)
	{
		GUI_DrawHLine(rect.y0, rect.x0, rect.x1);
		rect.y0 += RELAY_STATUS_LINE_Y_INC;
	}

	rect.x0 = RELAY_STATUS_LINE_X;
	rect.y0 = RELAY_STATUS_LINE_Y;
	rect.y1 = RELAY_STATUS_LINE_Y + ((row_cnt) * RELAY_STATUS_LINE_Y_INC);
	(void)GUI_SetPenSize(PENSIZE_LINE);
	for(int i = 0; i < row_cnt+1; i++)
	{
		GUI_DrawVLine(rect.x0, rect.y0, rect.y1);
		rect.x0 += RELAY_STATUS_LINE_X_INC;
	}

	GUI_SetColor(COLOR_LABEL);
	(void)GUI_SetFont(&GUI_Font20_ASCII);
	rect.y0 = RELAY_STATUS_LABEL_Y0;
	rect.y1 = RELAY_STATUS_LABEL_Y1;
	int pos = 0;
	for(int i = 0; i < row_cnt; i++)
	{
		rect.x0 = RELAY_STATUS_LABEL_X0;
		rect.x1 = RELAY_STATUS_LABEL_X1;
		for(int j = 0 ; j < INDEX_2; j++)
		{
			GUI_DispStringInRect(_acacbmccb_relay_status_text[nPage][pos], &rect, (GUI_TA_LEFT | GUI_TA_VCENTER));
			rect.x0 += RELAY_STATUS_LINE_X_INC;
			rect.x1 += RELAY_STATUS_LINE_X_INC;
			pos++;
		}
		rect.y0 += RELAY_STATUS_LINE_Y_INC;
		rect.y1 += RELAY_STATUS_LINE_Y_INC;
	}
	rect.y0 = RELAY_STATUS_BOX_Y0;
	rect.y1 = RELAY_STATUS_BOX_Y1;
	GUI_SetColor(COLOR_DISABLE);
	for(int i = 0; i < row_cnt; i++)
	{
		rect.x0 = RELAY_STATUS_BOX_X0;
		rect.x1 = RELAY_STATUS_BOX_X1;
		for(int j = 0 ; j < INDEX_2; j++)
		{
			GUI_FillRectEx(&rect);
			rect.x0 += RELAY_STATUS_LINE_X_INC;
			rect.x1 += RELAY_STATUS_LINE_X_INC;
			pos++;
		}
		rect.y0 += RELAY_STATUS_LINE_Y_INC;
		rect.y1 += RELAY_STATUS_LINE_Y_INC;
	}
}

void RelayStatus(void)
{
	uint8_t bRecvData;
	int flagBreak = FALSE;
	bRecvData = FALSE;
	int nPage = 0;
	RelayStatusDisp(nPage);
	gStatusSendEnd = STATUS_SEND_ING;
	statusSendStep = 0;
	nSendStep = 0;
	RelayStatusSend();
	int bCommError = gCommStatus[gDeviceIndex];

	while (1)
    {
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			nSendStep = 0;
			RelayStatusSend();
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			RelayStatusDisp(nPage);
			gCommOldStatus[gDeviceIndex] = -1;
			RelayStatusSend();
		}
		else
		if(key == KEY_UP)
		{
			if(nPage > 0)
			{
				nPage--;
			}
			else
			{
				nPage = RELAY_STATUS_PAGE_MAX - 1;
			}
			RelayStatusDisp(nPage);
		}
		else
		if(key == KEY_DOWN)
		{
			if(nPage < (RELAY_STATUS_PAGE_MAX-1))
			{
				nPage++;
			}
			else
			{
				nPage = 0;
			}
			RelayStatusDisp(nPage);
		}
		else
		if(key == DATA_RECV)
		{
			(void)printf("DATA_RECV gStatusSendEnd=%d\n",gStatusSendEnd);
			if(bCommError == COMM_ERROR)
			{
				bCommError = COMM_OK;
			}
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				StatusRecv();
				RelayStatusSend();
			}
			else
			{
				RelayStatusValueDisp(nPage);
				g_bRecvAllDone = TRUE;
				nSendStep = 0;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
				bRecvData = TRUE;
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{

			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				RelayStatusSend();
				g_bRecvAllDone = TRUE;
				(void)printf("All done!!!\n");
				gStatusSendEnd = STATUS_SEND_ING;
				statusSendStep = 0;
				nSendStep = 0;
			}
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			(void)printf("COMM_STAT_ERROR\n\n");
			bCommError = COMM_ERROR;
			RelayStatusDisp(nPage);
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
	}
}



/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       Createstatus_window
*/

// PRQA S 1503 1
void AcbMccbInfomation(void)
{
	int flagBreak = FALSE;
	nMenuPos = 0;

	InfoMenu(INFO_MENU, nMenuPos, INFO_MENU_COUNT);

	GUI_SetBkColor(COLOR_MAIN_BG);
	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_LINE);
	gStatusSendEnd = STATUS_SEND_ING;
	(void)StatusSend();

	while (1)
    {
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			(void)StatusSend();
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			InfoMenu(INFO_MENU, nMenuPos, INFO_MENU_COUNT);
		}
		else
		if(key == KEY_UP)
		{
			if(nMenuPos > 0)
			{
				nMenuPos--;
			}
			else
			{
				nMenuPos = INFO_MENU_COUNT - 1;
			}
			InfoMenu(INFO_MENU, nMenuPos, INFO_MENU_COUNT);
		}
		else
		if(key == KEY_DOWN)
		{
			if(nMenuPos < (INFO_MENU_COUNT-1))
			{
				nMenuPos++;
			}
			else
			{
				nMenuPos = 0;
			}
			InfoMenu(INFO_MENU, nMenuPos, INFO_MENU_COUNT);
		}
		else
		if(key == KEY_ENTER)
		{
			if(nMenuPos == INDEX_2)
			{
				RelayStatus();
			}
			else
			{
				InfoSend(nMenuPos);
				InfoDisp(nMenuPos);
			}
			InfoMenu(INFO_MENU, nMenuPos, INFO_MENU_COUNT);
		}
		else
		if(key == DATA_RECV)
		{
			StatusRecv();
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				(void)StatusSend();
			}
			else
			{
				g_bRecvAllDone = TRUE;
				nSendStep = 0;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{
			(void)printf("COMM Error!! gStatusSendEnd=%d, statusSendStep=%d\n",gStatusSendEnd,statusSendStep);
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				g_bRecvAllDone = TRUE;
				(void)printf("All done!!!\n");
				gStatusSendEnd = STATUS_SEND_ING;
				statusSendStep = 0;
				nSendStep = 0;
			}
		}
		else
		if(key == COMM_STAT_ERROR)
		{
//			flagBreak = TRUE;
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
		GUI_Delay(1);
	}
}
// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
