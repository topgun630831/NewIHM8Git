/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#define EXTERN extern
#include "stm32f4xx_hal.h"
#include "main.h"
#include "GuiData.h"

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
static void AcbMccbHwSetSend(void);
static void RecvHwSetDisp(void);
static void AcbMccbHwSetDisp(void);

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

//static int bEventSend;

static void AcbMccbHwSetSend(void)
{
	if(StatusSend() == STATUS_SEND_ING)
	{
		return;
	}
//	if(bEventSend == FALSE)
//	{
//		return;
//	}
//	g_modbusRxIndex = 0;
//	g_modbusRxDone = 0;
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
	{
		ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, HOLDING_REGISTER, ACB_HWSET_READ_ADDR, ACB_HWSET_READ_LEN);
	}
	else
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
	{
		ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, HOLDING_REGISTER, MCCB_HWSET_READ_ADDR, MCCB_HWSET_READ_LEN);
	}
	else {}
}

static void RecvHwSetDisp(void)
{
	char buf[INDEX_6][DEFAULT_BUF_SIZE];

	bEventSend = FALSE;
	if(g_functionCode == HOLDING_REGISTER)
	{
		uint16_t value;
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
		{
			uint8_t poll = (ModbusGetUint8_U(H_REGISTER_19));
			if(poll == INDEX_4)
			{
				(void)sprintf(buf[0], "4P");
			}
			else
			{
				(void)sprintf(buf[0], "3P");
			}
			value = ModbusGetUint16(H_REGISTER_39);
			(void)sprintf(buf[INDEX_1], "%4dV", value);
			value = ModbusGetUint16(H_REGISTER_24);
			(void)sprintf(buf[INDEX_2], "%4dA", value);
			value = ModbusGetUint16(H_REGISTER_41);
			(void)sprintf(buf[INDEX_3], "%4d", value);
			value = ModbusGetUint16(H_REGISTER_42) - 1;
			if(value > (SETUP_SPEED_MAX-1))
			{
				value = 0;
			}
			(void)sprintf(buf[INDEX_4], "%s", _acsetup_speed[value]);
			value = ModbusGetUint16(H_REGISTER_46) - 1;
			if(value > INDEX_1)
			{
				value = 0;
			}
			(void)sprintf(buf[INDEX_5], "%s", _aclocal_remote[SettingValue[SETUP_LANGUAGE]][value]);
		}
		else
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			uint8_t poll = (ModbusGetUint8_U(H_REGISTER_19));
			if(poll == INDEX_4)
			{
				(void)sprintf(buf[0], "4P");
			}
			else
			{
				(void)sprintf(buf[0], "3P");
			}
			value = ModbusGetUint16(H_REGISTER_28);
			(void)sprintf(buf[INDEX_1], "%dV", value);
			value = ModbusGetUint16(H_REGISTER_21);
//			(void)sprintf(buf[2], "%6.0fA", RationPlugTab[value]);
			(void)sprintf(buf[INDEX_2], "%dA", value);
			value = ModbusGetUint16(H_REGISTER_25);
			(void)sprintf(buf[INDEX_3], "%4d", value);
			value = ModbusGetUint16(H_REGISTER_26) - 1;
			if(value > (SETUP_SPEED_MAX-1))
			{
				value = 0;
			}
			(void)sprintf(buf[INDEX_4], "%s", _acsetup_speed[value]);
			value = ModbusGetUint16(H_REGISTER_29) - 1;
			if(value > 1)
			{
				value = 0;
			}
			(void)sprintf(buf[INDEX_5], "%s", _aclocal_remote[SettingValue[SETUP_LANGUAGE]][value]);
		}
		else {}
	}
	GUI_SetBkColor(COLOR_MAIN_BG);
	GUI_SetColor(COLOR_VALUE);
	GUI_RECT rect;
	rect.x0 = STARTX_VALUE;
	rect.y0 = STARTY_VALUE + INDEX_2;
	rect.x1 = (STARTX_VALUE + WIDTH_VALUE) - 1;
	rect.y1 = (STARTY_VALUE + HEIGHT_VALUE) - INDEX_4;

	(void)GUI_SetFont(&GUI_Font20B_ASCII);
	for(int i = 0 ; i < LINECOUNT_CONTENTS; i++)
	{
		if(i == INDEX_5)
		{
			LanguageSelect(FONT20B);
		}
		GUI_ClearRectEx(&rect);
		GUI_DispStringInRect(buf[i], &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
		rect.y0 += HEIGHT_VALUE;
		rect.y1 += HEIGHT_VALUE;
	}
}
static void AcbMccbHwSetDisp(void)
{
	GUI_SetBkColor(COLOR_MAIN_BG);
//	(void)GUI_SetFont(&GUI_Font20_ASCII);
	LanguageSelect(FONT20);

	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_LINE);

	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	GUI_DrawRect(STARTX_CONTENTS, STARTY_CONTENTS, (STARTX_CONTENTS + WIDTH_CONTENTS)-1, (STARTY_CONTENTS + HEIGHT_CONTENTS)-1);

	for(int i = 0; i < (LINECOUNT_CONTENTS-1); i++)
	{
		int y0 = STARTY_CONTENTS + ((i + 1) * HEIGHT_LABEL);
		GUI_DrawHLine(y0, STARTX_CONTENTS+INDEX_2, (STARTX_CONTENTS + WIDTH_CONTENTS)-1);
	}

	GUI_SetColor(COLOR_LABEL);
	GUI_RECT rect;
	rect.x0 = STARTX_LABEL;
	rect.y0 = STARTY_LABEL;
	rect.x1 = (STARTX_LABEL +  WIDTH_LABEL) - 1;
	rect.y1 = (STARTY_LABEL +  HEIGHT_LABEL)- 1;

	for(int i = 0 ; i < LINECOUNT_CONTENTS; i++)
	{
		GUI_DispStringInRect(_achwset_label_text[SettingValue[SETUP_LANGUAGE]][i], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);
		rect.y0 += HEIGHT_LABEL;
		rect.y1 += HEIGHT_LABEL;
	}
}

/*********************************************************************
*
*       Createstatus_window
*/
// PRQA S 1503 1
void AcbMccbHwSet(void)
{
	int flagBreak = FALSE;
	AcbMccbHwSetDisp();
	bEventSend = TRUE;
	nSendStep = 1;
	AcbMccbHwSetSend();
	while (1)
	{
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			nSendStep = 0;
			AcbMccbHwSetSend();
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			AcbMccbHwSetDisp();
			gCommOldStatus[gDeviceIndex] = -1;
		}
		else
		if(key == DATA_RECV)
		{
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				StatusRecv();
				AcbMccbHwSetSend();
			}
			else
			{
				RecvHwSetDisp();
				g_bRecvAllDone = TRUE;
//				(void)printf("g_bRecvAllDone=0\n");
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{
			(void)printf("COMM Error!! gStatusSendEnd=%d, statusSendStep=%d\n",gStatusSendEnd,statusSendStep);


			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				if(nSendStep < INDEX_1)
				{
					AcbMccbHwSetSend();
				}
				else
				{
					g_bRecvAllDone = TRUE;

//					(void)printf("All done!!!\n");
					gStatusSendEnd = STATUS_SEND_ING;
					statusSendStep = 0;
					nSendStep = 0;
				}
			}
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			(void)printf("key == COMM_STAT_ERROR\n");
			AcbMccbHwSetDisp();
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
		GUI_Delay(1);
	}
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
