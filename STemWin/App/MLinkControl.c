/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#define EXTERN extern
#include "stm32f4xx_hal.h"
#include "main.h"
#include "GuiData.h"

static void ControlSucceededMessage(void);
static void InitDisp(int pos, int cur_status, const char* msg);
static void MLinkControlValueDisp(int pos);
static void MLinkControlDisp(int pos, int flag);

static uint8_t ControlDoStatus[MLINK_DO_MAX];

// PRQA S 1505 1
void ControlErrorMessage(const char* message)
{
	int flagBreak = FALSE;
	GUI_RECT rect;

	GUI_SetBkColor(COLOR_MENU_NORMAL);

	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_MENU_SELECTED);

	GUI_ClearRect(POPUP_WINDOW_X0, POPUP_WINDOW_Y0, POPUP_WINDOW_X1, POPUP_WINDOW_Y1);
	GUI_DrawRect(POPUP_WINDOW_X0, POPUP_WINDOW_Y0, POPUP_WINDOW_X1, POPUP_WINDOW_Y1);

	GUI_SetColor(SELECTED_TEXT_COLOR);
	(void)GUI_SetFont(&GUI_Font32_ASCII);
	LanguageSelect(FONT32);
	rect.x0 = PASSWORD_MSG_X0;
	rect.y0 = PASSWORD_MSG_Y0;
	rect.x1 = PASSWORD_MSG_X1;
	rect.y1 = PASSWORD_MSG_Y1;
	GUI_DispStringInRect(message, &rect, GUI_TA_HCENTER | GUI_TA_VCENTER);

	rect.x0 = CONTROL_FAILED_BUTTON_X0;
	rect.y0 = CONTROL_FAILED_BUTTON_Y0;
	rect.x1 = (CONTROL_FAILED_BUTTON_X0 + CONTROL_BUTTON_WIDTH) - 1;
	rect.y1 = (CONTROL_FAILED_BUTTON_Y0 + CONTROL_BUTTON_HEIGHT) - 1;
	GUI_SetColor(COLOR_MENU_SELECTED);
	GUI_SetBkColor(COLOR_MENU_SELECTED);
	(void)GUI_SetFont(&GUI_Font24B_ASCII);
	GUI_FillRoundedRect(rect.x0, rect.y0, rect.x1, rect.y1, INDEX_2);
	GUI_SetColor(SELECTED_TEXT_COLOR);

	GUI_DispStringInRect(_accontrol_button_text[SettingValue[SETUP_LANGUAGE]][CONTROL_BUTTON_OK], &rect, GUI_TA_HCENTER | GUI_TA_VCENTER);

	while (1)
	{
		E_KEY key = GetKey();

		if(key == KEY_ENTER)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else {}

		if(flagBreak == TRUE)
		{
			break;
		}
	}
}

static void ControlSucceededMessage(void)
{
	int flagBreak = FALSE;
	GUI_RECT rect;

	GUI_SetBkColor(COLOR_MENU_NORMAL);

	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_MENU_SELECTED);

	GUI_ClearRect(POPUP_WINDOW_X0, POPUP_WINDOW_Y0, POPUP_WINDOW_X1, POPUP_WINDOW_Y1);
	GUI_DrawRect(POPUP_WINDOW_X0, POPUP_WINDOW_Y0, POPUP_WINDOW_X1, POPUP_WINDOW_Y1);

	GUI_SetColor(SELECTED_TEXT_COLOR);
	LanguageSelect(FONT32);
	rect.x0 = POPUP_WINDOW_X0;
	rect.y0 = SUCCEED_MSG_Y0;
	rect.x1 = POPUP_WINDOW_X1;
	rect.y1 = SUCCEED_MSG_Y1;
	GUI_DispStringInRect(_accontrol_succeeded_text[SettingValue[SETUP_LANGUAGE]], &rect, GUI_TA_HCENTER | GUI_TA_VCENTER);

	GUI_DrawBitmap(&bmicon_succeeded, SUCCEED_IMG_X, SUCCEED_IMG_Y);

	int count = MESSAGE_AUTO_CLOSE_TIME;
	while (1)
	{
		E_KEY key = GetKey();

		if(key == SECOND_TIMER)
		{
			if(--count <= 0)
			{
			flagBreak = TRUE;
			}
		}
		else
		if(key == KEY_ENTER)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else {}

		if(flagBreak == TRUE)
		{
			break;
		}
	}
}

// PRQA S 1505 1
void PasswordAllDisp(char *password)
{
	GUI_RECT rect;
	GUI_SetBkColor(COLOR_MENU_NORMAL);
	GUI_ClearRect(PASSWORD_INTPUT_DIGIT_X,
				  PASSWORD_INTPUT_DIGIT_UP_Y0,
				  (PASSWORD_INTPUT_DIGIT_X + (PASSWORD_INTPUT_DIGIT_WIDTH * CONTROL_PASSWORD_DIGIT)) - 1,
				  PASSWORD_INTPUT_DIGIT_DOWN_Y1);

	rect.x0 = PASSWORD_INTPUT_DIGIT_X;
	rect.y0 = PASSWORD_INTPUT_Y0;
	rect.x1 = (PASSWORD_INTPUT_DIGIT_X + PASSWORD_INTPUT_DIGIT_WIDTH) - 1;
	rect.y1 = PASSWORD_INTPUT_Y1;
	(void)GUI_SetFont(&GUI_Font32B_ASCII);
	char buf[PASSWORD_INPUT_BUF_SIZE];
	for(int i = 0; i < CONTROL_PASSWORD_DIGIT; i++)
	{
		buf[0] = password[i];
		buf[1] = 0;
		GUI_DispStringInRect(buf, &rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
		rect.x0 += PASSWORD_INTPUT_DIGIT_WIDTH;
		rect.x1 += PASSWORD_INTPUT_DIGIT_WIDTH;
	}
}

// PRQA S 1505 1
void PasswordDisp(int pos, char password)
{
	GUI_RECT rect;
	GUI_SetBkColor(COLOR_MENU_NORMAL);
	GUI_ClearRect(PASSWORD_INTPUT_DIGIT_X,
				  PASSWORD_INTPUT_DIGIT_UP_Y0,
				  (PASSWORD_INTPUT_DIGIT_X + (PASSWORD_INTPUT_DIGIT_WIDTH * CONTROL_PASSWORD_DIGIT)) - 1,
				  PASSWORD_INTPUT_DIGIT_DOWN_Y1);

	rect.x0 = PASSWORD_INTPUT_DIGIT_X;
	rect.y0 = PASSWORD_INTPUT_Y0;
	rect.x1 = (PASSWORD_INTPUT_DIGIT_X + PASSWORD_INTPUT_DIGIT_WIDTH) - 1;
	rect.y1 = PASSWORD_INTPUT_Y1;
	(void)GUI_SetFont(&GUI_Font32B_ASCII);
	for(int i = 0; i < CONTROL_PASSWORD_DIGIT; i++)
	{
		GUI_DispStringInRect(_acpassword_input_text, &rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
		rect.x0 += PASSWORD_INTPUT_DIGIT_WIDTH;
		rect.x1 += PASSWORD_INTPUT_DIGIT_WIDTH;
	}

	if(pos >= CONTROL_PASSWORD_DIGIT)
	{
		return;
	}

	int x = PASSWORD_INTPUT_DIGIT_X + (PASSWORD_INTPUT_DIGIT_WIDTH * pos);
	(void)GUI_BMP_Draw(_acUp, x, PASSWORD_INTPUT_DIGIT_UP_Y0);
	(void)GUI_BMP_Draw(_acDown, x, PASSWORD_INTPUT_DIGIT_DOWN_Y0);

	char buf[PASSWORD_INPUT_BUF_SIZE];
	buf[0] = password;
	buf[1] = 0;
	rect.x0 = PASSWORD_INTPUT_DIGIT_X + (PASSWORD_INTPUT_DIGIT_WIDTH * pos);
	rect.y0 = PASSWORD_INTPUT_Y0;
	rect.x1 = (PASSWORD_INTPUT_DIGIT_X  + (PASSWORD_INTPUT_DIGIT_WIDTH * pos) + PASSWORD_INTPUT_DIGIT_WIDTH) - 1;
	rect.y1 = PASSWORD_INTPUT_Y1;
	GUI_SetColor(SELECTED_TEXT_COLOR);
	GUI_SetBkColor(GUI_BLACK);
	GUI_ClearRect(rect.x0, rect.y0, rect.x1, rect.y1);
	GUI_DispStringInRect(buf, &rect, GUI_TA_HCENTER | GUI_TA_VCENTER);

}

// PRQA S 1505 1
void MLinkButtonDisp(int button)
{
	GUI_RECT rect;
	rect.x0 = CONTROL_BUTTON_X;
	rect.y0 = CONTROL_BUTTON_Y;
	rect.x1 = (CONTROL_BUTTON_X + CONTROL_BUTTON_WIDTH) - 1;
	rect.y1 = (CONTROL_BUTTON_Y + CONTROL_BUTTON_HEIGHT) - 1;
	for(int i = 0; i < CONTROL_BUTTON_NOSELECT; i++)
	{
		if(i == button)
		{
			GUI_SetColor(COLOR_MENU_SELECTED);
			GUI_SetBkColor(COLOR_MENU_SELECTED);
		}
		else
		{
			GUI_SetColor(CONTROL_NORMAL_BUTTON);
			GUI_SetBkColor(CONTROL_NORMAL_BUTTON);
		}
		LanguageSelect(FONT24B);
		GUI_FillRoundedRect(rect.x0, rect.y0, rect.x1, rect.y1, INDEX_2);
		if(i == button)
		{
			GUI_SetColor(SELECTED_TEXT_COLOR);
		}
		else
		{
			GUI_SetColor(CONTROL_NORMAL_COLOR);
		}

		GUI_DispStringInRect(_accontrol_button_text[SettingValue[SETUP_LANGUAGE]][i], &rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
		rect.x0 += CONTROL_BUTTON_WIDTH + CONTROL_BTTON_DISTANCE;
		rect.x1 += CONTROL_BUTTON_WIDTH + CONTROL_BTTON_DISTANCE;
	}
}

static void InitDisp(int pos, int cur_status, const char* msg)
{
	GUI_RECT rect;

	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_MENU_SELECTED);
	GUI_SetBkColor(COLOR_MENU_NORMAL);

	GUI_ClearRect(POPUP_WINDOW_X0, POPUP_WINDOW_Y0, POPUP_WINDOW_X1, POPUP_WINDOW_Y1);
	GUI_DrawRect(POPUP_WINDOW_X0, POPUP_WINDOW_Y0, POPUP_WINDOW_X1, POPUP_WINDOW_Y1);

	GUI_SetColor(SELECTED_TEXT_COLOR);
	LanguageSelect(FONT24);
	rect.x0 = CONTROL_MSG_X0;
	rect.y0 = CONTROL_MSG_Y0;
	rect.x1 = CONTROL_MSG_X1;
	rect.y1 = CONTROL_MSG_Y1;
	GUI_DispStringInRect(msg, &rect, GUI_TA_HCENTER | GUI_TA_VCENTER);

	MLinkButtonDisp(CONTROL_BUTTON_NOSELECT);
}

extern uint8_t KeyChanged[KEY_MAX];

// PRQA S 1505 1
void ControlSet(const int pos, const int offset, const int cur_status, const char* msg, const uint8_t nSBO)
{
	int flagBreak = FALSE;
	int nPos = 0;
	char password[CONTROL_PASSWORD_DIGIT+1];

	(void)sprintf(password, "0000");
	InitDisp(pos, cur_status, msg);
	PasswordDisp(nPos, password[nPos]);

	int SetupKeyCount = 0;
	while (1)
	{
		E_KEY key = GetKey();

		if(key == KEY_SETUP)
		{
			if(++SetupKeyCount >= 5)
			{
				sprintf(password, "%04d", SettingValue[SETUP_PASSWORD]);
				PasswordAllDisp(password);
			}
		}
		else
		if(key == KEY_UP)
		{
			SetupKeyCount = 0;
			if(nPos < CONTROL_PASSWORD_DIGIT)
			{
				if(password[nPos] < '9')
				{
					password[nPos]++;
				}
				else
				{
					password[nPos] = '0';
				}
				PasswordDisp(nPos, password[nPos]);
			}
			else
			if(nPos == (CONTROL_PASSWORD_DIGIT + 1))
			{
				MLinkButtonDisp(CONTROL_BUTTON_OK);
				nPos = CONTROL_PASSWORD_DIGIT;
			}
			else {}
		}
		else
		if(key == KEY_DOWN)
		{
			SetupKeyCount = 0;
			if(nPos < CONTROL_PASSWORD_DIGIT)
			{
				if(password[nPos] > '0')
				{
					password[nPos]--;
				}
				else
				{
					password[nPos] = '9';
				}
				PasswordDisp(nPos, password[nPos]);
			}
			else
			if(nPos == CONTROL_PASSWORD_DIGIT)
			{
				MLinkButtonDisp(CONTROL_BUTTON_CANCEL);
				nPos = CONTROL_PASSWORD_DIGIT + 1;
			}
			else {}
		}
		else
		if(key == KEY_ENTER)
		{
			SetupKeyCount = 0;
			if(nPos < CONTROL_PASSWORD_DIGIT)
			{
				nPos++;
				PasswordDisp(nPos, password[nPos]);
				if(nPos == CONTROL_PASSWORD_DIGIT)
				{
					MLinkButtonDisp(CONTROL_BUTTON_OK);
				}
			}
			else
			if(nPos == CONTROL_PASSWORD_DIGIT)	// OK 이면
			{
				uint16_t  iPassword = atoi(password);
				if(iPassword != SettingValue[SETUP_PASSWORD])
				{
				   if(QuestionMessage() == FALSE)
				   {
						flagBreak = TRUE;
				   }
					nPos = 0;
					InitDisp(pos, cur_status, msg);
					PasswordDisp(nPos, password[nPos]);
					MLinkButtonDisp(CONTROL_BUTTON_NOSELECT);
				}
				else
				{
					uint8_t controlStatus = ModbusControl(ConnectSetting[gDeviceIndex].Address, offset, pos, cur_status, nSBO);
					if(controlStatus == CONTROL_OK)
					{
						ControlSucceededMessage();
					}
					else
					{
						ControlErrorMessage(_accontrol_failed_text[SettingValue[SETUP_LANGUAGE]]);
					}
					flagBreak = TRUE;
				}
			}
			else
			if(nPos == (CONTROL_PASSWORD_DIGIT + 1))	// Cancel 이면
			{
				flagBreak = TRUE;
			}
			else {}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else {}

		if(flagBreak == TRUE)
		{
			break;
		}
	}
}

static void MLinkControlValueDisp(int pos)
{
	GUI_SetBkColor(COLOR_MAIN_BG);

	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_LINE);

	GUI_RECT rect;
	rect.x0 = STARTX_CONTENTS;
	rect.x1 = (STARTX_CONTENTS + INFO_MENU_WIDTH) - 1;
	rect.y0 = MLINK_CONTROL_STARTY;
	rect.y1 = (MLINK_CONTROL_STARTY + MLINK_CONTROL_HEIGHT) - 1;

	GUI_RECT rectDescLocal;
	rectDescLocal.x0 = MLINK_CONTROL_DESC_X0;
	rectDescLocal.x1 = (MLINK_CONTROL_DESC_X0 + MLINK_CONTROL_DESC_WIDTH) - 1;
	rectDescLocal.y0 = MLINK_CONTROL_STARTY;
	rectDescLocal.y1 = (MLINK_CONTROL_STARTY + MLINK_CONTROL_HEIGHT) - 1;

	GUI_RECT rectOn;
	rectOn.x0 = MLINK_CONTROL_ON_X0;
	rectOn.x1 = (MLINK_CONTROL_ON_X0 + MLINK_CONTROL_WIDTH) - 1;
	rectOn.y0 = MLINK_CONTROL_ONOFF_Y0;
	rectOn.y1 = (MLINK_CONTROL_ONOFF_Y0 + MLINK_CONTROL_ONOFF_HEIGHT) - 1;

	GUI_RECT rectOff;
	rectOff.x0 = MLINK_CONTROL_OFF_X0;
	rectOff.x1 = (MLINK_CONTROL_OFF_X0 + MLINK_CONTROL_WIDTH) - 1;
	rectOff.y0 = MLINK_CONTROL_ONOFF_Y0;
	rectOff.y1 = (MLINK_CONTROL_ONOFF_Y0 + MLINK_CONTROL_ONOFF_HEIGHT) - 1;

	for(int i = 0; i < MLINK_CONTROL_ITEM_COUNT; i++)
	{
		if(((mLinkMode[gDeviceIndex] != INDEX_4) && (mLinkMode[gDeviceIndex] != INDEX_5)) && (i == pos))
		{
			GUI_SetColor(COLOR_MENU_SELECTED);
		}
		else
		{
			GUI_SetColor(COLOR_MENU_NORMAL);
		}
		GUI_FillRectEx(&rect);

		GUI_COLOR onTextColor;
		GUI_COLOR offTextColor;
		GUI_COLOR onFillColor;
		GUI_COLOR offFillColor;

		if(((mLinkMode[gDeviceIndex] == INDEX_4) || (mLinkMode[gDeviceIndex] == INDEX_5)) || ((mLinkMode[gDeviceIndex] == INDEX_3) && (i >= INDEX_2)))
		{
			LanguageSelect(FONT24);
			GUI_SetColor(COLOR_DO_DISBLE);
			GUI_SetBkColor(COLOR_MENU_NORMAL);
		}
		else
		if(i == pos)
		{
			LanguageSelect(FONT24B);
			GUI_SetColor(SELECTED_TEXT_COLOR);
			GUI_SetBkColor(COLOR_MENU_SELECTED);
		}
		else
		{
			LanguageSelect(FONT24);
			GUI_SetColor(UNSELECTED_TEXT_COLOR);
			GUI_SetBkColor(COLOR_MENU_NORMAL);
		}
		GUI_DispStringInRect(_acmlink_control_text[i], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);

		if(((mLinkMode[gDeviceIndex] == INDEX_4) || (mLinkMode[gDeviceIndex] == INDEX_5)) || ((mLinkMode[gDeviceIndex] == INDEX_3) && (i >= INDEX_2)))
		{
			onTextColor = ONOFF_OFF_TEXT_COLOR;
			offTextColor = ONOFF_OFF_TEXT_COLOR;
			onFillColor = ON_OFF_BOX_COLOR;
			offFillColor = OFF_OFF_BOX_COLOR;
		}
		else
		if(doStatus[gDeviceIndex][i] == ON)
		{
			onTextColor = ONOFF_ON_TEXT_COLOR;
			offTextColor = ONOFF_OFF_TEXT_COLOR;
			onFillColor = ON_ON_BOX_COLOR;
			offFillColor = OFF_OFF_BOX_COLOR;
		}
		else
		{
			onTextColor = ONOFF_OFF_TEXT_COLOR;
			offTextColor = ONOFF_ON_TEXT_COLOR;
			onFillColor = ON_OFF_BOX_COLOR;
			offFillColor = OFF_ON_BOX_COLOR;
		}
		LanguageSelect(FONT24B);
		GUI_SetColor(onFillColor);
		GUI_FillRectEx(&rectOn);
		GUI_SetBkColor(onFillColor);
		GUI_SetColor(onTextColor);
		GUI_DispStringInRect(_aconoff_text[SettingValue[SETUP_LANGUAGE]][ON], &rectOn, GUI_TA_HCENTER | GUI_TA_VCENTER);

		GUI_SetColor(offFillColor);
		GUI_FillRectEx(&rectOff);
		GUI_SetBkColor(offFillColor);
		GUI_SetColor(offTextColor);
		GUI_DispStringInRect(_aconoff_text[SettingValue[SETUP_LANGUAGE]][OFF], &rectOff, GUI_TA_HCENTER | GUI_TA_VCENTER);

		GUI_SetColor(COLOR_MAIN_BG);
		GUI_DrawRectEx(&rectOn);
		GUI_DrawRectEx(&rectOff);


		rect.y0 += MLINK_CONTROL_ONOFF_DISTANCE;
		rect.y1 += MLINK_CONTROL_ONOFF_DISTANCE;

		rectDescLocal.y0 += MLINK_CONTROL_ONOFF_DISTANCE;
		rectDescLocal.y1 += MLINK_CONTROL_ONOFF_DISTANCE;

		rectOn.y0 += MLINK_CONTROL_ONOFF_DISTANCE;
		rectOn.y1 += MLINK_CONTROL_ONOFF_DISTANCE;

		rectOff.y0 += MLINK_CONTROL_ONOFF_DISTANCE;
		rectOff.y1 += MLINK_CONTROL_ONOFF_DISTANCE;

	}
	for(int i = 0; i < MLINK_DO_MAX; i++)
	{
		ControlDoStatus[i] = doStatus[gDeviceIndex][i];
	}
}

static void MLinkControlDisp(int pos, int flag)
{
	GUI_SetBkColor(COLOR_MAIN_BG);
	if(flag)
	{
		GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	}

	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_LINE);

	GUI_RECT rect;
	rect.x0 = STARTX_CONTENTS;
	rect.x1 = (STARTX_CONTENTS + INFO_MENU_WIDTH) - 1;
	rect.y0 = MLINK_CONTROL_STARTY;
	rect.y1 = (MLINK_CONTROL_STARTY + MLINK_CONTROL_HEIGHT) - 1;

	GUI_RECT rectDescLocal;
	rectDescLocal.x0 = MLINK_CONTROL_DESC_X0;
	rectDescLocal.x1 = (MLINK_CONTROL_DESC_X0 + MLINK_CONTROL_DESC_WIDTH) - 1;
	rectDescLocal.y0 = MLINK_CONTROL_STARTY;
	rectDescLocal.y1 = (MLINK_CONTROL_STARTY + MLINK_CONTROL_HEIGHT) - 1;

	GUI_RECT rectOn;
	rectOn.x0 = MLINK_CONTROL_ON_X0;
	rectOn.x1 = (MLINK_CONTROL_ON_X0 + MLINK_CONTROL_WIDTH) - 1;
	rectOn.y0 = MLINK_CONTROL_ONOFF_Y0;
	rectOn.y1 = (MLINK_CONTROL_ONOFF_Y0 + MLINK_CONTROL_ONOFF_HEIGHT) - 1;

	GUI_RECT rectOff;
	rectOff.x0 = MLINK_CONTROL_OFF_X0;
	rectOff.x1 = (MLINK_CONTROL_OFF_X0 + MLINK_CONTROL_WIDTH) - 1;
	rectOff.y0 = MLINK_CONTROL_ONOFF_Y0;
	rectOff.y1 = (MLINK_CONTROL_ONOFF_Y0 + MLINK_CONTROL_ONOFF_HEIGHT) - 1;

	for(int i = 0; i < MLINK_CONTROL_ITEM_COUNT; i++)
	{
//		if((mLinkMode[gDeviceIndex] != 4 && mLinkMode[gDeviceIndex] != 5) && i == pos)
//			GUI_SetColor(COLOR_MENU_SELECTED);
//		else
			GUI_SetColor(COLOR_MENU_NORMAL);
		GUI_FillRectEx(&rect);

		GUI_COLOR onTextColor;
		GUI_COLOR offTextColor;
		GUI_COLOR onFillColor;
		GUI_COLOR offFillColor;

//		if((mLinkMode[gDeviceIndex] == 4 || mLinkMode[gDeviceIndex] == 5) || (mLinkMode[gDeviceIndex] == 3 && i >= 2))
		{
//			(void)GUI_SetFont(&GUI_Font24_ASCII);
			LanguageSelect(FONT24);
			GUI_SetColor(COLOR_DO_DISBLE);
			GUI_SetBkColor(COLOR_MENU_NORMAL);
		}
//		else
//		if(i == pos)
//		{
//			(void)GUI_SetFont(&GUI_Font24B_ASCII);
//			GUI_SetColor(SELECTED_TEXT_COLOR);
//			GUI_SetBkColor(COLOR_MENU_SELECTED);
//		}
//		else
//		{
//			(void)GUI_SetFont(&GUI_Font24_ASCII);
//			GUI_SetColor(UNSELECTED_TEXT_COLOR);
//			GUI_SetBkColor(COLOR_MENU_NORMAL);
//		}
		GUI_DispStringInRect(_acmlink_control_text[i], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);

//		if((mLinkMode[gDeviceIndex] == 4 || mLinkMode[gDeviceIndex] == 5) || (mLinkMode[gDeviceIndex] == 3 && i >= 2))
		{
			onTextColor = ONOFF_OFF_TEXT_COLOR;
			offTextColor = ONOFF_OFF_TEXT_COLOR;
			onFillColor = ON_OFF_BOX_COLOR;
			offFillColor = OFF_OFF_BOX_COLOR;
		}
//		else
//		if(oStatus[gDeviceIndex][i] == ON)
//		{
//			onTextColor = ONOFF_ON_TEXT_COLOR;
//			offTextColor = ONOFF_OFF_TEXT_COLOR;
//			onFillColor = ON_ON_BOX_COLOR;
//			offFillColor = OFF_OFF_BOX_COLOR;
//		}
//		else
//		{
//			onTextColor = ONOFF_OFF_TEXT_COLOR;
//			offTextColor = ONOFF_ON_TEXT_COLOR;
//			onFillColor = ON_OFF_BOX_COLOR;
//			offFillColor = OFF_ON_BOX_COLOR;
//		}
		GUI_SetColor(onFillColor);
		GUI_FillRectEx(&rectOn);
		GUI_SetBkColor(onFillColor);
		GUI_SetColor(onTextColor);
		GUI_DispStringInRect(_aconoff_text[SettingValue[SETUP_LANGUAGE]][ON], &rectOn, GUI_TA_HCENTER | GUI_TA_VCENTER);

		GUI_SetColor(offFillColor);
		GUI_FillRectEx(&rectOff);
		GUI_SetBkColor(offFillColor);
		GUI_SetColor(offTextColor);
		GUI_DispStringInRect(_aconoff_text[SettingValue[SETUP_LANGUAGE]][OFF], &rectOff, GUI_TA_HCENTER | GUI_TA_VCENTER);

		GUI_SetColor(COLOR_MAIN_BG);
		GUI_DrawRectEx(&rectOn);
		GUI_DrawRectEx(&rectOff);


		rect.y0 += MLINK_CONTROL_ONOFF_DISTANCE;
		rect.y1 += MLINK_CONTROL_ONOFF_DISTANCE;

		rectDescLocal.y0 += MLINK_CONTROL_ONOFF_DISTANCE;
		rectDescLocal.y1 += MLINK_CONTROL_ONOFF_DISTANCE;

		rectOn.y0 += MLINK_CONTROL_ONOFF_DISTANCE;
		rectOn.y1 += MLINK_CONTROL_ONOFF_DISTANCE;

		rectOff.y0 += MLINK_CONTROL_ONOFF_DISTANCE;
		rectOff.y1 += MLINK_CONTROL_ONOFF_DISTANCE;

	}
}


/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       Createstatus_window
*/

// PRQA S 1503 1
void MLinkControl(void)
{
	int nPointPos = 0;
//	int bFirst = TRUE;
	uint8_t nSBO = 0;

	uint16_t mOldLinkMode = mLinkMode[gDeviceIndex];
	MLinkControlDisp(nPointPos, 1);

	nSendStep = 0;
//	bControlSend = 1;
//	DoStatusSend();

	int nPointMax;
	if(mLinkMode[gDeviceIndex] == INDEX_3)
	{
		nPointMax =INDEX_2;
	}
	else
	if((mLinkMode[gDeviceIndex] == INDEX_4) || (mLinkMode[gDeviceIndex] == INDEX_5))
	{
		nPointMax = 0;
	}
	else
	{
		nPointMax = MLINK_CONTROL_ITEM_COUNT;
	}
	int commStat = gCommStatus[gDeviceIndex];
	if(gCommStatus[gDeviceIndex] == COMM_OK)
	{
		MLinkControlValueDisp(nPointPos);
	}
	ReadyToSend();
	(void)StatusSend();
	while (1)
    {
		E_KEY key = GetKey();

		if(key == SECOND_TIMER)
		{
			uint8_t changed = 0;
			for(int i = 0; i < MLINK_DO_MAX; i++)
			{
				if(ControlDoStatus[i] != doStatus[gDeviceIndex][i])
				{
					changed = 1;
				}
			}
			nSBO = mLinkSBO[gDeviceIndex];
			if(mLinkMode[gDeviceIndex] != mOldLinkMode)
			{
				if(mLinkMode[gDeviceIndex] == INDEX_3)
				{
					nPointMax = INDEX_2;
				}
				else
				if((mLinkMode[gDeviceIndex] == INDEX_4) || (mLinkMode[gDeviceIndex] == INDEX_5))
				{
					nPointMax = 0;
				}
				else
				{
					nPointMax = MLINK_CONTROL_ITEM_COUNT;
				}
				if((mLinkMode[gDeviceIndex] == INDEX_3) && (nPointPos >= INDEX_2))
				{
					nPointPos = 1;
				}
				changed = 1;
				mOldLinkMode = mLinkMode[gDeviceIndex];
			}
			if(changed == 1)
			{
				MLinkControlValueDisp(nPointPos);
			}
		}
		else
		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			nSendStep = 0;
			statusSendStep = 0;
			(void)StatusSend();
		}
		else
		if(key == KEY_SETUP)
		{
			(void)Setup();
			MLinkControlDisp(nPointPos, 1);
			MLinkControlValueDisp(nPointPos);
			gCommOldStatus[gDeviceIndex] = -1;
		}
		else
		if(key == KEY_UP)
		{
			if(nPointMax == 0)
			{
				continue;
			}
			if(nPointPos > 0)
			{
				nPointPos--;
			}
			else
			{
				nPointPos = nPointMax - 1;
			}
			MLinkControlDisp(nPointPos, 0);
			MLinkControlValueDisp(nPointPos);
		}
		else
		if(key == KEY_DOWN)
		{
			if(nPointMax == 0)
			{
				continue;
			}
			if(nPointPos < (nPointMax-1))
			{
				nPointPos++;
			}
			else
			{
				nPointPos = 0;
			}
			MLinkControlDisp(nPointPos, 0);
			MLinkControlValueDisp(nPointPos);
		}
		else
		if(key == KEY_ENTER)
		{
			if(nPointMax == 0)
			{
				continue;
			}
			if(mLinkMode[gDeviceIndex] >= INDEX_4)
			{
				ControlErrorMessage(_acmode_invalid_text[SettingValue[SETUP_LANGUAGE]]);
				DispMLinkStatus();
				MLinkControlDisp(nPointPos, 1);
			}
			else
			{
				uint16_t address;
				uint8_t status = doStatus[gDeviceIndex][nPointPos];
				uint8_t dostatus = status;
				int nPoint = nPointPos;
				if((mLinkMode[gDeviceIndex] == 1) )
				{
					nPoint = 0;		// Index 증가 없음
					if(nSBO == 1)
					{
						address = MLINK_MODE1_SBO_START_ADDR;
						address += (nPointPos * INDEX_4);
						if(status == ON)
						{
							address += INDEX_2;
						}
					}
					else
					{
						address = MLINK_MODE1_NO_SBO_START_ADDR;
						address += (nPointPos * INDEX_2);
						if(status == ON)
						{
							address ++;
						}
					}
					status = OFF;			// 무조건 On으로 제어 -> Index 증가 없음
				}
				else
				if(mLinkMode[gDeviceIndex] == INDEX_2)
				{
					nPoint = 0;		// Index 증가 없음
					if(nSBO == 1)
					{
						address = MLINK_MODE23_SBO_START_ADDR;
						if(nPointPos >= INDEX_2)
						{
							address += INDEX_4;
						}
						if(status == ON)
						{
							address += INDEX_2;
						}
					}
					else
					{
						address = MLINK_MODE23_NO_SBO_START_ADDR;
						if(nPointPos >= INDEX_2)
						{
							address += INDEX_2;
						}
						if(status == ON)
						{
							address++;
						}
					}
					status = OFF;			// 무조건 On으로 제어 -> Index 증가 없음
				}
				else
				if(mLinkMode[gDeviceIndex] == INDEX_3)
				{
					nPoint = 0;		// Index 증가 없음
					if(nSBO == 1)
					{
						address = MLINK_MODE23_SBO_START_ADDR;
						if(nPointPos == INDEX_1)
						{
							address += INDEX_2;
						}
						if(status == ON)
						{
							address += INDEX_2;
						}
					}
					else
					{
						address = MLINK_MODE23_NO_SBO_START_ADDR;
						if(nPointPos == INDEX_1)
						{
							address += INDEX_2;
						}
						if(status == ON)
						{
							address++;
						}
					}
					status = OFF;			// 무조건 On으로 제어 -> Index 증가 없음
				}
				else {}
				ControlSet(nPoint, address, status, _accontrol_confirm_text[SettingValue[SETUP_LANGUAGE]][dostatus], nSBO);
				DispMLinkStatus();
				gCommOldStatus[gDeviceIndex] = -1;
				MLinkControlDisp(nPointPos, 1);
				MLinkControlValueDisp(nPointPos);
				g_bRecvAllDone = TRUE;
				nSendStep = 0;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
			}
			CommTimerInit();
		}
		else
		if(key == DATA_RECV)
		{
			if(commStat == COMM_ERROR)
			{
				commStat = COMM_OK;
				MLinkControlValueDisp(nPointPos);
			}
			StatusRecv();
			nSendStep = 0;
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				(void)StatusSend();
			}
			else
			{
				g_bRecvAllDone = TRUE;
				nSendStep = 0;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			break;
		}
		else
		if(key == KEY_COMM_ERROR)
		{
			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
//			else
//			{
//				(void)StatusSend();
//			}
			else
			{
					g_bRecvAllDone = TRUE;
					(void)printf("All done!!!\n");
					gStatusSendEnd = STATUS_SEND_ING;
					statusSendStep = 0;
					nSendStep = 0;
			}
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			commStat = COMM_ERROR;
			MLinkControlDisp(nPointPos, 1);
		}
		else {}
	}
}

/*************************** End of file ****************************/
