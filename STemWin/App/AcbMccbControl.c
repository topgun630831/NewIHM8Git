/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/


#define EXTERN extern
#include "stm32f4xx_hal.h"
#include "main.h"
#include "GuiData.h"

//const uint16_t IoStatus_Offset[IO_STATUS_COUNT] = {
//	0,
//	1,
//	0,
//	0,
//	0,
//	1,
//	1,
//	1
//};
//
//const uint16_t IoStatus_bit[IO_STATUS_COUNT] = {
//	0x8000,
//	0x8000,
//	0x1000,
//	0x0200,
//	0x4000,
//	0x0001,
//	0x0002,
//	0x0004
//};
//

static uint8_t AcbMccbcbStatus;
static uint8_t bUpdateFirst;

static void AcbMccbControlSend(void);
static int ControlCheck(void);
static void AcbMccbIoValueDisp(void);
static void AcbMccbControlDisp(void);
static void StuIo(void);

static void TrioTempValueDisp(void);
static void TrioTempSend(void);
static void TrioTempDisp(void);
static void TrioTemp(void);

static GUI_COLOR colorOffFillColor[OPEN_CLOSE_TRIP] = {
	CB_OPEN_OFF_COLOR,
	CB_CLOSE_OFF_COLOR,
	TRIP_OFF_COLOR
};

static GUI_COLOR colorOffTextColor[OPEN_CLOSE_TRIP] = {
	CB_OPEN_OFF_TEXT_COLOR,
	CB_CLOSE_OFF_TEXT_COLOR,
	TRIP_OFF_TEXT_COLOR
};

static void AcbMccbControlSend(void)
{
	if(StatusSend() == STATUS_SEND_ING)
	{
		return;
	}
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
	{
		ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, ACB_CONTROL_READ_ADDR, ACB_CONTROL_READ_LEN);	// 30183 ~ 30208
	}
	else
	{
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, MCCB_CONTROL_READ_ADDR, MCCB_CONTROL_READ_LEN);	// 30204 ~ 30208
		}
	}
}

static uint8_t nDoSetting[CB_STATUS_DO_MAX];
static uint8_t nRemote;
static uint8_t nTrio;
static int ControlCheck(void)
{
	int ret = FALSE;
	uint16_t comp=CB_STATUS_OUTPUT_DEFAULT;

	if(AcbMccbcbStatus == CB_STATUS_INPUT_OPEN)	// Open
	{
		comp = CB_STATUS_OUTPUT_CLOSE;	// CB Close
	}
	else
	if(AcbMccbcbStatus == CB_STATUS_INPUT_CLOSE)	// Close
	{
		comp = CB_STATUS_OUTPUT_OPEN;	// CB Open
	}
	else
	if(AcbMccbcbStatus == CB_STATUS_INPUT_FAULT)	// Fault
	{
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			ret = TRUE;
		}
	}
	else {}
	(void)printf("===============================\ncbStatus=%d, com=%d, nTrio=%d\n", AcbMccbcbStatus, comp, nTrio);
	for(int i = 0; i < CB_STATUS_DO_MAX; i++)
	{
		(void)printf("i=%d, nDoSetting=%d\n", i, nDoSetting[i]);
		if(nDoSetting[i] == comp)
		{
			ret = TRUE;
		}
	}
	return ret;
}

static void AcbMccbIoValueDisp(void)
{
	uint16_t nDioStatus[DIO_STATUS_MAX];
	static const uint16_t IoStatus_Offset[IO_STATUS_COUNT] =
	{
			0,
			1,
			0,
			1,
			1,
			1
	};
	static const uint16_t IoStatus_bit[IO_STATUS_COUNT] =
	{
			0x8000,
			0x8000,
			0x4000,
			0x0001,
			0x0002,
			0x0004
	};
	static GUI_COLOR colorOnFillColor[OPEN_CLOSE_TRIP] =
	{
			CB_OPEN_ON_COLOR,
			CB_CLOSE_ON_COLOR,
			TRIP_ON_COLOR
	};

	nDioStatus[INDEX_0] = ModbusGetUint16(I_REGISTER_207);
	nDioStatus[INDEX_1] = ModbusGetUint16(I_REGISTER_208);
	if(ModbusGetUint16(I_REGISTER_206) & CB_REMOTE_MASK)
	{
		nRemote = TRUE;
	}
	else
	{
		nRemote = FALSE;
	}
	nDoSetting[INDEX_0] = ModbusGetUint8_U(I_REGISTER_204);
	nDoSetting[INDEX_1] = ModbusGetUint8_L(I_REGISTER_204);
	nDoSetting[INDEX_2] = ModbusGetUint8_U(I_REGISTER_205);

	nTrio = INDEX_0;

//	(void)GUI_SetFont(&GUI_Font20B_ASCII);
	LanguageSelect(FONT20B);
	GUI_SetColor(GUI_BLACK);

	uint8_t status = (ModbusGetUint16(I_REGISTER_208) >> CB_STATUS_SHIFT) & CB_STATUS_MASK;		// 0x00: Open(ACB OCR 사용) 0x01: Close(ACB OCR 사용) 0x02: Trip 0x03: Intermediate
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
	{
		nTrio = (ModbusGetUint16(I_REGISTER_183) >> CB_TRIO_SHIFT) & CB_TRIO_MASK;	// TRIO 결선 000b: TRIO Only 001b: TRIO+ACB_OCR 010b: TRIO+MCCB 111b: ACB OCR Only
		(void)printf("nTrio=%d\n", nTrio);
		if(nTrio != INDEX_7)		// ACB Only가 아니면
		{
			status = (ModbusGetUint16(I_REGISTER_184) >> CB_ACB_TRIO_SHIFT) & CB_ACB_TRIO_MASK;
			nDoSetting[INDEX_0] = INDEX_2;		//CB CLose
			nDoSetting[INDEX_1] = INDEX_3;		// CB Open

			if(ModbusGetUint16(I_REGISTER_183) & CB_ACB_TRIO_REMOTE_MASK)
			{
				nRemote = TRUE;
			}
			else
			{
				nRemote = FALSE;
			}
		}
	}
	else
	{
		nDoSetting[INDEX_2] = 0;
	}
	if((bUpdateFirst == TRUE) || (AcbMccbcbStatus != status))
	{
		AcbMccbcbStatus = status;
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			GUI_FillRectEx(&rectMccbBox);
			for(uint8_t i = 0; i < INDEX_3; i++)
			{
				if(i == AcbMccbcbStatus)
				{
					GUI_SetColor(colorOnFillColor[i]);
					GUI_FillRectEx(&rectMccbStatus[i]);

					GUI_SetBkColor(colorOnFillColor[i]);
					GUI_SetColor(GUI_WHITE);
				}
				else
				{
					GUI_SetColor(colorOffFillColor[i]);
					GUI_FillRectEx(&rectMccbStatus[i]);

					GUI_SetBkColor(colorOffFillColor[i]);
					GUI_SetColor(colorOffTextColor[i]);
				}
				LanguageSelect(FONT20B);
				GUI_DispStringInRect(_accb_status[SettingValue[SETUP_LANGUAGE]][i], &rectMccbStatus[i], GUI_TA_HCENTER | GUI_TA_VCENTER);

			}
		}
		else
		{
			GUI_FillRectEx(&rectAcbBox);
			for(uint8_t i = 0; i < INDEX_2; i++)
			{
				if(i == AcbMccbcbStatus)
				{
					GUI_SetColor(colorOnFillColor[i]);
					GUI_FillRectEx(&rectAcbStatus[i]);

					GUI_SetBkColor(colorOnFillColor[i]);
					GUI_SetColor(GUI_WHITE);
				}
				else
				{
					GUI_SetColor(colorOffFillColor[i]);
					GUI_FillRectEx(&rectAcbStatus[i]);

					GUI_SetBkColor(colorOffFillColor[i]);
					GUI_SetColor(colorOffTextColor[i]);
				}
				LanguageSelect(FONT20B);
				GUI_DispStringInRect(_accb_status[SettingValue[SETUP_LANGUAGE]][i], &rectAcbStatus[i], GUI_TA_HCENTER | GUI_TA_VCENTER);

			}
		}
	}
	bUpdateFirst = FALSE;

	GUI_RECT rect;
	rect.x0 = ACBMCCB_IOSTATUS_START_X;
	rect.x1 = (ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_BOX_WIDTH) - 1;
	rect.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rect.y1 = (rect.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;

	GUI_RECT rectDescLocal;
	rectDescLocal.x0 = ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_DESC_X;
	rectDescLocal.x1 = ACBMCCB_IOSTATUS_STATUS_X - 1;
	rectDescLocal.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rectDescLocal.y1 = (rectDescLocal.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;

	GUI_RECT rectOnOff;
	rectOnOff.x0 = ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_STATUS_X;
	rectOnOff.x1 = (rectOnOff.x0 + ACBMCCB_IOSTATUS_STATUS_WIDTH) - 1;
	rectOnOff.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_STATUS_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rectOnOff.y1 = (rectOnOff.y0 + ACBMCCB_IOSTATUS_STATUS_HEIGHT) - 1;

	char *disableStatus = "-";

	for(int i = 0; i < IO_STATUS_COUNT; i++)
	{
		GUI_SetColor(COLOR_LINE);
		GUI_DrawRectEx(&rect);

//		(void)GUI_SetFont(&GUI_Font20_ASCII);
		if(((ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB) &&
		   (((i == ZSI_IN) && (gAmpareFrame[gDeviceIndex] <= AF250)) 				// 250AF
			|| (i == ERMS)														// ERMS
			|| (i == DO3)))) //	||													// DO #3
		{
			GUI_SetBkColor(COLOR_MAIN_BG);
			GUI_SetColor(OFF_ON_BOX_COLOR);
			LanguageSelect(FONT20);
			GUI_DispStringInRect(_acacbmccb_iostatus_text[i], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);

			GUI_SetColor(OFF_ON_BOX_COLOR);
			GUI_FillRectEx(&rectOnOff);
			GUI_SetColor(COLOR_LABEL);
			GUI_SetBkColor(OFF_ON_BOX_COLOR);
			GUI_DispStringInRect(disableStatus, &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);
		}
		else
		{
			GUI_SetBkColor(COLOR_MAIN_BG);
			GUI_SetColor(COLOR_LABEL);
			LanguageSelect(FONT20);
			GUI_DispStringInRect(_acacbmccb_iostatus_text[i], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);
			if(nDioStatus[IoStatus_Offset[i]] & IoStatus_bit[i])
			{
				GUI_SetColor(COLOR_ON);
				GUI_SetBkColor(COLOR_ON);
				GUI_FillRectEx(&rectOnOff);
				GUI_SetColor(GUI_WHITE);
				LanguageSelect(FONT20B);
				GUI_DispStringInRect(_aconoff_text[SettingValue[SETUP_LANGUAGE]][ON], &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);
			}
			else
			{
				GUI_SetColor(COLOR_OFF);
				GUI_SetBkColor(COLOR_OFF);
				GUI_FillRectEx(&rectOnOff);
				GUI_SetColor(GUI_WHITE);
				LanguageSelect(FONT20B);
				GUI_DispStringInRect(_aconoff_text[SettingValue[SETUP_LANGUAGE]][OFF], &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);
			}
		}
		if(i == ERMS)
		{
			rect.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rect.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectDescLocal.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectDescLocal.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectOnOff.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectOnOff.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;

			rect.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rect.y1 = (rect.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;
			rectDescLocal.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectDescLocal.y1 = (rectDescLocal.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;
			rectOnOff.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_STATUS_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectOnOff.y1 = (rectOnOff.y0 + ACBMCCB_IOSTATUS_STATUS_HEIGHT) - 1;
		}
		else
		{
			rect.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rect.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;

			rectDescLocal.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectDescLocal.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;

			rectOnOff.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectOnOff.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;
		}
	}
}

static void AcbMccbControlDisp(void)
{
	GUI_SetBkColor(COLOR_MAIN_BG);
	(void)GUI_SetPenSize(PENSIZE_LINE);
	(void)GUI_SetFont(&GUI_Font20_ASCII);

	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);

	GUI_RECT rect;
	rect.x0 = ACBMCCB_IOSTATUS_START_X;
	rect.x1 = (ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_X_DISTANCE + ACBMCCB_IOSTATUS_BOX_WIDTH) - 1;
	rect.y0 = ACBMCCB_IOSTATUS_START_Y;
	rect.y1 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_BOX_HEIGHT;

	GUI_RECT rectDescLocal;
	rectDescLocal.x0 = ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_DESC_X;
	rectDescLocal.x1 = (rectDescLocal.x0 + ACBMCCB_IOSTATUS_BOX_WIDTH) - 1;
	rectDescLocal.y0 = ACBMCCB_IOSTATUS_START_Y;
	rectDescLocal.y1 = (rectDescLocal.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;

	if(gCommStatus[gDeviceIndex] == COMM_OK)
	{
		GUI_SetColor(COLOR_MENU_SELECTED);
		GUI_FillRectEx(&rect);

		GUI_SetBkColor(COLOR_MENU_SELECTED);
		GUI_SetColor(GUI_WHITE);
		LanguageSelect(FONT20B);
	}
	else
	{
		GUI_SetColor(COLOR_MAIN_BG);
		GUI_FillRectEx(&rect);

//		GUI_SetBkColor(COLOR_MENU_SELECTED);
		GUI_SetColor(OFF_ON_BOX_COLOR);

		GUI_SetColor(COLOR_LINE);
		GUI_DrawRectEx(&rect);
		LanguageSelect(FONT20);
	}

//	(void)GUI_SetFont(&GUI_Font20B_ASCII);
//	GUI_DispStringInRect(_acacbmccb_cbstatus_control_text[ConnectSetting[gDeviceIndex].DeviceType], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);
	GUI_DispStringInRect(_acacbmccb_cbstatus_control_text[SettingValue[SETUP_LANGUAGE]], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);

	GUI_SetColor(GUI_BLACK);

	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
	{
		GUI_FillRectEx(&rectMccbBox);
		for(int i = 0; i < INDEX_3; i++)
		{
			GUI_SetColor(colorOffFillColor[i]);
			GUI_FillRectEx(&rectMccbStatus[i]);

			GUI_SetBkColor(colorOffFillColor[i]);
			GUI_SetColor(colorOffTextColor[i]);
			GUI_DispStringInRect(_accb_status[SettingValue[SETUP_LANGUAGE]][i], &rectMccbStatus[i], GUI_TA_HCENTER | GUI_TA_VCENTER);

		}
	}
	else
	{
		GUI_FillRectEx(&rectAcbBox);
		for(int i = 0; i < INDEX_2; i++)
		{
			GUI_SetColor(colorOffFillColor[i]);
			GUI_FillRectEx(&rectAcbStatus[i]);

			GUI_SetBkColor(colorOffFillColor[i]);
			GUI_SetColor(colorOffTextColor[i]);
			GUI_DispStringInRect(_accb_status[SettingValue[SETUP_LANGUAGE]][i], &rectAcbStatus[i], GUI_TA_HCENTER | GUI_TA_VCENTER);

		}
	}
	rect.x0 = ACBMCCB_IOSTATUS_START_X;
	rect.x1 = (ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_BOX_WIDTH) - 1;
	rect.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rect.y1 = (rect.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;

	rectDescLocal.x0 = ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_DESC_X;
	rectDescLocal.x1 = ACBMCCB_IOSTATUS_STATUS_X - 1;
	rectDescLocal.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rectDescLocal.y1 = (rectDescLocal.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;

	GUI_RECT rectOnOff;
	rectOnOff.x0 = ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_STATUS_X;
	rectOnOff.x1 = (rectOnOff.x0 + ACBMCCB_IOSTATUS_STATUS_WIDTH) - 1;
	rectOnOff.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_STATUS_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rectOnOff.y1 = (rectOnOff.y0 + ACBMCCB_IOSTATUS_STATUS_HEIGHT) - 1;

	char *disableStatus = "-";

	for(int i = 0; i < IO_STATUS_COUNT; i++)
	{
		GUI_SetColor(COLOR_LINE);
		GUI_DrawRectEx(&rect);

		GUI_SetBkColor(COLOR_MAIN_BG);
		GUI_SetColor(OFF_ON_BOX_COLOR);
		LanguageSelect(FONT20);
		GUI_DispStringInRect(_acacbmccb_iostatus_text[i], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);

		GUI_SetColor(OFF_ON_BOX_COLOR);
		GUI_FillRectEx(&rectOnOff);
		GUI_SetColor(COLOR_LABEL);
		GUI_SetBkColor(OFF_ON_BOX_COLOR);
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			LanguageSelect(FONT20B);
		}
		else
		{
			LanguageSelect(FONT20);
		}
		GUI_DispStringInRect(disableStatus, &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);

		if(i == ERMS)
		{
			rect.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rect.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectDescLocal.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectDescLocal.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectOnOff.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectOnOff.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;

			rect.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rect.y1 = (rect.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;
			rectDescLocal.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectDescLocal.y1 = (rectDescLocal.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;
			rectOnOff.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_STATUS_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectOnOff.y1 = (rectOnOff.y0 + ACBMCCB_IOSTATUS_STATUS_HEIGHT) - 1;
		}
		else
		{
			rect.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rect.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;

			rectDescLocal.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectDescLocal.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;

			rectOnOff.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectOnOff.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;
		}
	}
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       Createstatus_window
*/

//const char* KeyStr[COMM_STAT_ERROR+1] = {
//	"KEY_SETUP",
//	"KEY_UP",
//	"KEY_DOWN",
//	"KEY_ENTER",
//	"KEY_CANCEL",
//	"DATA_RECV",
//	"TIME_OUT",
//	"KEY_COMM_ERROR",
//	"COMM_STAT_ERROR",
//};

// PRQA S 1503 1
void StuIo(void)
{
	uint8_t bRecvData;
	int flagBreak = FALSE;
	bRecvData = FALSE;
	bUpdateFirst = TRUE;
	AcbMccbControlDisp();
	gStatusSendEnd = STATUS_SEND_ING;
	statusSendStep = 0;
	nSendStep = 0;
	AcbMccbControlSend();
	int bCommError = gCommStatus[gDeviceIndex];
	while (1)
    {
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			nSendStep = 0;
			AcbMccbControlSend();
		}
		else
		if(key == KEY_ENTER)
		{
			if(bRecvData == TRUE)
			{
				int flag = ControlCheck();
				(void)printf("nRemote=%d, flag=%d\n", nRemote, flag);
				if((nRemote == TRUE) && (flag == TRUE))
				{
					char buf[MESSAGE_BUF_SIZE];
					uint8_t status = AcbMccbcbStatus;
					uint16_t address=CB_STATUS_NOT_TRIO_ADDR;

					if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
					{
						if(status == CB_STATUS_INPUT_FAULT)
						{
							status = 0;
							address = CB_STATUS_MCCB_TRIP_ADDR;
						}
						else
						{
							address = CB_STATUS_MCCB_ADDR;
						}
					}
					else
					{
						if(nTrio != INDEX_7)		// TRIO 결선000b: TRIO Only, 001b: TRIO+ACB_OCR, 010b: TRIO+MCCB, 111b: ACB OCR Only
						{
							address = CB_STATUS_TRIO_ADDR;
						}
					}
					(void)sprintf(buf, _acacbMccbcontrol_confirm_text[SettingValue[SETUP_LANGUAGE]], _accb_control_status[SettingValue[SETUP_LANGUAGE]][AcbMccbcbStatus]);
					ControlSet(status, address, 0, buf, 1);
				}
				else
				{
					ControlErrorMessage(_acCBSetting_invalid_text[SettingValue[SETUP_LANGUAGE]]);
				}
				bUpdateFirst = TRUE;
				DispStatus();
				AcbMccbControlDisp();
				AcbMccbControlSend();
				gCommOldStatus[gDeviceIndex] = -1;
				CommTimerInit();
			}
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			AcbMccbControlDisp();
			gCommOldStatus[gDeviceIndex] = -1;
			AcbMccbControlSend();
		}
		else
		if(key == DATA_RECV)
		{
			(void)printf("DATA_RECV gStatusSendEnd=%d\n",gStatusSendEnd);
			if(bCommError == COMM_ERROR)
			{
				AcbMccbControlDisp();
				bCommError = COMM_OK;
			}
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				StatusRecv();
				AcbMccbControlSend();
			}
			else
			{
				AcbMccbIoValueDisp();
				g_bRecvAllDone = TRUE;
				nSendStep = 0;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
				bRecvData = TRUE;
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{

			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
					AcbMccbControlSend();
					g_bRecvAllDone = TRUE;
					(void)printf("All done!!!\n");
					gStatusSendEnd = STATUS_SEND_ING;
					statusSendStep = 0;
					nSendStep = 0;
			}
/*
			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(gAcbMccbSend == TRUE)
			{
				gAcbMccbSend =FALSE;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
			}
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				gAcbMccbSend = TRUE;
				AcbMccbControlSend();
			}
*/
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			bUpdateFirst = TRUE;
			(void)printf("COMM_STAT_ERROR\n\n");
			bCommError = COMM_ERROR;
			AcbMccbControlDisp();
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
	}
}

#define TRIO_TEMP_MAX					4

#define TRIO_TEMP_LABEL_HEIGHT			34
#define TRIO_TEMP_LABEL_WIDTH			30
#define TRIO_TEMP_LABEL_DISTANCE		57

#define TRIO_TEMP_LABEL_X0				29
#define TRIO_TEMP_LABEL_X1				((TRIO_TEMP_LABEL_X0 + TRIO_TEMP_LABEL_WIDTH) - 1)
#define TRIO_TEMP_LABEL_Y0				90
#define TRIO_TEMP_LABEL_Y1				((TRIO_TEMP_LABEL_Y0 + TRIO_TEMP_LABEL_HEIGHT) - 1)



#define TRIO_TEMP_DIVITION_LINE_X0		85
#define TRIO_TEMP_DIVITION_LINE_Y0		74
#define TRIO_TEMP_DIVITION_LINE_Y1		TRIO_TEMP_DIVITION_LINE_Y0 + 226
#define TRIO_TEMP_DIVITION_LINE_X_INC	64
#define TRIO_TEMP_DIVITION_LINE_CNT		5

#define TRIO_TEMP_TEMP_TEXT_X0			24
#define TRIO_TEMP_TEMP_TEXT_X1			38
#define TRIO_TEMP_TEMP_TEXT_Y1			14

#define TRIO_TEMP_X_TEXT_X0				137
#define TRIO_TEMP_X_TEXT_Y				52
#define TRIO_TEMP_X_TEXT_X1				24
#define TRIO_TEMP_X_TEXT_Y1				14

#define TRIO_TEMP_BAR_X0				88
#define TRIO_TEMP_BAR_Y0				84
#define TRIO_TEMP_BAR_X1				TRIO_TEMP_BAR_X0 + 10
#define TRIO_TEMP_BAR_Y1				TRIO_TEMP_BAR_Y0 + 35
#define TRIO_TEMP_BAR_X_DISTANCE		12
#define TRIO_TEMP_BAR_Y_DISTANCE		56

#define TRIO_TEMP_UNIT_X				435
#define TRIO_TEMP_UNIT_Y				95

#define TRIO_TEMP_VALUE_X0				366
#define TRIO_TEMP_VALUE_Y0				86
#define TRIO_TEMP_VALUE_X1				TRIO_TEMP_VALUE_X0 + 65
#define TRIO_TEMP_VALUE_Y1				TRIO_TEMP_VALUE_Y0 + 35

#define TRIO_TEMP_READ_ADDR				186
#define TRIO_TEMP_READ_LEN				26
#define I_REGISTER_186					186

#define	VALUE150						150
#define	VALUE100						100

static void TrioValueValueDisp(void)
{
	static const GUI_COLOR _BarColor[INDEX_4] = {
		0x0000ff, 0x00deff, 0x0fce00, 0x3a3939
	};
	static float	aiValue[TRIO_TEMP_MAX];
	uint16_t		barGraph[TRIO_TEMP_MAX];

	if(gCommStatus[gDeviceIndex] == COMM_ERROR)
	{
		return;
	}
	int index =  I_REGISTER_186;
	GUI_SetBkColor(COLOR_MAIN_BG);
	(void)GUI_SetFont(&GUI_Font32B_ASCII);
	GUI_SetColor(COLOR_VALUE);
	GUI_RECT rect;
	rect.x0 = TRIO_TEMP_VALUE_X0;
	rect.x1 = TRIO_TEMP_VALUE_X1;
	rect.y0 = TRIO_TEMP_VALUE_Y0;
	rect.y1 = TRIO_TEMP_VALUE_Y1;

	aiValue[0] = 59.9;
	aiValue[1] = 99.999;
	aiValue[2] = 100.1;
	aiValue[3] = 150;
	for(int i = 0; i < TRIO_TEMP_MAX; i++)
	{
		char buf[20];
//		aiValue[i] =  ModbusGetFloat(index);
printf("i=%d, value=%f\n",i, aiValue[i]);
		GUI_ClearRect(rect.x0, rect.y0, rect.x1, rect.y1);
		sprintf(buf, "%3d",(int)aiValue[i]);
		GUI_DispStringInRect(buf, &rect, (GUI_TA_RIGHT | GUI_TA_VCENTER));
		rect.y0 += TRIO_TEMP_LABEL_DISTANCE;
		rect.y1 += TRIO_TEMP_LABEL_DISTANCE;
		index +=  INDEX_2;
		if(aiValue == 0)
			barGraph[i] = 0;
		else
			barGraph[i] = (int)(aiValue[i] / INDEX_10) + 1;
	}
	int y0 = TRIO_TEMP_BAR_Y0;
	int y1 = TRIO_TEMP_BAR_Y1;
	for(int i = 0; i < TRIO_TEMP_MAX; i++)
	{
		if(aiValue[i] >= VALUE150)
		{
			GUI_SetColor(_BarColor[INDEX_0]);
		}
		else
		if(aiValue[i] >= VALUE100)
		{
			GUI_SetColor(_BarColor[INDEX_1]);
		}
		else
		{
			GUI_SetColor(_BarColor[INDEX_2]);
		}
		int x0 = TRIO_TEMP_BAR_X0;
		int x1 = TRIO_TEMP_BAR_X1;
		for(int j = 0; j < INDEX_20; j++)
		{
			if(barGraph[i] <= j)
			{
				GUI_SetColor(_BarColor[INDEX_3]);
			}
			GUI_FillRect(x0, y0, x1, y1);
			x0 += TRIO_TEMP_BAR_X_DISTANCE;
			x1 += TRIO_TEMP_BAR_X_DISTANCE;
			if((j == INDEX_4) || (j ==INDEX_9) || (j ==INDEX_14))
			{
				x0 += INDEX_4;
				x1 += INDEX_4;
			}
		}
		y0 += TRIO_TEMP_BAR_Y_DISTANCE;
		y1 += TRIO_TEMP_BAR_Y_DISTANCE;
	}
}

static void TrioTempSend(void)
{
	if(StatusSend() == STATUS_SEND_ING)
	{
		return;
	}
	ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, ACB_CONTROL_READ_ADDR, ACB_CONTROL_READ_LEN);	// 30183 ~ 30208
}


static void TrioTempDisp(void)
{
	GUI_SetBkColor(COLOR_MAIN_BG);
	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	(void)GUI_SetFont(&GUI_Font13_ASCII);

	GUI_SetColor(COLOR_LABEL);
	GUI_RECT rect;
	rect.x0 = TRIO_TEMP_TEMP_TEXT_X0;
	rect.x1 = TRIO_TEMP_TEMP_TEXT_X0 + TRIO_TEMP_TEMP_TEXT_X1;
	rect.y0 = TRIO_TEMP_X_TEXT_Y;
	rect.y1 = TRIO_TEMP_X_TEXT_Y + TRIO_TEMP_TEMP_TEXT_Y1;
	GUI_DispStringInRect("TEMP", &rect, (GUI_TA_HCENTER | GUI_TA_VCENTER));

	GUI_SetColor(GUI_WHITE);
	rect.x0 = TRIO_TEMP_X_TEXT_X0;
	rect.x1 = TRIO_TEMP_X_TEXT_X0 + TRIO_TEMP_X_TEXT_X1;
 	for(int i = 0; i < TRIO_TEMP_DIVITION_LINE_CNT-1; i++)
	{
		char buf[10];
		sprintf(buf, "%d", (i+1)*50);
		GUI_DispStringInRect(buf, &rect, (GUI_TA_HCENTER | GUI_TA_VCENTER));
		rect.x0 += TRIO_TEMP_DIVITION_LINE_X_INC;
		rect.x1 += TRIO_TEMP_DIVITION_LINE_X_INC;
	}

	GUI_SetColor(COLOR_LINE);
	rect.x0 = TRIO_TEMP_DIVITION_LINE_X0;
	rect.y0 = TRIO_TEMP_DIVITION_LINE_Y0;
	rect.y1 = TRIO_TEMP_DIVITION_LINE_Y1;
	(void)GUI_SetPenSize(PENSIZE_LINE);
	for(int i = 0; i < TRIO_TEMP_DIVITION_LINE_CNT; i++)
	{
		GUI_DrawVLine(rect.x0, rect.y0, rect.y1);
		rect.x0 += TRIO_TEMP_DIVITION_LINE_X_INC;
	}

	(void)GUI_SetFont(&GUI_Font32B_ASCII);
	GUI_SetColor(COLOR_LABEL);
	rect.x0 = TRIO_TEMP_LABEL_X0;
	rect.y0 = TRIO_TEMP_LABEL_Y0;
	rect.x1 = TRIO_TEMP_LABEL_X1;
	rect.y1 = TRIO_TEMP_LABEL_Y1;

	for(int i = 0; i < TRIO_TEMP_MAX; i++)
	{
		char buf[10];
		sprintf(buf,"#%d", i+1);
		GUI_DispStringInRect(buf,  &rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
		rect.y0 += TRIO_TEMP_LABEL_DISTANCE;
		rect.y1 += TRIO_TEMP_LABEL_DISTANCE;
	}

	(void)GUI_SetFont(&GUI_Font16B_1);
	GUI_SetColor(COLOR_DISABLE);
	int y0 = TRIO_TEMP_BAR_Y0;
	int y1 = TRIO_TEMP_BAR_Y1;

	printf("Bar \n");
	for(int i = 0; i < TRIO_TEMP_MAX; i++)
	{
		int x0 = TRIO_TEMP_BAR_X0;
		int x1 = TRIO_TEMP_BAR_X1;
		for(int j = 0; j < INDEX_20; j++)
		{
			GUI_FillRect(x0, y0, x1, y1);
			x0 += TRIO_TEMP_BAR_X_DISTANCE;
			x1 += TRIO_TEMP_BAR_X_DISTANCE;
			if((j == INDEX_4) || (j ==INDEX_9) || (j ==INDEX_14))
			{
				x0 += INDEX_4;
				x1 += INDEX_4;
			}
		}
		y0 += TRIO_TEMP_BAR_Y_DISTANCE;
		y1 += TRIO_TEMP_BAR_Y_DISTANCE;
	}

	int x = TRIO_TEMP_UNIT_X;
	int y = TRIO_TEMP_UNIT_Y;
	for(int i = 0; i < TRIO_TEMP_MAX; i++)
	{
		GUI_DrawBitmap(&bmCelsius, x, y);
		y += TRIO_TEMP_LABEL_DISTANCE;
	}

}

void TrioTemp(void)
{
	uint8_t bRecvData;
	int flagBreak = FALSE;
	bRecvData = FALSE;
	bUpdateFirst = TRUE;
	TrioTempDisp();
	gStatusSendEnd = STATUS_SEND_ING;
	statusSendStep = 0;
	nSendStep = 0;
	TrioTempSend();
	int bCommError = gCommStatus[gDeviceIndex];
	while (1)
    {
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			nSendStep = 0;
			TrioTempSend();
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			AcbMccbControlDisp();
			gCommOldStatus[gDeviceIndex] = -1;
			TrioTempSend();
		}
		else
		if(key == DATA_RECV)
		{
			(void)printf("DATA_RECV gStatusSendEnd=%d\n",gStatusSendEnd);
			if(bCommError == COMM_ERROR)
			{
				TrioTempDisp();
				bCommError = COMM_OK;
			}
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				StatusRecv();
				TrioTempSend();
			}
			else
			{
				TrioValueValueDisp();
				g_bRecvAllDone = TRUE;
				nSendStep = 0;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
				bRecvData = TRUE;
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{

			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
					TrioTempSend();
					g_bRecvAllDone = TRUE;
					(void)printf("All done!!!\n");
					gStatusSendEnd = STATUS_SEND_ING;
					statusSendStep = 0;
					nSendStep = 0;
			}
/*
			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(gAcbMccbSend == TRUE)
			{
				gAcbMccbSend =FALSE;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
			}
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				gAcbMccbSend = TRUE;
				TrioTempSend();
			}
*/
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			bUpdateFirst = TRUE;
			(void)printf("COMM_STAT_ERROR\n\n");
			bCommError = COMM_ERROR;
			TrioTempDisp();
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
	}
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       Createstatus_window
*/

// PRQA S 1503 2
// PRQA S 1505 1
void AcbMccbControl(void)
{
	int flagBreak = FALSE;
	nMenuPos = 0;

	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	InfoMenu(CONTROL_MENU, nMenuPos, EVENT_MENU_COUNT);

	//(void)StatusSend();

	nSendStep = 0;

	while (1)
    {
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			nSendStep = 0;
			statusSendStep = 0;
			gStatusSendEnd = STATUS_SEND_ING;
			(void)StatusSend();
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
			InfoMenu(CONTROL_MENU, nMenuPos, EVENT_MENU_COUNT);
			gCommOldStatus[gDeviceIndex] = -1;
		}
		else
		if(key == KEY_UP)
		{
			if(nMenuPos > 0)
			{
				nMenuPos--;
			}
			else
			{
				nMenuPos = EVENT_MENU_COUNT - 1;
			}
			InfoMenu(CONTROL_MENU, nMenuPos, EVENT_MENU_COUNT);
		}
		else
		if(key == KEY_DOWN)
		{
			if(nMenuPos < (EVENT_MENU_COUNT-1))
			{
				nMenuPos++;
			}
			else
			{
				nMenuPos = 0;
			}
			InfoMenu(CONTROL_MENU, nMenuPos, EVENT_MENU_COUNT);
		}
		else
		if(key == KEY_ENTER)
		{
			if(nMenuPos == INDEX_0)
			{
				StuIo();
			}
			else
			if(nMenuPos == INDEX_1)
			{
				StuIo();
			}
			if(nMenuPos == INDEX_2)
			{
				TrioTemp();
			}
			InfoMenu(CONTROL_MENU, nMenuPos, EVENT_MENU_COUNT);
		}
		else
		if(key == DATA_RECV)
		{
//			(void)printf("DATA_RECV\n");
			StatusRecv();
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				(void)EventSend(FALSE);
			}
			else
			{
				g_bRecvAllDone = TRUE;
//				(void)printf("All done!!!\n");
				nSendStep = 0;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{
			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				g_bRecvAllDone = TRUE;
				(void)printf("All done!!!\n");
				gStatusSendEnd = STATUS_SEND_ING;
				statusSendStep = 0;
				nSendStep = 0;
			}
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
	}
}
/*************************** End of file ****************************/
