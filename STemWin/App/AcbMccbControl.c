/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/


#define EXTERN extern
#include "stm32f4xx_hal.h"
#include "main.h"
#include "GuiData.h"

//const uint16_t IoStatus_Offset[IO_STATUS_COUNT] = {
//	0,
//	1,
//	0,
//	0,
//	0,
//	1,
//	1,
//	1
//};
//
//const uint16_t IoStatus_bit[IO_STATUS_COUNT] = {
//	0x8000,
//	0x8000,
//	0x1000,
//	0x0200,
//	0x4000,
//	0x0001,
//	0x0002,
//	0x0004
//};
//

static uint8_t AcbMccbcbStatus;
static uint8_t bUpdateFirst;
static uint8_t TrioIocbStatus;

static void AcbMccbControlSend(void);
static int ControlCheck(void);
static void AcbMccbIoValueDisp(void);
static void AcbMccbControlDisp(void);

static void TrioIoSend(void);
static void TrioPageDisp(int page);
static void TrioIoValueDisp(int pos);
static void TrioIoDisp(int pos);
static void TrioIo(void);

static void TrioTempValueDisp(void);
static void TrioTempSend(void);
static void TrioTempDisp(void);
static void TrioTemp(void);

#define TRIO_DO_MAX		3
static uint8_t ControlDoStatus[TRIO_DO_MAX];

static GUI_COLOR colorOffFillColor[OPEN_CLOSE_TRIP] = {
	CB_OPEN_OFF_COLOR,
	CB_CLOSE_OFF_COLOR,
	TRIP_OFF_COLOR
};

static GUI_COLOR colorOffTextColor[OPEN_CLOSE_TRIP] = {
	CB_OPEN_OFF_TEXT_COLOR,
	CB_CLOSE_OFF_TEXT_COLOR,
	TRIP_OFF_TEXT_COLOR
};

static void AcbMccbControlSend(void)
{
	if(StatusSend() == STATUS_SEND_ING)
	{
		return;
	}
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
	{
		ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, ACB_CONTROL_READ_ADDR, ACB_CONTROL_READ_LEN);	// 30183 ~ 30208
	}
	else
	{
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, MCCB_CONTROL_READ_ADDR, MCCB_CONTROL_READ_LEN);	// 30204 ~ 30208
		}
	}
}

static uint8_t nDoSetting[CB_STATUS_DO_MAX];
static uint8_t nRemote;
static int ControlCheck(void)
{
	int ret = FALSE;
	uint16_t compare=CB_STATUS_OUTPUT_DEFAULT;

	if(AcbMccbcbStatus == CB_STATUS_INPUT_OPEN)	// Open
	{
		compare = CB_STATUS_OUTPUT_CLOSE;	// CB Close
	}
	else
	if(AcbMccbcbStatus == CB_STATUS_INPUT_CLOSE)	// Close
	{
		compare = CB_STATUS_OUTPUT_OPEN;	// CB Open
	}
	else
	if(AcbMccbcbStatus == CB_STATUS_INPUT_FAULT)	// Fault
	{
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			ret = TRUE;
		}
	}
	else
	{
		printf("CB DI Status(30184) : %X\n", AcbMccbcbStatus);
	}
	(void)printf("===============================\ncbStatus=%d, compare=%d, nTrio=%d\n", AcbMccbcbStatus, compare, nTrio[gDeviceIndex]);
	for(int i = 0; i < CB_STATUS_DO_MAX; i++)
	{
		(void)printf("i=%d, nDoSetting=%d\n", i, nDoSetting[i]);
		if(nDoSetting[i] == compare)
		{
			ret = TRUE;
		}
	}
	return ret;
}

static void AcbMccbIoValueDisp(void)
{
	uint16_t nDioStatus[DIO_STATUS_MAX];
	static const uint16_t IoStatus_Offset[IO_STATUS_COUNT] =
	{
			0,
			1,
			0,
			1,
			1,
			1
	};
	static const uint16_t IoStatus_bit[IO_STATUS_COUNT] =
	{
			0x8000,
			0x8000,
			0x4000,
			0x0001,
			0x0002,
			0x0004
	};
	static GUI_COLOR colorOnFillColor[OPEN_CLOSE_TRIP] =
	{
			CB_OPEN_ON_COLOR,
			CB_CLOSE_ON_COLOR,
			TRIP_ON_COLOR
	};

	nDioStatus[INDEX_0] = ModbusGetUint16(I_REGISTER_207);
	nDioStatus[INDEX_1] = ModbusGetUint16(I_REGISTER_208);
	if(ModbusGetUint16(I_REGISTER_206) & CB_REMOTE_MASK)
	{
		nRemote = TRUE;
	}
	else
	{
		nRemote = FALSE;
	}
	nDoSetting[INDEX_0] = ModbusGetUint8_U(I_REGISTER_204);
	nDoSetting[INDEX_1] = ModbusGetUint8_L(I_REGISTER_204);
	nDoSetting[INDEX_2] = ModbusGetUint8_U(I_REGISTER_205);

//	nTrio = INDEX_0;

//	(void)GUI_SetFont(&GUI_Font20B_ASCII);
	LanguageSelect(FONT20B);
	GUI_SetColor(GUI_BLACK);

	uint8_t status = (ModbusGetUint16(I_REGISTER_208) >> CB_STATUS_SHIFT) & CB_STATUS_MASK;		// 0x00: Open(ACB OCR 사용) 0x01: Close(ACB OCR 사용) 0x02: Trip 0x03: Intermediate
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
	{
		nTrio[gDeviceIndex] = (ModbusGetUint16(I_REGISTER_183) >> CB_TRIO_SHIFT) & CB_TRIO_MASK;	// TRIO 결선 000b: TRIO Only 001b: TRIO+ACB_OCR 010b: TRIO+MCCB 111b: ACB OCR Only
//		(void)printf("nTrio=%d\n", nTrio[gDeviceIndex]);
		if(nTrio[gDeviceIndex] != INDEX_7)		// ACB Only가 아니면
		{
			status = (ModbusGetUint16(I_REGISTER_184) >> CB_ACB_TRIO_SHIFT) & CB_ACB_TRIO_MASK;
			nDoSetting[INDEX_0] = INDEX_2;		//CB CLose
			nDoSetting[INDEX_1] = INDEX_3;		// CB Open

			if(ModbusGetUint16(I_REGISTER_183) & CB_ACB_TRIO_REMOTE_MASK)
			{
				nRemote = TRUE;
			}
			else
			{
				nRemote = FALSE;
			}
		}
	}
	else
	{
		nDoSetting[INDEX_2] = 0;
	}
	if((bUpdateFirst == TRUE) || (AcbMccbcbStatus != status))
	{
		AcbMccbcbStatus = status;
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			GUI_FillRectEx(&rectMccbBox);
			for(uint8_t i = 0; i < INDEX_3; i++)
			{
				if(i == AcbMccbcbStatus)
				{
					GUI_SetColor(colorOnFillColor[i]);
					GUI_FillRectEx(&rectMccbStatus[i]);

					GUI_SetBkColor(colorOnFillColor[i]);
					GUI_SetColor(GUI_WHITE);
				}
				else
				{
					GUI_SetColor(colorOffFillColor[i]);
					GUI_FillRectEx(&rectMccbStatus[i]);

					GUI_SetBkColor(colorOffFillColor[i]);
					GUI_SetColor(colorOffTextColor[i]);
				}
				LanguageSelect(FONT20B);
				GUI_DispStringInRect(_accb_status[SettingValue[SETUP_LANGUAGE]][i], &rectMccbStatus[i], GUI_TA_HCENTER | GUI_TA_VCENTER);

			}
		}
		else
		{
			GUI_FillRectEx(&rectAcbBox);
			for(uint8_t i = 0; i < INDEX_2; i++)
			{
				if(i == AcbMccbcbStatus)
				{
					GUI_SetColor(colorOnFillColor[i]);
					GUI_FillRectEx(&rectAcbStatus[i]);

					GUI_SetBkColor(colorOnFillColor[i]);
					GUI_SetColor(GUI_WHITE);
				}
				else
				{
					GUI_SetColor(colorOffFillColor[i]);
					GUI_FillRectEx(&rectAcbStatus[i]);

					GUI_SetBkColor(colorOffFillColor[i]);
					GUI_SetColor(colorOffTextColor[i]);
				}
				LanguageSelect(FONT20B);
				GUI_DispStringInRect(_accb_status[SettingValue[SETUP_LANGUAGE]][i], &rectAcbStatus[i], GUI_TA_HCENTER | GUI_TA_VCENTER);

			}
		}
	}
	bUpdateFirst = FALSE;

	GUI_RECT rect;
	rect.x0 = ACBMCCB_IOSTATUS_START_X;
	rect.x1 = (ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_BOX_WIDTH) - 1;
	rect.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rect.y1 = (rect.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;

	GUI_RECT rectDescLocal;
	rectDescLocal.x0 = ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_DESC_X;
	rectDescLocal.x1 = ACBMCCB_IOSTATUS_STATUS_X - 1;
	rectDescLocal.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rectDescLocal.y1 = (rectDescLocal.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;

	GUI_RECT rectOnOff;
	rectOnOff.x0 = ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_STATUS_X;
	rectOnOff.x1 = (rectOnOff.x0 + ACBMCCB_IOSTATUS_STATUS_WIDTH) - 1;
	rectOnOff.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_STATUS_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rectOnOff.y1 = (rectOnOff.y0 + ACBMCCB_IOSTATUS_STATUS_HEIGHT) - 1;

	char *disableStatus = "-";

	for(int i = 0; i < IO_STATUS_COUNT; i++)
	{
		GUI_SetColor(COLOR_LINE);
		GUI_DrawRectEx(&rect);

//		(void)GUI_SetFont(&GUI_Font20_ASCII);
		if(((ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB) &&
		   (((i == ZSI_IN) && (gAmpareFrame[gDeviceIndex] <= AF250)) 				// 250AF
			|| (i == ERMS)														// ERMS
			|| (i == DO3)))) //	||													// DO #3
		{
			GUI_SetBkColor(COLOR_MAIN_BG);
			GUI_SetColor(OFF_ON_BOX_COLOR);
			LanguageSelect(FONT20);
			GUI_DispStringInRect(_acacbmccb_iostatus_text[i], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);

			GUI_SetColor(OFF_ON_BOX_COLOR);
			GUI_FillRectEx(&rectOnOff);
			GUI_SetColor(COLOR_LABEL);
			GUI_SetBkColor(OFF_ON_BOX_COLOR);
			GUI_DispStringInRect(disableStatus, &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);
		}
		else
		{
			GUI_SetBkColor(COLOR_MAIN_BG);
			GUI_SetColor(COLOR_LABEL);
			LanguageSelect(FONT20);
			GUI_DispStringInRect(_acacbmccb_iostatus_text[i], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);
			if(nDioStatus[IoStatus_Offset[i]] & IoStatus_bit[i])
			{
				GUI_SetColor(COLOR_ON);
				GUI_SetBkColor(COLOR_ON);
				GUI_FillRectEx(&rectOnOff);
				GUI_SetColor(GUI_WHITE);
				LanguageSelect(FONT20B);
				GUI_DispStringInRect(_aconoff_text[SettingValue[SETUP_LANGUAGE]][ON], &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);
			}
			else
			{
				GUI_SetColor(COLOR_OFF);
				GUI_SetBkColor(COLOR_OFF);
				GUI_FillRectEx(&rectOnOff);
				GUI_SetColor(GUI_WHITE);
				LanguageSelect(FONT20B);
				GUI_DispStringInRect(_aconoff_text[SettingValue[SETUP_LANGUAGE]][OFF], &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);
			}
		}
		if(i == ERMS)
		{
			rect.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rect.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectDescLocal.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectDescLocal.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectOnOff.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectOnOff.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;

			rect.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rect.y1 = (rect.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;
			rectDescLocal.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectDescLocal.y1 = (rectDescLocal.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;
			rectOnOff.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_STATUS_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectOnOff.y1 = (rectOnOff.y0 + ACBMCCB_IOSTATUS_STATUS_HEIGHT) - 1;
		}
		else
		{
			rect.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rect.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;

			rectDescLocal.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectDescLocal.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;

			rectOnOff.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectOnOff.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;
		}
	}
}

static void AcbMccbControlDisp(void)
{
	GUI_SetBkColor(COLOR_MAIN_BG);
	(void)GUI_SetPenSize(PENSIZE_LINE);
	(void)GUI_SetFont(&GUI_Font20_ASCII);

	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);

	GUI_RECT rect;
	rect.x0 = ACBMCCB_IOSTATUS_START_X;
	rect.x1 = (ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_X_DISTANCE + ACBMCCB_IOSTATUS_BOX_WIDTH) - 1;
	rect.y0 = ACBMCCB_IOSTATUS_START_Y;
	rect.y1 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_BOX_HEIGHT;

	GUI_RECT rectDescLocal;
	rectDescLocal.x0 = ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_DESC_X;
	rectDescLocal.x1 = (rectDescLocal.x0 + ACBMCCB_IOSTATUS_BOX_WIDTH) - 1;
	rectDescLocal.y0 = ACBMCCB_IOSTATUS_START_Y;
	rectDescLocal.y1 = (rectDescLocal.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;

	if(gCommStatus[gDeviceIndex] == COMM_OK)
	{
		GUI_SetColor(COLOR_MENU_SELECTED);
		GUI_FillRectEx(&rect);

		GUI_SetBkColor(COLOR_MENU_SELECTED);
		GUI_SetColor(GUI_WHITE);
		LanguageSelect(FONT20B);
	}
	else
	{
		GUI_SetColor(COLOR_MAIN_BG);
		GUI_FillRectEx(&rect);

//		GUI_SetBkColor(COLOR_MENU_SELECTED);
		GUI_SetColor(OFF_ON_BOX_COLOR);

		GUI_SetColor(COLOR_LINE);
		GUI_DrawRectEx(&rect);
		LanguageSelect(FONT20);
	}

//	(void)GUI_SetFont(&GUI_Font20B_ASCII);
//	GUI_DispStringInRect(_acacbmccb_cbstatus_control_text[ConnectSetting[gDeviceIndex].DeviceType], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);
	GUI_DispStringInRect(_acacbmccb_cbstatus_control_text[SettingValue[SETUP_LANGUAGE]], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);

	GUI_SetColor(GUI_BLACK);

	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
	{
		GUI_FillRectEx(&rectMccbBox);
		for(int i = 0; i < INDEX_3; i++)
		{
			GUI_SetColor(colorOffFillColor[i]);
			GUI_FillRectEx(&rectMccbStatus[i]);

			GUI_SetBkColor(colorOffFillColor[i]);
			GUI_SetColor(colorOffTextColor[i]);
			GUI_DispStringInRect(_accb_status[SettingValue[SETUP_LANGUAGE]][i], &rectMccbStatus[i], GUI_TA_HCENTER | GUI_TA_VCENTER);

		}
	}
	else
	{
		GUI_FillRectEx(&rectAcbBox);
		for(int i = 0; i < INDEX_2; i++)
		{
			GUI_SetColor(colorOffFillColor[i]);
			GUI_FillRectEx(&rectAcbStatus[i]);

			GUI_SetBkColor(colorOffFillColor[i]);
			GUI_SetColor(colorOffTextColor[i]);
			GUI_DispStringInRect(_accb_status[SettingValue[SETUP_LANGUAGE]][i], &rectAcbStatus[i], GUI_TA_HCENTER | GUI_TA_VCENTER);

		}
	}
	rect.x0 = ACBMCCB_IOSTATUS_START_X;
	rect.x1 = (ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_BOX_WIDTH) - 1;
	rect.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rect.y1 = (rect.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;

	rectDescLocal.x0 = ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_DESC_X;
	rectDescLocal.x1 = ACBMCCB_IOSTATUS_STATUS_X - 1;
	rectDescLocal.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rectDescLocal.y1 = (rectDescLocal.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;

	GUI_RECT rectOnOff;
	rectOnOff.x0 = ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_STATUS_X;
	rectOnOff.x1 = (rectOnOff.x0 + ACBMCCB_IOSTATUS_STATUS_WIDTH) - 1;
	rectOnOff.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_STATUS_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rectOnOff.y1 = (rectOnOff.y0 + ACBMCCB_IOSTATUS_STATUS_HEIGHT) - 1;

	char *disableStatus = "-";

	for(int i = 0; i < IO_STATUS_COUNT; i++)
	{
		GUI_SetColor(COLOR_LINE);
		GUI_DrawRectEx(&rect);

		GUI_SetBkColor(COLOR_MAIN_BG);
		GUI_SetColor(OFF_ON_BOX_COLOR);
		LanguageSelect(FONT20);
		GUI_DispStringInRect(_acacbmccb_iostatus_text[i], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);

		GUI_SetColor(OFF_ON_BOX_COLOR);
		GUI_FillRectEx(&rectOnOff);
		GUI_SetColor(COLOR_LABEL);
		GUI_SetBkColor(OFF_ON_BOX_COLOR);
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			LanguageSelect(FONT20B);
		}
		else
		{
			LanguageSelect(FONT20);
		}
		GUI_DispStringInRect(disableStatus, &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);

		if(i == ERMS)
		{
			rect.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rect.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectDescLocal.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectDescLocal.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectOnOff.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectOnOff.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;

			rect.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rect.y1 = (rect.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;
			rectDescLocal.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectDescLocal.y1 = (rectDescLocal.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;
			rectOnOff.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_STATUS_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectOnOff.y1 = (rectOnOff.y0 + ACBMCCB_IOSTATUS_STATUS_HEIGHT) - 1;
		}
		else
		{
			rect.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rect.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;

			rectDescLocal.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectDescLocal.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;

			rectOnOff.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectOnOff.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;
		}
	}
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       Createstatus_window
*/

//const char* KeyStr[COMM_STAT_ERROR+1] = {
//	"KEY_SETUP",
//	"KEY_UP",
//	"KEY_DOWN",
//	"KEY_ENTER",
//	"KEY_CANCEL",
//	"DATA_RECV",
//	"TIME_OUT",
//	"KEY_COMM_ERROR",
//	"COMM_STAT_ERROR",
//};

// PRQA S 1503 1
void StuMccbIo(void)
{
	uint8_t bRecvData;
	int flagBreak = FALSE;
	bRecvData = FALSE;
	bUpdateFirst = TRUE;
	AcbMccbControlDisp();

	ReadyToSend();
	gStatusSendEnd = STATUS_SEND_END;
	statusSendStep = 0;
	nSendStep = 0;

	AcbMccbControlSend();
	int bCommError = gCommStatus[gDeviceIndex];
	while (1)
    {
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			nSendStep = 0;
			AcbMccbControlSend();
		}
		else
		if(key == KEY_ENTER)
		{
			if(bRecvData == TRUE)
			{
				int flag = ControlCheck();
				(void)printf("nRemote=%d, flag=%d\n", nRemote, flag);
				if((nRemote == TRUE) && (flag == TRUE))
				{
					char buf[MESSAGE_BUF_SIZE];
					uint8_t status = AcbMccbcbStatus;
					uint16_t address=CB_STATUS_NOT_TRIO_ADDR;

					if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
					{
						if(status == CB_STATUS_INPUT_FAULT)
						{
							status = 0;
							address = CB_STATUS_MCCB_TRIP_ADDR;
						}
						else
						{
							address = CB_STATUS_MCCB_ADDR;
						}
					}
					else
					{
						if(nTrio[gDeviceIndex] != INDEX_7)		// TRIO 결선000b: TRIO Only, 001b: TRIO+ACB_OCR, 010b: TRIO+MCCB, 111b: ACB OCR Only
						{
							address = CB_STATUS_TRIO_ADDR;
						}
					}
					if(SettingValue[SETUP_PASSWORD_USE] == 0)
						(void)sprintf(buf, _acacbMccbcontrol_confirm_nopassword_text[SettingValue[SETUP_LANGUAGE]], _accb_control_status[SettingValue[SETUP_LANGUAGE]][AcbMccbcbStatus]);
					else
						(void)sprintf(buf, _acacbMccbcontrol_confirm_text[SettingValue[SETUP_LANGUAGE]], _accb_control_status[SettingValue[SETUP_LANGUAGE]][AcbMccbcbStatus]);
					ControlSet(status, address, 0, buf, 1);
				}
				else
				{
					ControlErrorMessage(_acCBSetting_invalid_text[SettingValue[SETUP_LANGUAGE]]);
				}
				bUpdateFirst = TRUE;
				DispStatus();
				AcbMccbControlDisp();
				AcbMccbControlSend();
				gCommOldStatus[gDeviceIndex] = -1;
//				CommTimerInit();
			}
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			AcbMccbControlDisp();
			gCommOldStatus[gDeviceIndex] = -1;
			AcbMccbControlSend();
		}
		else
		if(key == DATA_RECV)
		{
			//(void)printf("DATA_RECV gStatusSendEnd=%d\n",gStatusSendEnd);
			if(bCommError == COMM_ERROR)
			{
				AcbMccbControlDisp();
				bCommError = COMM_OK;
			}
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				StatusRecv();
				AcbMccbControlSend();
			}
			else
			{
				AcbMccbIoValueDisp();
				g_bRecvAllDone = TRUE;
				nSendStep = 0;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
				bRecvData = TRUE;
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{

			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
					AcbMccbControlSend();
					g_bRecvAllDone = TRUE;
					(void)printf("All done!!!\n");
					gStatusSendEnd = STATUS_SEND_ING;
					statusSendStep = 0;
					nSendStep = 0;
			}
/*
			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(gAcbMccbSend == TRUE)
			{
				gAcbMccbSend =FALSE;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
			}
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				gAcbMccbSend = TRUE;
				AcbMccbControlSend();
			}
*/
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			bUpdateFirst = TRUE;
			(void)printf("COMM_STAT_ERROR\n\n");
			bCommError = COMM_ERROR;
			AcbMccbControlDisp();
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
	}
}

static void TrioIoSend(void)
{
	if(StatusSend() == STATUS_SEND_ING)
	{
		return;
	}
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
	{
		ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, TRIO_IO_READ_ADDR, TRIO_IO_READ_LEN);	// 30183 ~ 30185
	}
}

static void TrioPageDisp(int page)
{
	int x = PAGE_X;
	int y = PAGE_Y + (PAGE_HEIGHT*3) + (PAGE_HEIGHT / 2);

	for(int i = 0; i < INDEX_2; i++)
	{
		if( i == page)
		{
			GUI_SetColor(COLOR_VALUE);
		}
		else
		{
			GUI_SetColor(COLOR_LINE);
		}
		GUI_FillCircle(x, y, PAGE_RADIUS);
		y += PAGE_HEIGHT;
	}
}

bool	 bDioStatus[TRIO_IO_STATUS_COUNT];
static void TrioIoValueDisp(int nPos)
{
	uint16_t nDioValue[DIO_STATUS_MAX];
	static const uint16_t IoStatus_Offset[TRIO_IO_STATUS_COUNT] =
	{
			0,
			0,
			0,
			0,
			0,
			1,
			1,
			1,
	};
	static const uint16_t IoStatus_bit[TRIO_IO_STATUS_COUNT] =
	{
			0x0000,
			0x0001,
			0x0002,
			0x0004,
			0x0008,
			0x0001,
			0x0002,
			0x0004,
	};
	static GUI_COLOR colorOnFillColor[OPEN_CLOSE_TRIP] =
	{
			CB_OPEN_ON_COLOR,
			CB_CLOSE_ON_COLOR,
			TRIP_ON_COLOR
	};

	if(ModbusGetUint16(I_REGISTER_183) & CB_ACB_TRIO_REMOTE_MASK)
	{
		nRemote = TRUE;
	}
	else
	{
		nRemote = FALSE;
	}
	nDioValue[INDEX_0] = ModbusGetUint16(I_REGISTER_184);
	nDioValue[INDEX_1] = ModbusGetUint16(I_REGISTER_185);
	for(int i = 0; i < TRIO_IO_STATUS_COUNT; i++)
	{
		if((nDioValue[IoStatus_Offset[i]] & IoStatus_bit[i]) == 0)
			bDioStatus[i] = false;
		else
			bDioStatus[i] = true;
	}
	ControlDoStatus[0] = bDioStatus[INDEX_5];
	ControlDoStatus[1] = bDioStatus[INDEX_6];
	ControlDoStatus[2] = bDioStatus[INDEX_7];


	if((nDioValue[INDEX_1] & CB_REMOTE_MASK) == 0)
	{
		bDioStatus[0] = false;
	}
	else
	{
		bDioStatus[0] = true;
	}

	LanguageSelect(FONT20B);
	GUI_SetColor(GUI_BLACK);

	uint8_t status = (nDioValue[INDEX_0] >> CB_STATUS_SHIFT) & CB_STATUS_MASK;		// 0x00: Open 0x01: Close  0x03: Error

	AcbMccbcbStatus = status;

	if(status != 0x03 && (bUpdateFirst == TRUE) || (TrioIocbStatus != status))
	{
		TrioIocbStatus = status;
		GUI_FillRectEx(&rectTrioBox);
		for(uint8_t i = 0; i < INDEX_2; i++)
		{
			if(i == TrioIocbStatus)
			{
				GUI_SetColor(colorOnFillColor[i]);
				GUI_FillRectEx(&rectTrioStatus[i]);

				GUI_SetBkColor(colorOnFillColor[i]);
				GUI_SetColor(GUI_WHITE);
			}
			else
			{
				GUI_SetColor(colorOffFillColor[i]);
				GUI_FillRectEx(&rectTrioStatus[i]);

				GUI_SetBkColor(colorOffFillColor[i]);
				GUI_SetColor(colorOffTextColor[i]);
			}
			LanguageSelect(FONT20B);
			GUI_DispStringInRect(_accb_status[SettingValue[SETUP_LANGUAGE]][i], &rectTrioStatus[i], GUI_TA_HCENTER | GUI_TA_VCENTER);

		}
	}
	bUpdateFirst = FALSE;

	GUI_RECT rect;
	rect.x0 = TRIO_IOSTATUS_START_X;
	rect.x1 = (TRIO_IOSTATUS_START_X + TRIO_IOSTATUS_BOX_WIDTH) - 1;
	rect.y0 = TRIO_IOSTATUS_START_Y + TRIO_IOSTATUS_Y_DISTANCE;
	rect.y1 = (rect.y0 + TRIO_IOSTATUS_BOX_HEIGHT) - 1;

	GUI_RECT rectOnOff;
	rectOnOff.x0 = TRIO_IOSTATUS_START_X + TRIO_IOSTATUS_STATUS_X;
	rectOnOff.x1 = (rectOnOff.x0 + TRIO_IOSTATUS_STATUS_WIDTH) - 1;
	rectOnOff.y0 = TRIO_IOSTATUS_START_Y + TRIO_IOSTATUS_STATUS_Y + TRIO_IOSTATUS_Y_DISTANCE;
	rectOnOff.y1 = (rectOnOff.y0 + TRIO_IOSTATUS_STATUS_HEIGHT) - 1;

	int count = IO_STATUS_COUNT;
	int pos = 0;
	if(nPos >= INDEX_2)
	{
		pos = INDEX_2;
		count = INDEX_2;
	}

	for(int i = 0; i < count; i++, pos++)
	{
		GUI_SetColor(COLOR_LINE);
		GUI_DrawRectEx(&rect);

		GUI_SetBkColor(COLOR_MAIN_BG);
		GUI_SetColor(COLOR_LABEL);
		LanguageSelect(FONT20);
		if(bDioStatus[pos] == true)
		{
			GUI_SetColor(COLOR_ON);
			GUI_SetBkColor(COLOR_ON);
			GUI_FillRectEx(&rectOnOff);
			GUI_SetColor(GUI_WHITE);
			LanguageSelect(FONT20B);
			GUI_DispStringInRect(_aconoff_text[SettingValue[SETUP_LANGUAGE]][ON], &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);
		}
		else
		{
			GUI_SetColor(COLOR_OFF);
			GUI_SetBkColor(COLOR_OFF);
			GUI_FillRectEx(&rectOnOff);
			GUI_SetColor(GUI_WHITE);
			LanguageSelect(FONT20B);
			GUI_DispStringInRect(_aconoff_text[SettingValue[SETUP_LANGUAGE]][OFF], &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);
		}
		if(i == INDEX_2)
		{
			rect.x0 += TRIO_IOSTATUS_X_DISTANCE;
			rect.x1 += TRIO_IOSTATUS_X_DISTANCE;
			rectOnOff.x0 += TRIO_IOSTATUS_X_DISTANCE;
			rectOnOff.x1 += TRIO_IOSTATUS_X_DISTANCE;

			rect.y0 = TRIO_IOSTATUS_START_Y + TRIO_IOSTATUS_Y_DISTANCE;
			rect.y1 = (rect.y0 + TRIO_IOSTATUS_BOX_HEIGHT) - 1;
			rectOnOff.y0 = TRIO_IOSTATUS_START_Y + TRIO_IOSTATUS_STATUS_Y + TRIO_IOSTATUS_Y_DISTANCE;
			rectOnOff.y1 = (rectOnOff.y0 + TRIO_IOSTATUS_STATUS_HEIGHT) - 1;
		}
		else
		{
			rect.y0 += TRIO_IOSTATUS_Y_DISTANCE;
			rect.y1 += TRIO_IOSTATUS_Y_DISTANCE;

			rectOnOff.y0 += TRIO_IOSTATUS_Y_DISTANCE;
			rectOnOff.y1 += TRIO_IOSTATUS_Y_DISTANCE;
		}
	}
}

static void TrioIoDisp(int nPos)
{
	GUI_SetBkColor(COLOR_MAIN_BG);
	(void)GUI_SetPenSize(PENSIZE_LINE);
	(void)GUI_SetFont(&GUI_Font20_ASCII);

	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);

	int page = 0;
	if(nPos >= INDEX_2)
	{
		page = 1;
	}
	TrioPageDisp(page);

	GUI_RECT rect;
	rect.x0 = TRIO_IOSTATUS_START_X;
	rect.x1 = (TRIO_IOSTATUS_START_X + TRIO_IOSTATUS_X_DISTANCE + TRIO_IOSTATUS_BOX_WIDTH) - 1;
	rect.y0 = TRIO_IOSTATUS_START_Y;
	rect.y1 = TRIO_IOSTATUS_START_Y + TRIO_IOSTATUS_BOX_HEIGHT;

	GUI_RECT rectDescLocal;
	rectDescLocal.x0 = TRIO_IOSTATUS_START_X + TRIO_IOSTATUS_DESC_X;
	rectDescLocal.x1 = (rectDescLocal.x0 + TRIO_IOSTATUS_BOX_WIDTH) - 1;
	rectDescLocal.y0 = TRIO_IOSTATUS_START_Y;
	rectDescLocal.y1 = (rectDescLocal.y0 + TRIO_IOSTATUS_BOX_HEIGHT) - 1;

	if(nPos == 0 && gCommStatus[gDeviceIndex] == COMM_OK)
	{
		GUI_SetColor(COLOR_MENU_SELECTED);
		GUI_FillRectEx(&rect);

		GUI_SetBkColor(COLOR_MENU_SELECTED);
		GUI_SetColor(GUI_WHITE);
		LanguageSelect(FONT20B);
	}
	else
	{
		GUI_SetColor(COLOR_MAIN_BG);
		GUI_FillRectEx(&rect);

		GUI_SetColor(COLOR_LINE);
		GUI_DrawRectEx(&rect);

		GUI_SetColor(GUI_WHITE);
		LanguageSelect(FONT20);
	}

	GUI_DispStringInRect(_actrio_io_cbstatus_control_text[SettingValue[SETUP_LANGUAGE]], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);

	GUI_SetColor(GUI_BLACK);

	GUI_FillRectEx(&rectTrioBox);
	for(int i = 0; i < INDEX_2; i++)
	{
		GUI_SetColor(colorOffFillColor[i]);
		GUI_FillRectEx(&rectTrioStatus[i]);

		GUI_SetBkColor(colorOffFillColor[i]);
		GUI_SetColor(colorOffTextColor[i]);
		GUI_DispStringInRect(_accb_status[SettingValue[SETUP_LANGUAGE]][i], &rectTrioStatus[i], GUI_TA_HCENTER | GUI_TA_VCENTER);

	}

	rect.x0 = TRIO_IOSTATUS_START_X;
	rect.x1 = (TRIO_IOSTATUS_START_X + TRIO_IOSTATUS_BOX_WIDTH) - 1;
	rect.y0 = TRIO_IOSTATUS_START_Y + TRIO_IOSTATUS_Y_DISTANCE;
	rect.y1 = (rect.y0 + TRIO_IOSTATUS_BOX_HEIGHT) - 1;

	rectDescLocal.x0 = TRIO_IOSTATUS_START_X + TRIO_IOSTATUS_DESC_X;
	rectDescLocal.x1 = TRIO_IOSTATUS_STATUS_X - 1;
	rectDescLocal.y0 = TRIO_IOSTATUS_START_Y + TRIO_IOSTATUS_Y_DISTANCE;
	rectDescLocal.y1 = (rectDescLocal.y0 + TRIO_IOSTATUS_BOX_HEIGHT) - 1;

	GUI_RECT rectOnOff;
	rectOnOff.x0 = TRIO_IOSTATUS_START_X + TRIO_IOSTATUS_STATUS_X;
	rectOnOff.x1 = (rectOnOff.x0 + TRIO_IOSTATUS_STATUS_WIDTH) - 1;
	rectOnOff.y0 = TRIO_IOSTATUS_START_Y + TRIO_IOSTATUS_STATUS_Y + TRIO_IOSTATUS_Y_DISTANCE;
	rectOnOff.y1 = (rectOnOff.y0 + TRIO_IOSTATUS_STATUS_HEIGHT) - 1;

	char *disableStatus = "-";

	int count = IO_STATUS_COUNT;
	int pos = 0;
	if(page == 1)
	{
		count = 2;
		pos = INDEX_2;
	}

	for(int i = 0; i < count; i++, pos++)
	{
		GUI_SetColor(COLOR_LINE);
		GUI_DrawRectEx(&rect);

		if((nPos == INDEX_1 && i == INDEX_5 ) || (nPos == INDEX_2 && i == 0) || (nPos == INDEX_3 && i == INDEX_1 ))
		{
			GUI_SetColor(COLOR_MENU_SELECTED);
			GUI_FillRectEx(&rect);
			GUI_SetBkColor(COLOR_MENU_SELECTED);
		}
		else
		{
			GUI_SetColor(COLOR_LINE);
			GUI_DrawRectEx(&rect);
			GUI_SetBkColor(COLOR_MAIN_BG);
		}
//		GUI_SetColor(OFF_ON_BOX_COLOR);
		GUI_SetColor(GUI_WHITE);
		LanguageSelect(FONT20);
		GUI_DispStringInRect(_actrio_io_iostatus_text[page][i], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);


		LanguageSelect(FONT20);
		if(bUpdateFirst == TRUE)
		{
			GUI_SetColor(OFF_ON_BOX_COLOR);
			GUI_FillRectEx(&rectOnOff);
			GUI_SetColor(COLOR_LABEL);
			GUI_SetBkColor(OFF_ON_BOX_COLOR);
			GUI_DispStringInRect(disableStatus, &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);
		}
		else
		{
			if(bDioStatus[pos] == true)
			{
				GUI_SetColor(COLOR_ON);
				GUI_SetBkColor(COLOR_ON);
				GUI_FillRectEx(&rectOnOff);
				GUI_SetColor(GUI_WHITE);
				LanguageSelect(FONT20B);
				GUI_DispStringInRect(_aconoff_text[SettingValue[SETUP_LANGUAGE]][ON], &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);
			}
			else
			{
				GUI_SetColor(COLOR_OFF);
				GUI_SetBkColor(COLOR_OFF);
				GUI_FillRectEx(&rectOnOff);
				GUI_SetColor(GUI_WHITE);
				LanguageSelect(FONT20B);
				GUI_DispStringInRect(_aconoff_text[SettingValue[SETUP_LANGUAGE]][OFF], &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);
			}
		}

		if(i == INDEX_2)
		{
			rect.x0 += TRIO_IOSTATUS_X_DISTANCE;
			rect.x1 += TRIO_IOSTATUS_X_DISTANCE;
			rectDescLocal.x0 += TRIO_IOSTATUS_X_DISTANCE;
			rectDescLocal.x1 += TRIO_IOSTATUS_X_DISTANCE;
			rectOnOff.x0 += TRIO_IOSTATUS_X_DISTANCE;
			rectOnOff.x1 += TRIO_IOSTATUS_X_DISTANCE;

			rect.y0 = TRIO_IOSTATUS_START_Y + TRIO_IOSTATUS_Y_DISTANCE;
			rect.y1 = (rect.y0 + TRIO_IOSTATUS_BOX_HEIGHT) - 1;
			rectDescLocal.y0 = TRIO_IOSTATUS_START_Y + TRIO_IOSTATUS_Y_DISTANCE;
			rectDescLocal.y1 = (rectDescLocal.y0 + TRIO_IOSTATUS_BOX_HEIGHT) - 1;
			rectOnOff.y0 = TRIO_IOSTATUS_START_Y + TRIO_IOSTATUS_STATUS_Y + TRIO_IOSTATUS_Y_DISTANCE;
			rectOnOff.y1 = (rectOnOff.y0 + TRIO_IOSTATUS_STATUS_HEIGHT) - 1;
		}
		else
		{
			rect.y0 += TRIO_IOSTATUS_Y_DISTANCE;
			rect.y1 += TRIO_IOSTATUS_Y_DISTANCE;

			rectDescLocal.y0 += TRIO_IOSTATUS_Y_DISTANCE;
			rectDescLocal.y1 += TRIO_IOSTATUS_Y_DISTANCE;

			rectOnOff.y0 += TRIO_IOSTATUS_Y_DISTANCE;
			rectOnOff.y1 += TRIO_IOSTATUS_Y_DISTANCE;
		}
	}
}

// PRQA S 1503 1
static void TrioIo(void)
{
	uint8_t bRecvData = FALSE;
	int flagBreak = FALSE;
	int pos = 0;
	bUpdateFirst = TRUE;
	TrioIoDisp(pos);
	ReadyToSend();
	gStatusSendEnd = STATUS_SEND_END;
	statusSendStep = 0;
	nSendStep = 0;
	TrioIoSend();
	int bCommError = gCommStatus[gDeviceIndex];
	while (1)
    {
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			nSendStep = 0;
			TrioIoSend();
		}
		else
		if(key == KEY_ENTER)
		{
			if(bRecvData == TRUE)
			{
				if(nRemote == FALSE)
				{
					ControlErrorMessage(_acCBSetting_invalid_text[SettingValue[SETUP_LANGUAGE]]);
					bUpdateFirst = TRUE;
					DispStatus();
					TrioIoDisp(pos);
					TrioIoSend();
					gCommOldStatus[gDeviceIndex] = -1;
					continue;
				}
				if(pos == 0)
				{
					int flag = ControlCheck();
					(void)printf("nRemote=%d, flag=%d\n", nRemote, flag);
					if((nRemote == TRUE) && (flag == TRUE))
					{
						char buf[MESSAGE_BUF_SIZE];
						uint8_t status = AcbMccbcbStatus;
						uint16_t address=CB_STATUS_NOT_TRIO_ADDR;

						if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
						{
							if(status == CB_STATUS_INPUT_FAULT)
							{
								status = 0;
								address = CB_STATUS_MCCB_TRIP_ADDR;
							}
							else
							{
								address = CB_STATUS_MCCB_ADDR;
							}
						}
						else
						{
							if(nTrio[gDeviceIndex] != INDEX_7)		// TRIO 결선000b: TRIO Only, 001b: TRIO+ACB_OCR, 010b: TRIO+MCCB, 111b: ACB OCR Only
							{
								address = CB_STATUS_TRIO_ADDR;
							}
						}
						if(SettingValue[SETUP_PASSWORD_USE] == 0)
							(void)sprintf(buf, _acacbMccbcontrol_confirm_nopassword_text[SettingValue[SETUP_LANGUAGE]], _accb_control_status[SettingValue[SETUP_LANGUAGE]][AcbMccbcbStatus]);
						else
							(void)sprintf(buf, _acacbMccbcontrol_confirm_text[SettingValue[SETUP_LANGUAGE]], _accb_control_status[SettingValue[SETUP_LANGUAGE]][AcbMccbcbStatus]);
						ControlSet(status, address, 0, buf, 1);
					}
					else
					{
						ControlErrorMessage(_acCBSetting_invalid_text[SettingValue[SETUP_LANGUAGE]]);
					}
					bUpdateFirst = TRUE;
					DispStatus();
					TrioIoDisp(pos);
					TrioIoSend();
					gCommOldStatus[gDeviceIndex] = -1;
				}
				else
				{
					uint16_t address;
					uint8_t status = ControlDoStatus[pos-1];
					uint8_t dostatus = status;
					uint8_t nSBO = 1;
					int nPoint = pos - 1;

					address = TRIO_SBO_START_ADDR;
					if(status == ON)
					{
						address += INDEX_2;
					}
					status = OFF;			// 무조건 On으로 제어 -> Index 증가 없음
					if(SettingValue[SETUP_PASSWORD_USE] == 0)
						ControlSet(nPoint, address, status, _accontrol_confirm_nopassword_text[SettingValue[SETUP_LANGUAGE]][dostatus], nSBO);
					else
						ControlSet(nPoint, address, status, _accontrol_confirm_text[SettingValue[SETUP_LANGUAGE]][dostatus], nSBO);
					bUpdateFirst = TRUE;
					DispStatus();
					TrioIoDisp(pos);
					TrioIoSend();
					gCommOldStatus[gDeviceIndex] = -1;
				}
			}
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			TrioIoDisp(pos);
			gCommOldStatus[gDeviceIndex] = -1;
			TrioIoSend();
		}
		else
		if(key == KEY_UP)
		{
			if(pos == 0)
			{
				pos = INDEX_3;
			}
			else
			{
				pos--;
			}
			bUpdateFirst = TRUE;
			TrioIoDisp(pos);
		}
		else
		if(key == KEY_DOWN)
		{
			if(pos == INDEX_3)
			{
				pos = 0;
			}
			else
			{
				pos++;
			}
			bUpdateFirst = TRUE;
			TrioIoDisp(pos);
		}
		else
		if(key == DATA_RECV)
		{
			(void)printf("DATA_RECV gStatusSendEnd=%d\n",gStatusSendEnd);
			if(bCommError == COMM_ERROR)
			{
				TrioIoDisp(pos);
				bCommError = COMM_OK;
			}
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				StatusRecv();
				TrioIoSend();
			}
			else
			{
				TrioIoValueDisp(pos);
				g_bRecvAllDone = TRUE;
				nSendStep = 0;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
				bRecvData = TRUE;
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{

			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
					TrioIoSend();
					g_bRecvAllDone = TRUE;
					(void)printf("All done!!!\n");
					gStatusSendEnd = STATUS_SEND_ING;
					statusSendStep = 0;
					nSendStep = 0;
			}
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			bUpdateFirst = TRUE;
			(void)printf("COMM_STAT_ERROR\n\n");
			bCommError = COMM_ERROR;
			TrioIoDisp(pos);
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
	}
}

#define TRIO_TEMP_MAX					4

#define TRIO_TEMP_LABEL_HEIGHT			34
#define TRIO_TEMP_LABEL_WIDTH			30
#define TRIO_TEMP_LABEL_DISTANCE		57

#define TRIO_TEMP_LABEL_X0				29
#define TRIO_TEMP_LABEL_X1				((TRIO_TEMP_LABEL_X0 + TRIO_TEMP_LABEL_WIDTH) - 1)
#define TRIO_TEMP_LABEL_Y0				90
#define TRIO_TEMP_LABEL_Y1				((TRIO_TEMP_LABEL_Y0 + TRIO_TEMP_LABEL_HEIGHT) - 1)



#define TRIO_TEMP_DIVITION_LINE_X0		85
#define TRIO_TEMP_DIVITION_LINE_Y0		74
#define TRIO_TEMP_DIVITION_LINE_Y1		TRIO_TEMP_DIVITION_LINE_Y0 + 226
#define TRIO_TEMP_DIVITION_LINE_X_INC	64
#define TRIO_TEMP_DIVITION_LINE_CNT		5

#define TRIO_TEMP_TEXT_X0				24
#define TRIO_TEMP_TEXT_X1				38
#define TRIO_TEMP_TEXT_Y1				14

#define TRIO_TEMP_X_TEXT_X0				137
#define TRIO_TEMP_X_TEXT_Y				52
#define TRIO_TEMP_X_TEXT_X1				24
#define TRIO_TEMP_X_TEXT_Y1				14

#define TRIO_TEMP_BAR_X0				88
#define TRIO_TEMP_BAR_Y0				84
#define TRIO_TEMP_BAR_X1				TRIO_TEMP_BAR_X0 + 10
#define TRIO_TEMP_BAR_Y1				TRIO_TEMP_BAR_Y0 + 35
#define TRIO_TEMP_BAR_X_DISTANCE		12
#define TRIO_TEMP_BAR_Y_DISTANCE		56

#define TRIO_TEMP_UNIT_X				435
#define TRIO_TEMP_UNIT_Y				95

#define TRIO_TEMP_VALUE_X0				366
#define TRIO_TEMP_VALUE_Y0				86
#define TRIO_TEMP_VALUE_X1				TRIO_TEMP_VALUE_X0 + 65
#define TRIO_TEMP_VALUE_Y1				TRIO_TEMP_VALUE_Y0 + 35

#define TRIO_TEMP_READ_ADDR				186
#define TRIO_TEMP_READ_LEN				26
#define I_REGISTER_186					186

#define	VALUE150						150
#define	VALUE100						100


static void TrioTempValueDisp(void)
{
	static const GUI_COLOR _BarColor[INDEX_4] = {
		0x0000ff, 0x00deff, 0x0fce00, 0x3a3939
	};
	static float	aiValue[TRIO_TEMP_MAX];
	uint16_t		barGraph[TRIO_TEMP_MAX];

	if(gCommStatus[gDeviceIndex] == COMM_ERROR)
	{
		return;
	}
	int index =  I_REGISTER_186;
	GUI_SetBkColor(COLOR_MAIN_BG);
	(void)GUI_SetFont(&GUI_Font32B_ASCII);
	GUI_SetColor(COLOR_VALUE);
	GUI_RECT rect;
	rect.x0 = TRIO_TEMP_VALUE_X0;
	rect.x1 = TRIO_TEMP_VALUE_X1;
	rect.y0 = TRIO_TEMP_VALUE_Y0;
	rect.y1 = TRIO_TEMP_VALUE_Y1;

/*	aiValue[0] = 59.9;
	aiValue[1] = 99.999;
	aiValue[2] = 100.1;
	aiValue[3] = 150;
*/
	for(int i = 0; i < TRIO_TEMP_MAX; i++)
	{
		char buf[20];
		aiValue[i] =  ModbusGetFloat(index);
		GUI_ClearRect(rect.x0, rect.y0, rect.x1, rect.y1);
		sprintf(buf, "%3d",(int)aiValue[i]);
		GUI_DispStringInRect(buf, &rect, (GUI_TA_RIGHT | GUI_TA_VCENTER));
		rect.y0 += TRIO_TEMP_LABEL_DISTANCE;
		rect.y1 += TRIO_TEMP_LABEL_DISTANCE;
		index +=  INDEX_2;
		if(aiValue[i] <= 0)
			barGraph[i] = 0;
		else
			barGraph[i] = (int)(aiValue[i] / INDEX_10) + 1;
// printf("i=%d, barGraph[i]=%d, value=%f\n",i, barGraph[i], aiValue[i]);
	}
	int y0 = TRIO_TEMP_BAR_Y0;
	int y1 = TRIO_TEMP_BAR_Y1;
	for(int i = 0; i < TRIO_TEMP_MAX; i++)
	{
		if(aiValue[i] >= VALUE150)
		{
			GUI_SetColor(_BarColor[INDEX_0]);
		}
		else
		if(aiValue[i] >= VALUE100)
		{
			GUI_SetColor(_BarColor[INDEX_1]);
		}
		else
		{
			GUI_SetColor(_BarColor[INDEX_2]);
		}
		int x0 = TRIO_TEMP_BAR_X0;
		int x1 = TRIO_TEMP_BAR_X1;
		for(int j = 0; j < INDEX_20; j++)
		{
			if(barGraph[i] <= j)
			{
				GUI_SetColor(_BarColor[INDEX_3]);
			}
			GUI_FillRect(x0, y0, x1, y1);
			x0 += TRIO_TEMP_BAR_X_DISTANCE;
			x1 += TRIO_TEMP_BAR_X_DISTANCE;
			if((j == INDEX_4) || (j ==INDEX_9) || (j ==INDEX_14))
			{
				x0 += INDEX_4;
				x1 += INDEX_4;
			}
		}
		y0 += TRIO_TEMP_BAR_Y_DISTANCE;
		y1 += TRIO_TEMP_BAR_Y_DISTANCE;
	}
}

static void TrioTempSend(void)
{
	if(StatusSend() == STATUS_SEND_ING)
	{
		return;
	}
	ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, I_REGISTER_186, INDEX_8);	// 30186~ 30193
}


static void TrioTempDisp(void)
{
	GUI_SetBkColor(COLOR_MAIN_BG);
	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	(void)GUI_SetFont(&GUI_Font13_ASCII);

	GUI_SetColor(COLOR_LABEL);
	GUI_RECT rect;
	rect.x0 = TRIO_TEMP_TEXT_X0;
	rect.x1 = TRIO_TEMP_TEXT_X0 + TRIO_TEMP_TEXT_X1;
	rect.y0 = TRIO_TEMP_X_TEXT_Y;
	rect.y1 = TRIO_TEMP_X_TEXT_Y + TRIO_TEMP_TEXT_Y1;
	GUI_DispStringInRect("TEMP", &rect, (GUI_TA_HCENTER | GUI_TA_VCENTER));

	GUI_SetColor(GUI_WHITE);
	rect.x0 = TRIO_TEMP_X_TEXT_X0;
	rect.x1 = TRIO_TEMP_X_TEXT_X0 + TRIO_TEMP_X_TEXT_X1;
 	for(int i = 0; i < TRIO_TEMP_DIVITION_LINE_CNT-1; i++)
	{
		char buf[10];
		sprintf(buf, "%d", (i+1)*50);
		GUI_DispStringInRect(buf, &rect, (GUI_TA_HCENTER | GUI_TA_VCENTER));
		rect.x0 += TRIO_TEMP_DIVITION_LINE_X_INC;
		rect.x1 += TRIO_TEMP_DIVITION_LINE_X_INC;
	}

	GUI_SetColor(COLOR_LINE);
	rect.x0 = TRIO_TEMP_DIVITION_LINE_X0;
	rect.y0 = TRIO_TEMP_DIVITION_LINE_Y0;
	rect.y1 = TRIO_TEMP_DIVITION_LINE_Y1;
	(void)GUI_SetPenSize(PENSIZE_LINE);
	for(int i = 0; i < TRIO_TEMP_DIVITION_LINE_CNT; i++)
	{
		GUI_DrawVLine(rect.x0, rect.y0, rect.y1);
		rect.x0 += TRIO_TEMP_DIVITION_LINE_X_INC;
	}

	(void)GUI_SetFont(&GUI_Font32B_ASCII);
	GUI_SetColor(COLOR_LABEL);
	rect.x0 = TRIO_TEMP_LABEL_X0;
	rect.y0 = TRIO_TEMP_LABEL_Y0;
	rect.x1 = TRIO_TEMP_LABEL_X1;
	rect.y1 = TRIO_TEMP_LABEL_Y1;

	for(int i = 0; i < TRIO_TEMP_MAX; i++)
	{
		char buf[10];
		sprintf(buf,"#%d", i+1);
		GUI_DispStringInRect(buf,  &rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
		rect.y0 += TRIO_TEMP_LABEL_DISTANCE;
		rect.y1 += TRIO_TEMP_LABEL_DISTANCE;
	}

	(void)GUI_SetFont(&GUI_Font16B_1);
	GUI_SetColor(COLOR_DISABLE);
	int y0 = TRIO_TEMP_BAR_Y0;
	int y1 = TRIO_TEMP_BAR_Y1;

	printf("Bar \n");
	for(int i = 0; i < TRIO_TEMP_MAX; i++)
	{
		int x0 = TRIO_TEMP_BAR_X0;
		int x1 = TRIO_TEMP_BAR_X1;
		for(int j = 0; j < INDEX_20; j++)
		{
			GUI_FillRect(x0, y0, x1, y1);
			x0 += TRIO_TEMP_BAR_X_DISTANCE;
			x1 += TRIO_TEMP_BAR_X_DISTANCE;
			if((j == INDEX_4) || (j ==INDEX_9) || (j ==INDEX_14))
			{
				x0 += INDEX_4;
				x1 += INDEX_4;
			}
		}
		y0 += TRIO_TEMP_BAR_Y_DISTANCE;
		y1 += TRIO_TEMP_BAR_Y_DISTANCE;
	}

	int x = TRIO_TEMP_UNIT_X;
	int y = TRIO_TEMP_UNIT_Y;
	for(int i = 0; i < TRIO_TEMP_MAX; i++)
	{
		GUI_DrawBitmap(&bmCelsius, x, y);
		y += TRIO_TEMP_LABEL_DISTANCE;
	}

}

void TrioTemp(void)
{
	int flagBreak = FALSE;
	bUpdateFirst = TRUE;
	TrioTempDisp();
	ReadyToSend();
	gStatusSendEnd = STATUS_SEND_END;
	statusSendStep = 0;
	nSendStep = 0;
	TrioTempSend();
	int bCommError = gCommStatus[gDeviceIndex];
	while (1)
    {
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			nSendStep = 0;
			TrioTempSend();
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			AcbMccbControlDisp();
			gCommOldStatus[gDeviceIndex] = -1;
			TrioTempSend();
		}
		else
		if(key == DATA_RECV)
		{
//			(void)printf("DATA_RECV gStatusSendEnd=%d\n",gStatusSendEnd);
			if(bCommError == COMM_ERROR)
			{
				TrioTempDisp();
				bCommError = COMM_OK;
			}
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				StatusRecv();
				TrioTempSend();
			}
			else
			{
				TrioTempValueDisp();
				g_bRecvAllDone = TRUE;
				nSendStep = 0;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{

			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
					TrioTempSend();
					g_bRecvAllDone = TRUE;
					(void)printf("All done!!!\n");
					gStatusSendEnd = STATUS_SEND_ING;
					statusSendStep = 0;
					nSendStep = 0;
			}
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			bUpdateFirst = TRUE;
			(void)printf("COMM_STAT_ERROR\n\n");
			bCommError = COMM_ERROR;
			TrioTempDisp();
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
	}
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       Createstatus_window
*/
//bool bDataRecv;
// PRQA S 1503 2
// PRQA S 1505 1

void AcbMccbControl(void)
{
	int flagBreak = FALSE;
	nMenuPos = 0;
	int nMenuCount = EVENT_MENU_COUNT;

	//   TRIO 결선
	// 000b: TRIO Only
	// 001b: TRIO+ACB_OCR
	// 010b: TRIO+MCCB
	// 111b: ACB OCR Only
	if(nTrio[gDeviceIndex] == 0)   //000b: TRIO Only
		nMenuPos = 1;
	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	InfoMenu(CONTROL_MENU, nMenuPos, nMenuCount);

	ReadyToSend();
//	gStatusSendEnd = STATUS_SEND_ING;
//	g_bRecvAllDone = FALSE;
	StatusSend();

	nSendStep = 0;
	while (1)
    {
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			nSendStep = 0;
			statusSendStep = 0;
			gStatusSendEnd = STATUS_SEND_ING;
			(void)StatusSend();
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
			InfoMenu(CONTROL_MENU, nMenuPos, nMenuCount);
			gCommOldStatus[gDeviceIndex] = -1;
		}
		else
		if(key == KEY_UP)
		{
			if(nMenuCount != INDEX_1)
			{
				if(nMenuPos > 0)
				{
					nMenuPos--;
				}
				else
				{
					nMenuPos = nMenuCount - 1;
				}
				if(nMenuPos == 0 && nTrio[gDeviceIndex] == 0)   //000b: TRIO Only
					nMenuPos = 1;
				InfoMenu(CONTROL_MENU, nMenuPos, nMenuCount);
			}
		}
		else
		if(key == KEY_DOWN)
		{
			if(nMenuCount != INDEX_1)
			{
				if(nMenuPos < (nMenuCount-1))
				{
					nMenuPos++;
				}
				else
				{
					nMenuPos = 0;
					if(nTrio[gDeviceIndex] == 0)   //000b: TRIO Only
						nMenuPos = 1;
				}
				InfoMenu(CONTROL_MENU, nMenuPos, nMenuCount);
			}
		}
		else
		if(key == KEY_ENTER)
		{
			if(nMenuPos == INDEX_0)
			{
				StuMccbIo();
			}
			else
			if(nMenuPos == INDEX_1)
			{
				TrioIo();
			}
			if(nMenuPos == INDEX_2)
			{
				TrioTemp();
			}
			InfoMenu(CONTROL_MENU, nMenuPos, nMenuCount);
		}
		else
		if(key == DATA_RECV)
		{
/*
			if(bDataRecv == false)
			{
				if(ConnectSetting[gDeviceIndex].Address == g_modbusRxBuff[0] &&  g_startAddr == I_REGISTER_183)
				{
					nTrio = (ModbusGetUint16(I_REGISTER_183) >> CB_TRIO_SHIFT) & CB_TRIO_MASK;	// TRIO 결선 000b: TRIO Only 001b: TRIO+ACB_OCR 010b: TRIO+MCCB 111b: ACB OCR Only
					if(nTrio == INDEX_7)
						nMenuCount = 1;
					else
						nMenuCount = EVENT_MENU_COUNT;

					if(nTrio == 0)
					{
						int kkk = 1;
					}
					printf("nTrio = %d\n", nTrio);
					InfoMenu(CONTROL_MENU, nMenuPos, nMenuCount);
					bDataRecv = true;
					nSendStep = 0;
					statusSendStep = 0;
					gStatusSendEnd =  STATUS_SEND_ING;
					StatusSend();
					gbSettingTime = FALSE;
				}
				else
				{
					ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, I_REGISTER_183, INDEX_1);	// 30183 ~ 30183
				}
			}
			else
*/			{
				StatusRecv();
				if(StatusSend() != STATUS_SEND_ING)
				{
					g_bRecvAllDone = TRUE;
	//				(void)printf("All done!!!\n");
					nSendStep = 0;
					statusSendStep = 0;
					gStatusSendEnd = STATUS_SEND_ING;
				}
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{
			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep);
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				g_bRecvAllDone = TRUE;
				(void)printf("All done!!!\n");
				gStatusSendEnd = STATUS_SEND_ING;
				statusSendStep = 0;
				nSendStep = 0;
			}
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
	}
}
/*************************** End of file ****************************/
