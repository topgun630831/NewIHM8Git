/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/


#define EXTERN extern
#include "stm32f4xx_hal.h"
#include "main.h"
#include "GuiData.h"

//const uint16_t IoStatus_Offset[IO_STATUS_COUNT] = {
//	0,
//	1,
//	0,
//	0,
//	0,
//	1,
//	1,
//	1
//};
//
//const uint16_t IoStatus_bit[IO_STATUS_COUNT] = {
//	0x8000,
//	0x8000,
//	0x1000,
//	0x0200,
//	0x4000,
//	0x0001,
//	0x0002,
//	0x0004
//};
//

static uint8_t AcbMccbcbStatus;
static uint8_t bUpdateFirst;

static void AcbMccbControlSend(void);
static int ControlCheck(void);
static void AcbMccbIoValueDisp(void);
static void AcbMccbControlDisp(void);

static GUI_COLOR colorOffFillColor[OPEN_CLOSE_TRIP] = {
	CB_OPEN_OFF_COLOR,
	CB_CLOSE_OFF_COLOR,
	TRIP_OFF_COLOR
};

static GUI_COLOR colorOffTextColor[OPEN_CLOSE_TRIP] = {
	CB_OPEN_OFF_TEXT_COLOR,
	CB_CLOSE_OFF_TEXT_COLOR,
	TRIP_OFF_TEXT_COLOR
};

static void AcbMccbControlSend(void)
{
	if(StatusSend() == STATUS_SEND_ING)
	{
		return;
	}
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
	{
		ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, ACB_CONTROL_READ_ADDR, ACB_CONTROL_READ_LEN);	// 30183 ~ 30208
	}
	else
	{
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, INPUT_REGISTER, MCCB_CONTROL_READ_ADDR, MCCB_CONTROL_READ_LEN);	// 30204 ~ 30208
		}
	}
}

static uint8_t nDoSetting[CB_STATUS_DO_MAX];
static uint8_t nRemote;
static uint8_t nTrio;
static int ControlCheck(void)
{
	int ret = FALSE;
	uint16_t comp=CB_STATUS_OUTPUT_DEFAULT;

	if(AcbMccbcbStatus == CB_STATUS_INPUT_OPEN)	// Open
	{
		comp = CB_STATUS_OUTPUT_CLOSE;	// CB Close
	}
	else
	if(AcbMccbcbStatus == CB_STATUS_INPUT_CLOSE)	// Close
	{
		comp = CB_STATUS_OUTPUT_OPEN;	// CB Open
	}
	else
	if(AcbMccbcbStatus == CB_STATUS_INPUT_FAULT)	// Fault
	{
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			ret = TRUE;
		}
	}
	else {}
	(void)printf("===============================\ncbStatus=%d, com=%d, nTrio=%d\n", AcbMccbcbStatus, comp, nTrio);
	for(int i = 0; i < CB_STATUS_DO_MAX; i++)
	{
		(void)printf("i=%d, nDoSetting=%d\n", i, nDoSetting[i]);
		if(nDoSetting[i] == comp)
		{
			ret = TRUE;
		}
	}
	return ret;
}

static void AcbMccbIoValueDisp(void)
{
	uint16_t nDioStatus[DIO_STATUS_MAX];
	static const uint16_t IoStatus_Offset[IO_STATUS_COUNT] =
	{
			0,
			1,
			0,
			1,
			1,
			1
	};
	static const uint16_t IoStatus_bit[IO_STATUS_COUNT] =
	{
			0x8000,
			0x8000,
			0x4000,
			0x0001,
			0x0002,
			0x0004
	};
	static GUI_COLOR colorOnFillColor[OPEN_CLOSE_TRIP] =
	{
			CB_OPEN_ON_COLOR,
			CB_CLOSE_ON_COLOR,
			TRIP_ON_COLOR
	};

	nDioStatus[INDEX_0] = ModbusGetUint16(I_REGISTER_207);
	nDioStatus[INDEX_1] = ModbusGetUint16(I_REGISTER_208);
	if(ModbusGetUint16(I_REGISTER_206) & CB_REMOTE_MASK)
	{
		nRemote = TRUE;
	}
	else
	{
		nRemote = FALSE;
	}
	nDoSetting[INDEX_0] = ModbusGetUint8_U(I_REGISTER_204);
	nDoSetting[INDEX_1] = ModbusGetUint8_L(I_REGISTER_204);
	nDoSetting[INDEX_2] = ModbusGetUint8_U(I_REGISTER_205);

	nTrio = INDEX_0;

//	(void)GUI_SetFont(&GUI_Font20B_ASCII);
	LanguageSelect(FONT20B);
	GUI_SetColor(GUI_BLACK);

	uint8_t status = (ModbusGetUint16(I_REGISTER_208) >> CB_STATUS_SHIFT) & CB_STATUS_MASK;		// 0x00: Open(ACB OCR 사용) 0x01: Close(ACB OCR 사용) 0x02: Trip 0x03: Intermediate
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
	{
		nTrio = (ModbusGetUint16(I_REGISTER_183) >> CB_TRIO_SHIFT) & CB_TRIO_MASK;	// TRIO 결선 000b: TRIO Only 001b: TRIO+ACB_OCR 010b: TRIO+MCCB 111b: ACB OCR Only
		(void)printf("nTrio=%d\n", nTrio);
		if(nTrio != INDEX_7)		// ACB Only가 아니면
		{
			status = (ModbusGetUint16(I_REGISTER_184) >> CB_ACB_TRIO_SHIFT) & CB_ACB_TRIO_MASK;
			nDoSetting[INDEX_0] = INDEX_2;		//CB CLose
			nDoSetting[INDEX_1] = INDEX_3;		// CB Open

			if(ModbusGetUint16(I_REGISTER_183) & CB_ACB_TRIO_REMOTE_MASK)
			{
				nRemote = TRUE;
			}
			else
			{
				nRemote = FALSE;
			}
		}
	}
	else
	{
		nDoSetting[INDEX_2] = 0;
	}
	if((bUpdateFirst == TRUE) || (AcbMccbcbStatus != status))
	{
		AcbMccbcbStatus = status;
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			GUI_FillRectEx(&rectMccbBox);
			for(uint8_t i = 0; i < INDEX_3; i++)
			{
				if(i == AcbMccbcbStatus)
				{
					GUI_SetColor(colorOnFillColor[i]);
					GUI_FillRectEx(&rectMccbStatus[i]);

					GUI_SetBkColor(colorOnFillColor[i]);
					GUI_SetColor(GUI_WHITE);
				}
				else
				{
					GUI_SetColor(colorOffFillColor[i]);
					GUI_FillRectEx(&rectMccbStatus[i]);

					GUI_SetBkColor(colorOffFillColor[i]);
					GUI_SetColor(colorOffTextColor[i]);
				}
				LanguageSelect(FONT20B);
				GUI_DispStringInRect(_accb_status[SettingValue[SETUP_LANGUAGE]][i], &rectMccbStatus[i], GUI_TA_HCENTER | GUI_TA_VCENTER);

			}
		}
		else
		{
			GUI_FillRectEx(&rectAcbBox);
			for(uint8_t i = 0; i < INDEX_2; i++)
			{
				if(i == AcbMccbcbStatus)
				{
					GUI_SetColor(colorOnFillColor[i]);
					GUI_FillRectEx(&rectAcbStatus[i]);

					GUI_SetBkColor(colorOnFillColor[i]);
					GUI_SetColor(GUI_WHITE);
				}
				else
				{
					GUI_SetColor(colorOffFillColor[i]);
					GUI_FillRectEx(&rectAcbStatus[i]);

					GUI_SetBkColor(colorOffFillColor[i]);
					GUI_SetColor(colorOffTextColor[i]);
				}
				LanguageSelect(FONT20B);
				GUI_DispStringInRect(_accb_status[SettingValue[SETUP_LANGUAGE]][i], &rectAcbStatus[i], GUI_TA_HCENTER | GUI_TA_VCENTER);

			}
		}
	}
	bUpdateFirst = FALSE;

	GUI_RECT rect;
	rect.x0 = ACBMCCB_IOSTATUS_START_X;
	rect.x1 = (ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_BOX_WIDTH) - 1;
	rect.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rect.y1 = (rect.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;

	GUI_RECT rectDescLocal;
	rectDescLocal.x0 = ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_DESC_X;
	rectDescLocal.x1 = ACBMCCB_IOSTATUS_STATUS_X - 1;
	rectDescLocal.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rectDescLocal.y1 = (rectDescLocal.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;

	GUI_RECT rectOnOff;
	rectOnOff.x0 = ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_STATUS_X;
	rectOnOff.x1 = (rectOnOff.x0 + ACBMCCB_IOSTATUS_STATUS_WIDTH) - 1;
	rectOnOff.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_STATUS_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rectOnOff.y1 = (rectOnOff.y0 + ACBMCCB_IOSTATUS_STATUS_HEIGHT) - 1;

	char *disableStatus = "-";

	for(int i = 0; i < IO_STATUS_COUNT; i++)
	{
		GUI_SetColor(COLOR_LINE);
		GUI_DrawRectEx(&rect);

//		(void)GUI_SetFont(&GUI_Font20_ASCII);
		if(((ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB) &&
		   (((i == ZSI_IN) && (gAmpareFrame[gDeviceIndex] <= AF250)) 				// 250AF
			|| (i == ERMS)														// ERMS
			|| (i == DO3)))) //	||													// DO #3
		{
			GUI_SetBkColor(COLOR_MAIN_BG);
			GUI_SetColor(OFF_ON_BOX_COLOR);
			LanguageSelect(FONT20);
			GUI_DispStringInRect(_acacbmccb_iostatus_text[i], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);

			GUI_SetColor(OFF_ON_BOX_COLOR);
			GUI_FillRectEx(&rectOnOff);
			GUI_SetColor(COLOR_LABEL);
			GUI_SetBkColor(OFF_ON_BOX_COLOR);
			GUI_DispStringInRect(disableStatus, &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);
		}
		else
		{
			GUI_SetBkColor(COLOR_MAIN_BG);
			GUI_SetColor(COLOR_LABEL);
			LanguageSelect(FONT20);
			GUI_DispStringInRect(_acacbmccb_iostatus_text[i], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);
			if(nDioStatus[IoStatus_Offset[i]] & IoStatus_bit[i])
			{
				GUI_SetColor(COLOR_ON);
				GUI_SetBkColor(COLOR_ON);
				GUI_FillRectEx(&rectOnOff);
				GUI_SetColor(GUI_WHITE);
				LanguageSelect(FONT20B);
				GUI_DispStringInRect(_aconoff_text[SettingValue[SETUP_LANGUAGE]][ON], &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);
			}
			else
			{
				GUI_SetColor(COLOR_OFF);
				GUI_SetBkColor(COLOR_OFF);
				GUI_FillRectEx(&rectOnOff);
				GUI_SetColor(GUI_WHITE);
				LanguageSelect(FONT20B);
				GUI_DispStringInRect(_aconoff_text[SettingValue[SETUP_LANGUAGE]][OFF], &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);
			}
		}
		if(i == ERMS)
		{
			rect.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rect.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectDescLocal.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectDescLocal.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectOnOff.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectOnOff.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;

			rect.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rect.y1 = (rect.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;
			rectDescLocal.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectDescLocal.y1 = (rectDescLocal.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;
			rectOnOff.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_STATUS_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectOnOff.y1 = (rectOnOff.y0 + ACBMCCB_IOSTATUS_STATUS_HEIGHT) - 1;
		}
		else
		{
			rect.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rect.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;

			rectDescLocal.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectDescLocal.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;

			rectOnOff.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectOnOff.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;
		}
	}
}

static void AcbMccbControlDisp(void)
{
	GUI_SetBkColor(COLOR_MAIN_BG);
	(void)GUI_SetPenSize(PENSIZE_LINE);
	(void)GUI_SetFont(&GUI_Font20_ASCII);

	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);

	GUI_RECT rect;
	rect.x0 = ACBMCCB_IOSTATUS_START_X;
	rect.x1 = (ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_X_DISTANCE + ACBMCCB_IOSTATUS_BOX_WIDTH) - 1;
	rect.y0 = ACBMCCB_IOSTATUS_START_Y;
	rect.y1 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_BOX_HEIGHT;

	GUI_RECT rectDescLocal;
	rectDescLocal.x0 = ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_DESC_X;
	rectDescLocal.x1 = (rectDescLocal.x0 + ACBMCCB_IOSTATUS_BOX_WIDTH) - 1;
	rectDescLocal.y0 = ACBMCCB_IOSTATUS_START_Y;
	rectDescLocal.y1 = (rectDescLocal.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;

	if(gCommStatus[gDeviceIndex] == COMM_OK)
	{
		GUI_SetColor(COLOR_MENU_SELECTED);
		GUI_FillRectEx(&rect);

		GUI_SetBkColor(COLOR_MENU_SELECTED);
		GUI_SetColor(GUI_WHITE);
		LanguageSelect(FONT20B);
	}
	else
	{
		GUI_SetColor(COLOR_MAIN_BG);
		GUI_FillRectEx(&rect);

//		GUI_SetBkColor(COLOR_MENU_SELECTED);
		GUI_SetColor(OFF_ON_BOX_COLOR);

		GUI_SetColor(COLOR_LINE);
		GUI_DrawRectEx(&rect);
		LanguageSelect(FONT20);
	}
			
//	(void)GUI_SetFont(&GUI_Font20B_ASCII);
//	GUI_DispStringInRect(_acacbmccb_cbstatus_control_text[ConnectSetting[gDeviceIndex].DeviceType], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);
	GUI_DispStringInRect(_acacbmccb_cbstatus_control_text[SettingValue[SETUP_LANGUAGE]], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);

	GUI_SetColor(GUI_BLACK);

	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
	{
		GUI_FillRectEx(&rectMccbBox);
		for(int i = 0; i < INDEX_3; i++)
		{
			GUI_SetColor(colorOffFillColor[i]);
			GUI_FillRectEx(&rectMccbStatus[i]);

			GUI_SetBkColor(colorOffFillColor[i]);
			GUI_SetColor(colorOffTextColor[i]);
			GUI_DispStringInRect(_accb_status[SettingValue[SETUP_LANGUAGE]][i], &rectMccbStatus[i], GUI_TA_HCENTER | GUI_TA_VCENTER);

		}
	}
	else
	{
		GUI_FillRectEx(&rectAcbBox);
		for(int i = 0; i < INDEX_2; i++)
		{
			GUI_SetColor(colorOffFillColor[i]);
			GUI_FillRectEx(&rectAcbStatus[i]);

			GUI_SetBkColor(colorOffFillColor[i]);
			GUI_SetColor(colorOffTextColor[i]);
			GUI_DispStringInRect(_accb_status[SettingValue[SETUP_LANGUAGE]][i], &rectAcbStatus[i], GUI_TA_HCENTER | GUI_TA_VCENTER);

		}
	}
	rect.x0 = ACBMCCB_IOSTATUS_START_X;
	rect.x1 = (ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_BOX_WIDTH) - 1;
	rect.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rect.y1 = (rect.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;

	rectDescLocal.x0 = ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_DESC_X;
	rectDescLocal.x1 = ACBMCCB_IOSTATUS_STATUS_X - 1;
	rectDescLocal.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rectDescLocal.y1 = (rectDescLocal.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;

	GUI_RECT rectOnOff;
	rectOnOff.x0 = ACBMCCB_IOSTATUS_START_X + ACBMCCB_IOSTATUS_STATUS_X;
	rectOnOff.x1 = (rectOnOff.x0 + ACBMCCB_IOSTATUS_STATUS_WIDTH) - 1;
	rectOnOff.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_STATUS_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
	rectOnOff.y1 = (rectOnOff.y0 + ACBMCCB_IOSTATUS_STATUS_HEIGHT) - 1;

	char *disableStatus = "-";

	for(int i = 0; i < IO_STATUS_COUNT; i++)
	{
		GUI_SetColor(COLOR_LINE);
		GUI_DrawRectEx(&rect);

		GUI_SetBkColor(COLOR_MAIN_BG);
		GUI_SetColor(OFF_ON_BOX_COLOR);
		LanguageSelect(FONT20);
		GUI_DispStringInRect(_acacbmccb_iostatus_text[i], &rectDescLocal, GUI_TA_LEFT | GUI_TA_VCENTER);

		GUI_SetColor(OFF_ON_BOX_COLOR);
		GUI_FillRectEx(&rectOnOff);
		GUI_SetColor(COLOR_LABEL);
		GUI_SetBkColor(OFF_ON_BOX_COLOR);
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			LanguageSelect(FONT20B);
		}
		else
		{
			LanguageSelect(FONT20);
		}
		GUI_DispStringInRect(disableStatus, &rectOnOff, GUI_TA_HCENTER | GUI_TA_VCENTER);

		if(i == ERMS)
		{
			rect.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rect.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectDescLocal.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectDescLocal.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectOnOff.x0 += ACBMCCB_IOSTATUS_X_DISTANCE;
			rectOnOff.x1 += ACBMCCB_IOSTATUS_X_DISTANCE;

			rect.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rect.y1 = (rect.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;
			rectDescLocal.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectDescLocal.y1 = (rectDescLocal.y0 + ACBMCCB_IOSTATUS_BOX_HEIGHT) - 1;
			rectOnOff.y0 = ACBMCCB_IOSTATUS_START_Y + ACBMCCB_IOSTATUS_STATUS_Y + ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectOnOff.y1 = (rectOnOff.y0 + ACBMCCB_IOSTATUS_STATUS_HEIGHT) - 1;
		}
		else
		{
			rect.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rect.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;

			rectDescLocal.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectDescLocal.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;

			rectOnOff.y0 += ACBMCCB_IOSTATUS_Y_DISTANCE;
			rectOnOff.y1 += ACBMCCB_IOSTATUS_Y_DISTANCE;
		}
	}
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       Createstatus_window
*/

//const char* KeyStr[COMM_STAT_ERROR+1] = {
//	"KEY_SETUP",
//	"KEY_UP",
//	"KEY_DOWN",
//	"KEY_ENTER",
//	"KEY_CANCEL",
//	"DATA_RECV",
//	"TIME_OUT",
//	"KEY_COMM_ERROR",
//	"COMM_STAT_ERROR",
//};

// PRQA S 1503 1
void AcbMccbControl(void)
{
	uint8_t bRecvData;
	int flagBreak = FALSE;
	bRecvData = FALSE;
	bUpdateFirst = TRUE;
	AcbMccbControlDisp();
	gStatusSendEnd = STATUS_SEND_ING;
	statusSendStep = 0;
	nSendStep = 0;
	AcbMccbControlSend();
	int bCommError = gCommStatus[gDeviceIndex];
	while (1)
    {
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			nSendStep = 0;
			AcbMccbControlSend();
		}
		else
		if(key == KEY_ENTER)
		{
			if(bRecvData == TRUE)
			{
				int flag = ControlCheck();
				(void)printf("nRemote=%d, flag=%d\n", nRemote, flag);
				if((nRemote == TRUE) && (flag == TRUE))
				{
					char buf[MESSAGE_BUF_SIZE];
					uint8_t status = AcbMccbcbStatus;
					uint16_t address=CB_STATUS_NOT_TRIO_ADDR;
					
					if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
					{
						if(status == CB_STATUS_INPUT_FAULT)
						{
							status = 0;
							address = CB_STATUS_MCCB_TRIP_ADDR;
						}
						else
						{
							address = CB_STATUS_MCCB_ADDR;
						}
					}
					else
					{
						if(nTrio != INDEX_7)		// TRIO 결선000b: TRIO Only, 001b: TRIO+ACB_OCR, 010b: TRIO+MCCB, 111b: ACB OCR Only
						{
							address = CB_STATUS_TRIO_ADDR;
						}
					}
					(void)sprintf(buf, _acacbMccbcontrol_confirm_text[SettingValue[SETUP_LANGUAGE]], _accb_control_status[SettingValue[SETUP_LANGUAGE]][AcbMccbcbStatus]);
					ControlSet(status, address, 0, buf, 1);
				}
				else
				{
					ControlErrorMessage(_acCBSetting_invalid_text[SettingValue[SETUP_LANGUAGE]]);
				}
				bUpdateFirst = TRUE;
				DispStatus();
				AcbMccbControlDisp();
				AcbMccbControlSend();
				gCommOldStatus[gDeviceIndex] = -1;
				CommTimerInit();
			}
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			AcbMccbControlDisp();
			gCommOldStatus[gDeviceIndex] = -1;
			AcbMccbControlSend();
		}
		else
		if(key == DATA_RECV)
		{
			(void)printf("DATA_RECV gStatusSendEnd=%d\n",gStatusSendEnd);
			if(bCommError == COMM_ERROR)
			{
				AcbMccbControlDisp();
				bCommError = COMM_OK;
			}
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				StatusRecv();
				AcbMccbControlSend();
			}
			else
			{
				AcbMccbIoValueDisp();
				g_bRecvAllDone = TRUE;
				nSendStep = 0;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
				bRecvData = TRUE;
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{

			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep); 
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
					AcbMccbControlSend();
					g_bRecvAllDone = TRUE;
					(void)printf("All done!!!\n");
					gStatusSendEnd = STATUS_SEND_ING;
					statusSendStep = 0;
					nSendStep = 0;
			}
/*			
			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep); 
			if(gAcbMccbSend == TRUE)
			{
				gAcbMccbSend =FALSE;
				statusSendStep = 0;
				gStatusSendEnd = STATUS_SEND_ING;
			}				
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				gAcbMccbSend = TRUE;
				AcbMccbControlSend();
			}
*/
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			bUpdateFirst = TRUE;
			(void)printf("COMM_STAT_ERROR\n\n");
			bCommError = COMM_ERROR;
			AcbMccbControlDisp();
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
	}
}

/*************************** End of file ****************************/
