/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define EXTERN extern
#include "stm32f4xx_hal.h"
#include "main.h"
#include "GuiData.h"

static void RelaySetSend(void);
static void RelaySetValueDisp(void);
static void AcbMccbRelaySetInitDisp(void);

//static uint16_t sendStep;
static void RelaySetSend(void)
{
	if(StatusSend() == STATUS_SEND_ING)
	{
		return;
	}
	
	(void)printf("RelaySetSend() nSendStep=%d\n", nSendStep);

	uint16_t len = ACB_RELAYSET_STEP1_READ_LEN;
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB)
	{
		if(nSendStep == 0)
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, HOLDING_REGISTER, ACB_RELAYSET_STEP0_READ_ADDR, ACB_RELAYSET_STEP0_READ_LEN);
		}
		else
		{
			ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, HOLDING_REGISTER, ACB_RELAYSET_STEP1_READ_ADDR+gGroupOffset[gDeviceIndex], len);
		}
	}
	else
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
	{
		len = MCCB_RELAYSET_READ_LEN;
		ModbusSendFrame(ConnectSetting[gDeviceIndex].Address, HOLDING_REGISTER, MCCB_RELAYSET_READ_ADDR+gGroupOffset[gDeviceIndex], len);
	}
	else {}
}

static void RelaySetValueDisp(void)
{
	if((ConnectSetting[gDeviceIndex].DeviceType == DEVICE_ACB) && (nSendStep == 0))
	{
		uint16_t group = ModbusGetUint16(H_REGISTER_50);
		if(group == 1)		//Group B
		{
			gGroupOffset[gDeviceIndex] = ACB_RELAYSET_GROUPOFFSET;
		}
		else
		{
			gGroupOffset[gDeviceIndex] = 0;
		}
		nSendStep = 1;
		return;
	}
	nSendStep = 0;
	char ampare[LINECOUNT_CONTENTS-1][DEFAULT_BUF_SIZE];
	char Sec[LINECOUNT_CONTENTS-1][DEFAULT_BUF_SIZE];

	uint8_t used = ModbusGetUint8_U(I_REGISTER_61+gGroupOffset[gDeviceIndex]);
	float l = (float)ModbusGetUint16(I_REGISTER_64+gGroupOffset[gDeviceIndex]);
	float t;
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
	{
		t = (float)ModbusGetUint16(I_REGISTER_65)/MCCB_TIME;
	}
	else
	{
		t = (float)ModbusGetUint16(I_REGISTER_65+gGroupOffset[gDeviceIndex])/PER_MAX;
	}
	if(used == INDEX_5)
	{
		(void)sprintf(ampare[0], 	"-");
		(void)sprintf(Sec[0], 	"-");
	}
	else
	{
		(void)sprintf(ampare[0], 	"%.1f A", l);
		(void)sprintf(Sec[0], 	"%.2f s", t);
	}
	uint16_t nPhaseProtect;
	if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB) // Inr은 Ir의 비율, MCCB의 tnr은 tr과 동일
	{
		used = 1;
		nPhaseProtect = ModbusGetUint16(I_REGISTER_104);
		if(nPhaseProtect <= 1)
		{
			used = INDEX_5;
		}
	}
	else
	{
		used = ModbusGetUint8_U(I_REGISTER_116+gGroupOffset[gDeviceIndex]);
	}
	if(used == INDEX_5)
	{
		(void)sprintf(ampare[1], 	"-");
		(void)sprintf(Sec[1], 	"-");
	}
	else
	{
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB) // Inr은 Ir의 비율, MCCB의 tnr은 tr과 동일
		{
			if(nPhaseProtect == INDEX_3)
			{
				l = l * 0.5;
			}
			else
			{
			}						 
			(void)sprintf(ampare[1], 	"%.1f A", l);
			(void)sprintf(Sec[1], 	"%.2f s", t);
			if(nPhaseProtect == INDEX_4)
			{
				(void)sprintf(ampare[1], "OSN");
			}
			else
			{
			}
		}
		else
		{
			(void)sprintf(ampare[1], 	"%.1f A", (l * ((float)ModbusGetUint16((I_REGISTER_119+gGroupOffset[gDeviceIndex]))/PER_MAX)));
			(void)sprintf(Sec[1], 	"%.2f s", (float)ModbusGetUint16(I_REGISTER_120+(gGroupOffset[gDeviceIndex]))/PER_MAX);
		}
	}
	used = ModbusGetUint8_U(I_REGISTER_67+gGroupOffset[gDeviceIndex]);
	if(used == INDEX_5)
	{
		(void)sprintf(ampare[INDEX_2], 	"-");
		(void)sprintf(Sec[INDEX_2], 	"-");
	}
	else
	{
		(void)sprintf(ampare[INDEX_2], 	"%.1f A", (float)ModbusGetUint16(I_REGISTER_71+gGroupOffset[gDeviceIndex]));
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			(void)sprintf(Sec[INDEX_2], 	"%.2f s", (float)ModbusGetUint16(I_REGISTER_72+gGroupOffset[gDeviceIndex])/MCCB_TIME);
		}
		else
		{
			(void)sprintf(Sec[INDEX_2], 	"%.2f s", (float)ModbusGetUint16(I_REGISTER_72+gGroupOffset[gDeviceIndex])/PER_MAX);
		}
	}
	used = ModbusGetUint8_U(I_REGISTER_87+gGroupOffset[gDeviceIndex]);
	if(used == INDEX_5)
	{
		(void)sprintf(ampare[INDEX_3], 	"-");
	}
	else
	{
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			(void)sprintf(ampare[INDEX_3], 	"%.1f A", (float)ModbusGetUint16(I_REGISTER_90+gGroupOffset[gDeviceIndex]));
		}
		else
		{
			(void)sprintf(ampare[INDEX_3], 	"%.1f A", (float)ModbusGetUint16(I_REGISTER_90+gGroupOffset[gDeviceIndex]) * TEN);
		}
	}
	Sec[INDEX_3][0] = 0;
	used = ModbusGetUint8_U(I_REGISTER_94+gGroupOffset[gDeviceIndex]);
	if(used == INDEX_5)
	{
		(void)sprintf(ampare[INDEX_4], 	"-");
		(void)sprintf(Sec[INDEX_4], 	"-");
	}
	else
	{
		if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
		{
			(void)sprintf(ampare[INDEX_4], 	"%.1f A", (float)ModbusGetUint16(I_REGISTER_98+gGroupOffset[gDeviceIndex])/FLOAT_TEN);
			(void)sprintf(Sec[INDEX_4], 	"%.2f s", (float)ModbusGetUint16(I_REGISTER_99+gGroupOffset[gDeviceIndex])/MCCB_TIME);
		}
		else
		{
			(void)sprintf(ampare[INDEX_4], 	"%.1f A", (float)ModbusGetUint16(I_REGISTER_98+gGroupOffset[gDeviceIndex]));
			(void)sprintf(Sec[INDEX_4], 	"%.2f s", (float)ModbusGetUint16(I_REGISTER_99+gGroupOffset[gDeviceIndex])/PER_MAX);
		}
	}

	GUI_SetColor(COLOR_VALUE);
	(void)GUI_SetFont(&GUI_Font20B_ASCII);
	GUI_SetBkColor(COLOR_MAIN_BG);

	GUI_RECT rect;
	rect.x0 = ACBMCCB_RELAYSET_AMPARE_X0 ;
	rect.y0 = ACBMCCB_RELAYSET_GRID_Y0+1;
	rect.x1 = (rect.x0 + ACBMCCB_RELAYSET_VALUE_WIDTH) - 1;
	rect.y1 = (ACBMCCB_RELAYSET_GRID_Y0 + HEIGHT_VALUE) - INDEX_2;
	for(int i = 0 ; i < (LINECOUNT_CONTENTS-1); i++)
	{
		GUI_ClearRectEx(&rect);
		GUI_DispStringInRect(ampare[i], &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
		rect.y0 += HEIGHT_VALUE;
		rect.y1 += HEIGHT_VALUE;
	}

	rect.x0 = ACBMCCB_RELAYSET_VALUE2_X0;
	rect.y0 = ACBMCCB_RELAYSET_GRID_Y0+1;
	rect.x1 = (ACBMCCB_RELAYSET_VALUE2_X0 + ACBMCCB_RELAYSET_VALUE_WIDTH) - 1;
	rect.y1 = (ACBMCCB_RELAYSET_GRID_Y0 + HEIGHT_VALUE) - INDEX_2;
	for(int i = 0 ; i < (LINECOUNT_CONTENTS-1); i++)
	{
		GUI_ClearRectEx(&rect);
		GUI_DispStringInRect(Sec[i], &rect, GUI_TA_RIGHT | GUI_TA_VCENTER);
		rect.y0 += HEIGHT_VALUE;
		rect.y1 += HEIGHT_VALUE;
	}
}

#define CH_ACBMCCB_RELAYSET_LABEL1_X0		5
#define CH_ACBMCCB_RELAYSET_LABEL1_WIDTH	130

static void AcbMccbRelaySetInitDisp(void)
{
	GUI_SetBkColor(COLOR_MAIN_BG);

	(void)GUI_SetPenSize(PENSIZE_LINE);
	GUI_SetColor(COLOR_LINE);

	GUI_ClearRect(X0_MAIN, Y0_MAIN, X1_MAIN, Y1_MAIN);
	GUI_DrawRect(ACBMCCB_RELAYSET_GRID_X0, ACBMCCB_RELAYSET_GRID_Y0, ACBMCCB_RELAYSET_GRID_X1, ACBMCCB_RELAYSET_GRID_Y1);

	for(int i = 0; i < (LINECOUNT_CONTENTS-INDEX_2); i++)
	{
		int y0 = ACBMCCB_RELAYSET_GRID_Y0 + ((i + 1) * HEIGHT_VALUE);
		GUI_DrawHLine(y0, ACBMCCB_RELAYSET_GRID_X0, ACBMCCB_RELAYSET_GRID_X1);
	}
	GUI_DrawVLine(ACBMCCB_RELAYSET_GRID_X, ACBMCCB_RELAYSET_GRID_Y0, ACBMCCB_RELAYSET_GRID_Y1);

	GUI_SetColor(COLOR_LABEL);

	GUI_RECT rect;
	for(int i = 0; i < INDEX_3; i++)
	{
		if(i == INDEX_0)
		{
			LanguageSelect(FONT20);
			if(SettingValue[SETUP_LANGUAGE] == CHINESE)
			{
				rect.x0 = CH_ACBMCCB_RELAYSET_LABEL1_X0;
				rect.x1 = (CH_ACBMCCB_RELAYSET_LABEL1_X0 +  CH_ACBMCCB_RELAYSET_LABEL1_WIDTH) - 1;
			}
			else
			{
				rect.x0 = ACBMCCB_RELAYSET_LABEL1_X0;
				rect.x1 = (ACBMCCB_RELAYSET_LABEL1_X0 +  ACBMCCB_RELAYSET_LABEL1_WIDTH) - 1;
			}
		}
		else
		if(i == INDEX_1)
		{
			(void)GUI_SetFont(&GUI_Font20_ASCII);
			rect.x0 = ACBMCCB_RELAYSET_LABEL2_X0;
			rect.x1 = (ACBMCCB_RELAYSET_LABEL2_X0 +  ACBMCCB_RELAYSET_LABEL2_WIDTH) - 1;
		}
		else
		if(i == INDEX_2)
		{
			(void)GUI_SetFont(&GUI_Font20_ASCII);
			rect.x0 = ACBMCCB_RELAYSET_LABEL3_X0;
			rect.x1 = (ACBMCCB_RELAYSET_LABEL3_X0 +  ACBMCCB_RELAYSET_LABEL3_WIDTH) - 1;
		}
		else {}
		rect.y0 = ACBMCCB_RELAYSET_GRID_Y0;
		rect.y1 = (ACBMCCB_RELAYSET_GRID_Y0 +  HEIGHT_LABEL) - 1;

		for(int j= 0 ; j < (LINECOUNT_CONTENTS-1); j++)
		{
			GUI_DispStringInRect(_acrelayset_label_text[SettingValue[SETUP_LANGUAGE]][i][j], &rect, GUI_TA_LEFT | GUI_TA_VCENTER);
			rect.y0 += HEIGHT_LABEL;
			rect.y1 += HEIGHT_LABEL;
		}
	}
}

// PRQA S 1503 1
void AcbMccbRelaySet(void)
{
	int flagBreak = FALSE;
	AcbMccbRelaySetInitDisp();
//	gGroupOffset[gDeviceIndex] = 0;
	nSendStep = 0;
	RelaySetSend();
	while (1)
    {
		E_KEY key = GetKey();

		if(key == TIME_OUT)
		{
			gStatusSendEnd = STATUS_SEND_ING;
			statusSendStep = 0;
			nSendStep = 0;
			RelaySetSend();
		}
		else
		if(key == KEY_SETUP)
		{
			if(Setup() == SETUP_CHANGED)
			{
				flagBreak = TRUE;
			}
			AcbMccbRelaySetInitDisp();
			gCommOldStatus[gDeviceIndex] = -1;
		}
		else
		if(key == DATA_RECV)
		{
			if(gStatusSendEnd == STATUS_SEND_ING)
			{
				nSendStep = 0;
				StatusRecv();
				RelaySetSend();
			}
			else
			{
				RelaySetValueDisp();
				
				if(nSendStep != 0)
				{
					RelaySetSend();
				}
				else
				{
					g_bRecvAllDone = TRUE;
			
					(void)printf("All done!!!\n");
					gStatusSendEnd = STATUS_SEND_ING;
					statusSendStep = 0;
					nSendStep = 0;
				}
			}
		}
		else
		if(key == KEY_CANCEL)
		{
			flagBreak = TRUE;
		}
		else
		if(key == KEY_COMM_ERROR)
		{
			(void)printf("COMM Error!!! gStatusSendEnd=%d, statusSendStep=%d, nSendStep=%d\n",gStatusSendEnd,statusSendStep,nSendStep); 
			if(gStatusSendEnd == STATUS_SEND_END)
			{
				nSendStep++;
			}
			if(StatusRecvErrorProcess() == STATUS_SEND_ING)
			{
				nSendStep = 0;
			}
			else
			{
				int nStepMax;
				if(ConnectSetting[gDeviceIndex].DeviceType == DEVICE_MCCB)
				{
					nStepMax = 1;
				}
				else
				{
					nStepMax = INDEX_2;
				}
				
				if(nSendStep < nStepMax)
				{
					RelaySetSend();
				}
				else
				{
					g_bRecvAllDone = TRUE;
			
					(void)printf("All done!!!\n");
					gStatusSendEnd = STATUS_SEND_ING;
					statusSendStep = 0;
					nSendStep = 0;
				}
			}
		}
		else
		if(key == COMM_STAT_ERROR)
		{
			AcbMccbRelaySetInitDisp();
		}
		else {}
		if(flagBreak == TRUE)
		{
			break;
		}
	}

}

/*************************** End of file ****************************/
